<xml>
<doc title='013.txt'>
experiments  density-constrained graph clustering.
abstract.
clustering  graph means identifying internally dense.
subgraphs    sparsely interconnected. formalizations   notion lead  measures  quantify  quality   clustering   algorithms .
actually find clusterings. since,  generally, corresponding optimization problems  hard, heuristic.
clustering algorithms  used  practice,   approaches    based   objective function.
  work  conduct  comprehensive experimental.
evaluation   qualitative behavior  greedy bottomup heuristics driven  cut-based objectives  constrained  intracluster density, using  real-world.
data  artificial instances.  study documents .
 greedy strategy based  local movement  superior.
 one based  merging.   reveal   former approach generally outperforms alternative setups.
 reference algorithms   literature  terms .
  objective,   modularity-based algorithm.
competes surprisingly well. finally,  exhibit .
combinations  cut-based inter-  intracluster measures  suitable  identifying  hidden reference clustering  synthetic random graphs.  results serve .
 guideline   usage  bicriterial, cut-based measures  graph clusterings.
. introduction.
graph clustering aims  finding subsets  vertices.
  densely connected     sparsely.
connected   remainder   graph.  .
last decades, interest  graph clustering algorithms .
grown rapidly,  applications ranging  customer.
recommendation systems   analysis  networks.
describing social ties  protein-protein interaction. .
variety  measures   proposed,   used.
 assess  compare different clusterings   guide.
 design  algorithms. traditional methods .
algorithmics often focus  sparse cuts  respect .
measures like conductance .  expansion ., ,.
. work  partially supported   dfg  grant.
 .
.institute  theoretical informatics, karlsruhe institute .
technology .kit., karlsruhe, germany.
independent  ,  measure called modularity .
proved  yield meaningful clusterings   wide range.
 application data.
recently,  systematically assembled  range .
self-evident intracluster density  intercluster sparsity.
measures  clusterings,   latter  based .
conductance , expansion  density   cuts induced.
  clusters .   formally stated .
problem density-constrained clustering .dcc.,.
  objective   optimize intercluster sparsity.
  constraint   intracluster density must.
exceed  given threshold.  optimal polynomialtime algorithms  dcc  unknown,  investigated.
 different combinations  intracluster sparsity .
intercluster density measure influence  efficiency  .
greedy optimization strategy based  cluster merging.
however, little  known   qualitative behavior.
 practical scenarios,   experimental evaluation.
 dcc  yet  missing.
 contribution.  provide  comprehensive.
study   practical behavior  greedy graph clustering heuristics driven  cut-based objectives .
constrained  intracluster density.  give evidence.
,  general, greedy algorithms based  local vertex moves lead  better quality   corresponding.
merge-based algorithm.   compare  movebased algorithm   set  reference algorithms  .
literature,   respect   objective  dcc.
  ability  reconstruct planted partitions  .
family  synthetic graphs.  find   greedy.
move algorithm compares favorably   reference.
algorithms   context  dcc,   comparison   modularity-based algorithm shows .
optimizing modularity implicitly yields good results .
 variants  dcc. experiments  planted partition graphs suggest  certain combinations  interand intracluster measures  effective  finding .
hidden clustering,  others clearly fail. together.
 observations   number  identified clusters,  yields valuable insights   behavior .
 respective intra-  intercluster density measures.
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . density measures.
intracluster density.
global gid.
.
. .
. .
.
. .
minimum mid min.
.
.
. .
average aid .
.
.
.
. .
intercluster density.
global gxd.
.
. ,.
. nanb.
maximum mixd max.
.
.
ncnv .
average aixd .
.
.
.
ncnv .
intercluster conductance.
maximum mixc max.
.
, .
min. , .
average aixc .
.
.
, .
min. , .
intercluster expansion.
maximum mixe max.
.
, .
min. , .
average aixe .
.
.
, .
min. , .
intercluster edges.
global nxe.
.
.cma,.
modularity.
global mod.
.
. .
.
.
.
. .
.
.
.
related work. related clustering algorithms  iterative conductance cutting ., markov-clustering.
., geometric mst clustering .   modularitybased greedy algorithm based  vertex moves . .
use   reference algorithms. kannan  . propose  minimize  cut , subject   guaranteed conductance within clusters .,   closely.
related   dcc.   show  iterative.
conductance cutting  polylogarithmic approximation guarantees     measures. brandes .
. conduct  experimental study   performance .
iterative conductance cutting, markov-clustering .
geometric mst clustering,   respect  quality  running times .  similar,   recent.
study   found  . flake  . give  clustering.
algorithm  provable,  interdependent bounds .
 intra-   variant  intercluster expansion. .
notion  modularity  introduced  .,  extensive  recent overview   research    .
found  . apart  ,    huge number.
 publications  graph clustering,   overview see.
., .
. preliminaries.
notation.   . .,.   undirected, unweighted,  simple graph, .   loopless  .
 parallel edges.   following,  will always denote.
 number  vertices    number  edges  .
 two subsets      , , . .
., . .  .
 . ,  . .   number  edges    ,.
 . .   number  vertices  ,  . .
  number  intracluster edges   . , .
 number  intercluster edges incident  . ,.
 volume     defined   .
.
. deg.
 conductance   cut .,  . measures  bottleneck.
    , defined .
,.
min. , . . expansion substitutes volume  cardinality.
,.
min. , . .  density.
. sparsity.   cut .
,.
nsnt.
,  equals  uniform.
minimum-ratio cut.  restrict   disjoint.
clusters   work,  means,   . ., . . . , .
  partition   ,  call   clustering    .
sets  clusters.  cluster containing vertex   .
  clustering  results  moving vertex  .
cluster , .
. ., .,.,  abbreviated  .  clustering  trivial  either  . .
.all-clustering.,   cluster contains  one element .singletons.  identify  cluster   .
set  nodes  constitutes    vertex-induced.
subgraph  .  . . . .  called.
intracluster edges   . . intercluster edges. .
clustering measure   function  maps clusterings.
 real numbers, thereby assessing  quality   clustering.  define high quality  correspond  high.
.low. values  intracluster .intercluster. measures .
will always denote intracluster density measures  .
 intercluster density measures  , unless otherwise stated.
intracluster density  intercluster sparsity.
measures.  intercluster measures  use  based.
 cuts  k-way cuts. separating  single cluster .
 remaining vertices induces  cut, whose sparsity .
 evaluated using density, conductance  expansion.
 defines  set  sparsity values   whole clustering,     either compute  average .
 maximum, yielding maximum.average intercluster.
density.conductance.expansion .mixd, aixd, mixc, aixc,.
mixe  aixe. another point  view   evaluate.
 clustering   whole, .  assess  sparsity .
 induced k-way cut directly.     either.
counting  number  intercluster edges .nxe.  .
dividing  number  intercluster edges   maximum possible number, .  number  intercluster.
pairs .gxd.   possible  use similar, cut-based measures  intracluster density. however, even evaluating.
 measures   given clustering  np-hard, .
.note   keep     abbreviations, although .
contrast  .,    distinguish  pairwise .
isolated measures.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 clustering algorithms usually work  approximations  bounds ., ., .   intend  use.
intracluster density measures  constraints  greedy.
bottom-up algorithms,   crucial   able  evaluate  efficiently.  therefore use   practical.
approach  define intracluster density   ratio .
 number  intracluster edges   number  intracluster pairs. evaluating  globally leads  global.
intracluster density .gid., whereas  average  minimum   clusters yields average  minimum intracluster density .aid  mid.
table . summarizes  formalizations   measures considered. note ,  contrast   set .
measures used  .,  omit  notions  pairwise.
densities   turned     prone  local minima  used  greedy bottom-up algorithms.
although    quite fit   classification,.
table . also includes  objective used  one  .
reference algorithms, modularity,  simultaneously.
assesses intracluster density  intercluster sparsity .
subtracting   fraction  intracluster edges .
expectation   value   random graph .note .
high modularity corresponds  high quality.
density-constrained clustering. densityconstrained clustering .dcc.   problem .
optimizing intercluster density  retaining guarantees   intracluster density. considering .
combination  intracluster  intercluster measure.
listed  table . leads   family  optimization.
problems. slightly abusing  notation,  consider.
modularity   intercluster density objective  .
context.
problem . .density-constrained clustering.
given  graph  . .,., among  clusterings .
 intracluster density   less  ., find .
clustering   optimum intercluster quality.
. greedy algorithms  density-constrained.
clustering.
 following generic greedy algorithms heuristically.
minimize .maximize.  objective function  dcc .
 density measures considered.
greedy merge . starting  singletons, .
algorithm greedily merges pairs  clusters.  .
step, among  pairs  clusters whose merge  .
violate  constraint   intracluster density, .
merge   largest benefit   intercluster density.
 performed.  recently proposed  algorithm .
 context  dcc .  classified combinations.
 intercluster  intracluster density  respect.
  question  efficiently  algorithm  .
implemented. algorithms   kind  common.
  context  clustering point sets  d-dimensional.
space,   basic constraint    number .
clusters must  fall   certain threshold. .
 field  graph clustering,  algorithm  used .
optimize modularity .
algorithm .greedy vertex moving .gvm.
input . graph  . .,., inter, intra, .
output. clustering .  .
. . , . .
repeat.
 . .,singletons., intra, inter, .
. . contract., .
. . .
   real contractions.
  . . .
. . .
 . project., .
 . ., , inter, intra, .
end.
return .
algorithm . local moving .
input . graph  . .,., clustering cinit  , inter,.
intra, .
output. clustering   .
 . cinit.
repeat.
forall   .  .
. .  . intra.  ., .
 . arg min.
.
.inter.
 inter. . . inter.  move.,.
end.
   changes.
return .
greedy vertex moving .gvm.  key ingredient.
 gvm .algo. .   subprocedure  tries  greedily.
improve  objective function  letting vertices move.
 neighboring clusters .algo. .  subprocedure.
repeatedly iterates   vertex set ,  .
vertex, performs   improving move .subject .
 constraint., potentially isolating  vertex,  leaving.
   ,   local optimum  reached. starting  singletons, gvm first calls  subprocedure.
 contracts  resulting preliminary clustering  .
super-graph, .  cluster becomes  vertex weighted.
  number  vertices  represents,  edges .
summarized   edge weights reflect  number.
 edges   original graph.  whole process .
iterated  local moving   yield  .
improvement,  results   hierarchy  graphs .
increasing coarseness.   second phase .refinement.,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 hierarchy  unfurled step  step  projecting .
clustering    . .-th level   hierarchy  level.
, .  clusters  level   merged according  .
clustering  level  . .   step,   called.
   current level   hierarchy  potentially.
improve  objective function ,   clustering.
  finest level, .  original graph,  obtained.
gvm  closely related  algorithms   context.
 graph partitioning   previously  used .
modularity-based clustering without constraints ., .
neither approximation guarantees  subexponential.
bounds   running time  known,  experimentally    shown  outperform  corresponding greedy merge algorithm  respect  .
quality  efficiency.  modularity,   easily .
shown  moving  vertex   cluster    linked.
  never  best choice, therefore  suffices  consider neighboring clusters. together   observation   change  modularity   determined .
constant time   move   information .
 clustering  maintained,  yields  running time.
 .   round  .  latter observation.
 running time also holds   intracluster density.
 intercluster sparsity measures except  mixd, mixc.
 mixe, whose values  expensive  maintain.
ensuring strict improvements. another issue .
 direct application  gvm  maximum-based measures   iteratively traversing  whole vertex set.
 inefficient     vertex moves potentially.
decrease  cut   cluster   currently worst.
value. even worse,   cluster   unique,  .
likely   search  stuck   local minimum, .
vertex moves generally   improve  value .
one   cluster,      simultaneously.
  try  prevent   allowing vertex moves .
  strictly improving,  somehow   ensure.
  algorithm terminates   finite number .
operations.      similar way  proposed.
 .    greedily optimizing  lexicographical order   intercluster sparsity values   .
clusters.  . . ., . . . , .,  . , .
 sequence   values  decreasing intercluster.
density, . . . .   . ., . . . , . .
 clustering   l-better  .  .  lexicographically less  .  now determine   vertex.
 set  clusterings    reached  moving .
 one   clusterings  l-better   current.
clustering,  move  results   l-best sequence.
 performed.   strictly improve  lexicographical order   step, termination  guaranteed. .
means,  greedily optimize  maximum value .
 also allowed  improve  intercluster sparsity .
clusters  locally, yielding better efficiency  .
.
.
. mixd, mixe.
.
.
. mixc.
.
.
. aixc, aixe, aixd.
figure . examples illustrating   measures considered   enforce connected moves. given  clusterings.
indicated   gray areas, among  moves involving ,.
moving   cluster . yields  largest decrease  .
objective function.
possibility  escape local minima.
determining  best move  .deg. time.
using  following observation,    seen .
 two clusterings resulting  leaving vertex .
untouched   moving    different . new.
cluster   l-compared  constant time.
observation .  three distinct clusters ,  .
     .   holds .
. .  l-better   .
.
 . .,  . . .
l-better  .,.
. .  l-better  . .
.
 . ., . .
l-better .
.
 . ., .
  volume, size  number  out-going edges.
  clusters ,     maintained .
 algorithm,  density.conductance.expansion .
,,,., .  .   determined .
constant time. hence,  conditions   right-hand.
side   evaluated  constant time,   .
used  determine  best move   vertex efficiently.
furthermore,   immediate  moving  vertex.
  cluster    linked   never decrease .
number  intercluster edges .nxe.    hold.
 gxd, however,  following equation shows .
gvm never   consider non-neighboring clusters .
gxd,  isolating  respective vertex  always .
. copyright . siam.
unauthorized reproduction   article  prohibited.
beneficial.   .  ,  . . . .   .  .
 ., . ., .
gxd. .
.
, ,.
mci, .,.
, ,.
. . .
.
.
, ,.
mci, ., .
. . .
.,.
, ,.
. . . . .
.
. gxd.
   intercluster density measures   .
hold    seen   examples  fig. .  configurations like    expected  degenerate.
cases,  impact  efficiency  large  sparse graphs,.
 unconnected clusters   desirable   context  graph clustering,  chose  restrict  set .
feasible moves  neighboring clusters. together .
 possibility  compare different moves  constant.
time,  get  time complexity  .   round.
  local move procedure     combinations.
considered.
. experiments.
qualitative comparison  greedy merge .
greedy vertex moving.  first experiments.
address  question  flavor  greedy algorithm.
 better suited  dcc.  test instances,  used .
graphs listed  table .  less  . vertices,.
  real-world networks taken   websites.
 mark newman .  alex arenas .  .
proposed combinations  measures, figure . shows .
ratio   intercluster density obtained  using gvm.
 , averaged   graphs.  modularity, .
ratio  always greater  one, confirming  local.
moving yields better results, regardless   choice.
 strength   constraint.  combination .
gid  mid,  similarly holds    objectives.
except  nxe, note ,  contrast  modularity, .
aim  minimize  measures  therefore  value.
 one means  gvm attains better results. .
nxe,  outcome depends   value  . chosen.
 combination  aid,  outcome  less clear,.
 results  nxe    bounds   ratio .
 configurations exceeds . percents.   .
explained   observation  aid happily allows.
. thereby encourages. unbalanced clusterings,  bad.
intracluster density values  large clusters  easily .
compensated   set  small  dense clusters, .
  known    tendency  produce unbalanced.
partitions.    often leads  unintuitive.
clusterings,  deem aid less suitable   context .
graph clustering. disregarding aid   reasons,  .
vast majority  configurations, gvm outperforms .
 tackling dcc,  thus solely use gvm, putting.
aside  algorithm based  greedy merging.
effectiveness  different objective functions.
 next question  pose ,     intercluster.
density measures  effective  optimizing  .
used  inter  gvm.  answer  question,  conducted  following experiment   set  graphs.
listed  table .   following,  gvmi,., denote gvm incorporating  constraint . . . .
 objective .   setup  dcc, . intracluster measure , intercluster measure   . .
., ., . . . , .,  ranked  clusterings obtained.
 gvmi,.,   performance  respect  ,.
using  possible objectives   gvm. figure . shows.
 distribution   ranks   configurations.
involving gid, grouped  .  outcome   experiment  less clear   might  expected.none.
  intercluster measures,  even modularity, scores.
 best quality  respect     configurations. nonetheless,  general, except  nxe  .
clearly dominated  gxd,  objective optimizes  quite well.  also holds  mid,   aid, .
outcome  even less clear,    seen  figures .,.
.  app. .
reference algorithms.    comprehensive.
assessment  gvm   means  address dcc, .
use  following reference algorithms.
. iterative conductance cutting .icc. . .
top-down algorithm iteratively splits  input.
graph  two subgraphs based   cut  low.
conductance.  process stops   conductance   cut exceeds  given threshold, .
 set  .   experiments.
. markov-clustering .mcl. . emulating  random walk,  matrix  transition probabilities .
alternately taken    power    renormalized  taking  entry   power  , .
    input parameters.   experiments,.
 set     . . equals  parameter setting used  .
. geometric mst clustering .gmc. . first, .
spectral embedding   graph  d-dimensional.
space  built.   algorithm constructs .
euclidean minimum spanning tree  successively.
deletes  heaviest edge.  defines  sequence .
forests whose connected components induce  set .
clusterings. among  clusterings,  one .
 best value according   given objective.
function  chosen.
. copyright . siam.
unauthorized reproduction   article  prohibited.
graph   graph   graph  .
karate. . . celegansneural. . . astro-ph. . .
dolphins. . . celegans metabolic. . . cond-mat. . .
lesmis. . . polblogs. . . as-.july. . .
polbooks. . . netscience. . . cond-mat-. . .
adjnoun. . . power. . . cond-mat-. . .
football. . . hep-th. . .
jazz. . . pgpgiantcompo. . .
table . list   real world test instances ordered  increasing number  vertices.   taken   webpages.
 arenas. .  newman. .   often used  compare clustering algorithms.
figure . qualitative comparison  gvm  .
. multi-level modularity .ml-mod. .  .
 gvm-algorithm based solely  modularity.
without using  constraint.  algorithm .
 shown  perform  well   context .
modularity optimization .
comparison based  intracluster density.
found  reference algorithms. icc, mcl .
ml-mod   incorporate constraints   intracluster density   resulting clustering. nonetheless,.
  still possible  evaluate   respect  .
variants  dcc,  .  set   intracluster density found   algorithms.   words, given .
 constraint  reference algorithm  implicitly adheres ,  well  gvm compare   wrt. dcc.
 first ran icc, mcl  ml-mod  .
test instances  table .  recorded  intracluster.
density values   resulting clusterings. , .
 reference algorithm , , recorded corresponding.
intracluster density .  ,  compare  clustering.
obtained  gvmi,.,   clustering   .
respect  .  gmc  experiments slightly differ.
 gmc requires  objective function.  filled .
degree  freedom  choosing . . . . . .
 objective function   experiments using  .
intracluster    intercluster density measure. .
seemed    fairest way  comparison  .
almost  cases led  non-trivial clusterings.
table . shows   percentage  graphs .
 greedy algorithm   compares favorably .
 arithmetic mean   ratio   obtained .
gvm    reference algorithm.   aim .
minimize intercluster density,  value  . indicates.
  greedy algorithm succeeds  beating .
reference algorithm  vice versa. compared  icc.
 mcl, gvm clearly yields better results. .
 holds  gmc, except  used  combination.
 aid,  gmc sometimes produces far better.
results.    explained   fact  aid.
  punish unbalancedness  gmc naturally.
leads   unbalanced clusterings   instances.
 outcome   comparison   modularitybased algorithm  less clear.  aid, gvm performs.
better,    surprising  modularity strongly.
discourages unbalanced clusterings.  mid, gvm still.
beats ml-mod   majority  configurations, .
 gid,   holds  slightly less  half  .
configurations. furthermore,   worth mentioning.
 especially  aixd  aixe   instances.
 modularity minimizes  functions far better.
  respective greedy algorithms. altogether, .
comparison  icc, mcl  gmc suggests .
gvm effectively addresses dcc,   comparison.
 ml-mod shows  optimizing modularity .
similarly effective  minimizing cut-based intercluster.
figure . ranks  different intercluster density measures  objectives   gvm-algorithm using gid  constraint,.
evaluated   intercluster density   resulting clustering.
gid mid aid.
table . comparison  gvm  reference algorithms. entries    form .,     percentage  graphs.
gvm compares favorably     mean ratio   obtained  gvm  reference algorithm.
sparsity measures.
recovering planted partitions.  compare .
different objective functions qualitatively,  evaluated.
 well  corresponding gvm-algorithms  able.
 reconstruct planted partitions  random graphs. .
 comparison,  also give  results obtained  mlmod. due  higher running times  large numbers.
 experiments,  omit  comparison  icc, mcl.
 gmc.
random graphs generated.  use  adapted.
erdo.s-re.nyi-model, , starting   given reference partition,  probability  vertices   .
set . different sets.  connected equals pin .pout.
 number  vertices .  clusters .  well .
 skewness   distribution  cluster sizes . .
 planted partition  input parameters. setting .
 . corresponds  uniform cluster sizes, values    . cause  distribution   skewed,.
  details see .  configurations,  fixed .
 .  chose pin  pout    average.
number  intracluster .intercluster. edges  vertex  incident  equals . .  determine  reference partition,  used  combinations   . ., ., . .
. . ., ., .   configuration,  generated.
. instances  always averaged obtained values.
distance measures.  compare  clusterings obtained   different algorithms   reference.
clustering,  use  following graph-based distance.
measures taken  .
. graph-based rand index .  .  . .
clusterings  . .  number  edges .
 intracluster .intercluster. wrt.  .  .
figure . distance  reference clustering .boxplots, left-hand y-axis.  number  clusters discovered  planted partition.
graphs .green .-marks, right-hand y-axis., different configurations.
unauthorized reproduction   article  prohibited.
, ., . . . . . .
. editing set difference .esd.   clustering.
,  editing set    set  edges requiring.
insertion  removal    clusters  .
form disjoint cliques. ,  clusterings .
 .,  editing set difference  defined .
esd., . . . . . . . . . .
parameters  evaluation.   exhaustive parameter search   configurations   far .
expensive,  always set .  . percent   expected global intra-cluster density pin.  deemed taking  actual value  pin  strict, , especially .
mid, even  reference clustering   generator .
likely   meet  constraint.  previous experiments indicate    configurations .
particular objective functions used  gvm   score.
 best results  respect  .   goal.
  compare good clusterings  respect  different combinations    , independent  artifacts .
gvm,  chose  following approach.   combination , ., ,  evaluated  clustering , among .
results obtained  gvm using  . .  constraint,.
 best  respect   . opposed  simply evaluating gvmi,.,. furthermore, preliminary experiments.
confirmed  constraining aid leads   unintuitive  unbalanced clusterings,   mirrored .
 fact   corresponding versions  dcc  far.
less effective  finding  hidden clustering.  .
reason,  excluded aid   discussion   results.
results  planted partition graphs. figure .
shows  results  selected configurations,  results.
  whole set  experiments  respect   .
 found  app. ,  additional plots evaluating esd.
see  extended version .   first plot   .
seen ,  general,  clusterings   ranked.
best  respect  mod, nxe  gxd   similar.
  reference.
constraining modularity  mid improves  results.  especially holds   experiments .
high skewness . . .   . .   experiments, modularity finds far less clusters  expected,.
partially due   known resolution limit ., .
  circumvented  steering  coarseness  .
clustering  constraining  intracluster density. another interesting fact   esd punishes  coarse.
clustering obtained  pure modularity far  .
.
fine reference clusterings disbalance maximum objectives. compared   , especially mixc  combination  gid yields worse similarity values. ,.
  slightly increased cluster count   explained.
  tendency  mixc  favor unbalanced clusterings .
 expected number  clusters  high . . ., .
also explains   effect   happen  combination  mid    allow  unbalanced.
clusterings.   smaller extent,   observation.
also holds    maximum measures,   .
seen   . .  . . .
aixe  especially aixd identify many clusters. another striking observation    average number.
 clusters  clusterings found  aixd  aixe, indicated   green .-marks,  much higher  .
average number  clusters   reference.  especially stems   experiments   clusters. .
 configuration  . . .   . .,   also .
seen   measures differ  ,  coarser .
expected clustering gets.    unexpected,  .
denominator  aixd grows  slowly   number.
 vertices   cluster   denominator  aixe,.
meaning  aixd  less eager  produce  large.
clusters. additionally,  .   proven  .
 exception  aixd,  inter-cluster measures considered   always  ameliorated  merging two.
existing clusters .unboundedness.,   also  hint.
 aixd  less likely  produce coarse clusterings .
  measures.
selected clusterings  small example network.
figure . demonstrates  differences  intercluster measures   small network reflecting social interaction   group  . dolphins .    .
want  introduce  artificial bias towards  particular clustering,  .force-directed. layout   vertices.
figure . network  frequent associations  .
dolphins   community living  doubtful sound, new.
zealand .  clusterings displayed  obtained .
optimizing  measures mixe .fill color., aixd .vertex shape.
 mod .border color.  gvm   restriction.
gid . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
  use  information   clustering. .
 restriction gid . ., aixd dominates nxe, gxd .
mixd   sense   clustering obtained  optimizing aixd  gvm yields less intercluster edges.
 lower values  gxd  mixd   corresponding clusterings obtained  optimizing  measures.
directly. similarly, mixe dominates aixc  mixc, .
aixc dominates aixe. due     retain visual.
clarity,   give  clusterings obtained  aixd,.
mixe  mod. aixc  omitted   respective.
clustering   similar   one obtained  mixe,.
  differ   assignment   vertices connecting  left   right part.
compared  mixe,  clustering obtained  mod.
introduces two new clusters  consist   vertices.
connecting  left   right part.  main difference   clusterings   one obtained.
 aixd   assignment   nine vertices  .
right side    sparsely connected   remainder   graph. mixe  mod assign   .
 clusters   connected   aixd essentially leaves  unclustered. overall,  clusterings.
 rather similar   sense    vertices.
 treated differently,    either connecting .
two parts    loosely connected   network.  human observer might argue  favor  .
  clusterings considered,   group affiliation .
 vertices seems ambiguous.
 reason  nxe, gxd  mixd  dominated.
 aixd    respective versions  gvm merge.
 sparsely connected vertices   right side .
 anchor vertices   early stage   algorithm.
isolating  vertices later    possible, .
  decrease  respective objective function,.
although isolating  vertices  moving one  .
vertices   middle   respective cluster  .
feasible  improve  objective function.
implementation  running times.  algorithms icc, mcl, gmc    implemented .
java . . using  graph library yfiles . gvm.
.also incorporating ml-mod   special case.  implemented  . using version . .   boost graph.
library .  compiled  gcc .  optimization level .  focus   evaluation    quality.
  resulting clusterings,   running times. however,  get  rough impression   latter, clustering cond-mat-.   . ghz amd opteron processor takes  . hours  icc, . hour  . minutes  mcl, . minutes  gmc  .  . seconds  gvm, depending   parameter setting.
  prototype implementation . including .
improvements proposed  .  , clustering .
much smaller celegans metabolic takes  . minutes.
. conclusion.
 work   experimental evaluation  algorithms.
 density-constrained clustering .dcc. .
first evaluated two greedy heuristics, vertex moving .
cluster merging,      algorithms   literature. vertex moving proved reliably superior  cluster merging ,  many cases,.
beats  results   reference algorithms.  results also show   well-known modularity-based algorithm implicitly addresses dcc quite well, revealing.
similarities  cut-based intercluster sparsity measures  modularity.   second part,  addressed.
 question whether different combinations  intracluster density  intercluster sparsity measures .
suitable  guide algorithms  recovering planted partitions  random graphs.  results suggest  minimizing  average intercluster expansion  density .
 clusters overestimates  number  clusters  .
expected clustering  coarse,   maximum intercluster measures lead  unbalanced clusters  .
expected clustering  fine   constraint   intracluster density   force  clustering  .
balanced. additionally,    seen   known.
resolution limit  modularity   circumvented .
 coarseness   clustering  controlled   additional constraint   intracluster density   clustering.
</doc>
<doc title='014.txt'>
distributed evolutionary graph partitioning.
peter sanders. christian schulz.
abstract.
 present  novel distributed evolutionary algorithm,.
kaffpae,  solve  graph partitioning problem, .
makes use  kaffpa .karlsruhe fast flow partitioner.
 use   multilevel graph partitioner kaffpa provides new effective crossover  mutation operators. .
combining    scalable communication protocol .
obtain  system   able  improve  best known partitioning results  many inputs    short amount .
time.  example,  walshaw. well known benchmark tables   able  improve  recompute .  entries .
 tables  ., .  . imbalance.
. introduction.
problems  graph partitioning arise  various areas .
computer science, engineering,  related fields. .
example  high performance computing ., community detection  social networks .  route planning .  particular  graph partitioning problem.
  valuable  parallel computing.   area,.
graph partitioning  mostly used  partition  underlying graph model  computation  communication.
roughly speaking, vertices   graph represent computation units  edges denote communication. .
graph needs   partitioned     .
edges   blocks .pieces.  particular,  .
want  use  processors  want  partition  graph.
  blocks   equal size.
  paper  focus   version   problem.
 constrains  maximum block size  . . times.
 average block size  tries  minimize  total cut.
size, .,  number  edges  run  blocks.
  well known   problem  np-complete .
     approximation algorithm  .
constant ratio factor  general graphs . therefore.
mostly heuristic algorithms  used  practice.
 successful heuristic  partitioning large graphs.
  multilevel graph partitioning .mgp. approach depicted  figure .   graph  recursively contracted  achieve smaller graphs   reflect.
  basic structure   input graph.  .karlsruhe institute  technology, institute  theoretical informatics, algorithmics . email. sanders.kit.edu, christian.schulz.kit.edu.
plying  initial partitioning algorithm   smallest.
graph,  contraction  undone ,   level, .
local refinement method  used  improve  partitioning induced   coarser level.
 main focus   paper   technique  integrates  evolutionary search algorithm   multilevel graph partitioner kaffpa   scalable parallelization.  present novel mutation  combine.
operators   contrast  previous methods .
use  graph partitioner ., .   need random.
perturbations  edge weights.  show  section .
  usage  edge weight perturbations decreases.
 overall quality   underlying graph partitioner.
 new combine operators enable   combine individuals  different kinds .see section .   details.
due   parallelization  system  able  compute.
partitions   quality comparable  better .
previous entries  walshaw. well known partitioning.
benchmark within   minutes  graphs  moderate size. previous methods  soper  . . required.
runtimes    one week  graphs   size. .
therefore believe   contrast  previous methods,.
 method   valuable   area  high performance computing.
input .
graph.
. .
initial.
.
ntraction phase.
.
fin.
.
.
 .
.
.
local improvement.
uncontract.
partitioning.
contract.
match.
output.
partition.
figure . multilevel graph partitioning.
 paper  organized  follows.  begin  section .
 introducing basic concepts.  shortly presenting.
related work  section .,  give  brief outline .
 techniques used   multilevel graph partitioner.
kaffpa .  section . since  use    base case.
partitioner.  continue describing  main evolutionary components  section .   parallelization .
section .  summary  extensive experiments done .
tune  algorithm  evaluate  performance  pre. copyright . siam.
unauthorized reproduction   article  prohibited.
sented  section .   implemented  techniques   graph partitioner kaffpae .karlsruhe.
fast flow partitioner evolutionary.   written .
. experiments reported  section . indicate .
kaffpae  able  compute partitions   high.
quality  scales well  large networks  machines.
. preliminaries.
. basic concepts. consider  undirected graph.
 . .,, , .  edge weights . .  . ., node.
weights  .  . .,  . . .,   . . .
extend   .  sets, ., . . .
.
. . . .
. .
.
. . . . . . ., . . . denotes  neighbors  .   looking  blocks.
 nodes .,. . . ,  partition  , ., . . . . . .
 .    .  . .   . .  balancing constraint demands  . . . . . .
lmax . . . . . . maxv. .   parameter .  last term   equation arises   node  atomic  therefore  deviation.
  heaviest node    allowed.  objective   minimize  total cut.
.
. .eij. .
eij . ., . .  .  . ,  . .  clustering .
also  partition   nodes, however   usually .
given  advance   balance constraint  removed.
 vertex  .     neighbor  .  ,  . ,.
  boundary vertex.  abstract view   partitioned graph    called quotient graph,  vertices represent blocks  edges  induced  connectivity  blocks. given two clusterings .  .
 overlay clustering   clustering   block.
corresponds   connected component   graph.
 . .,.     union   cut edges.
 .  ., .  edges  run  blocks .
either .  .  default,  initial inputs will .
unit edge  node weights. however, even  will.
 translated  weighted problems   course .
 algorithm.
 matching  .    set  edges  .
 share  common nodes, .,  graph .,.
 maximum degree one. contracting  edge ., .
means  replace  nodes      new node .
connected   former neighbors    .  set.
. . . . .   weight   node   level.
  number  nodes   representing   original graph.  replacing edges   form .,.,., .
 generate two parallel edges .,.,  insert .
single edge  .,. . .,., . uncontracting  edge  undos  contraction.  order .
avoid tedious notation,  will denote  current state .
 graph     .contraction unless .
explicitly want  refer  different states   graph.
 multilevel approach  graph partitioning consists.
 three main phases.   contraction .coarsening.
phase,  iteratively identify matchings  .  .
contract  edges   . contraction  quickly.
reduce  size   input   computed level.
 reflect  global structure   input network.
contraction  stopped   graph  small enough.
  directly partitioned using  expensive .
algorithm.   refinement . uncoarsening. phase,.
 matchings  iteratively uncontracted.  uncontracting  matching,  refinement algorithm moves.
nodes  blocks  order  improve  cut size.
 balance.
local search algorithms find good solutions  .
 short amount  time  often get stuck  local optima.  contrast  local search algorithms, genetic.evolutionary algorithms  good  searching .
problem space globally. however, genetic algorithms.
lack  ability  fine tuning  solution,   local.
search algorithms  help  improve  performance.
  genetic algorithm.  combination   evolutionary algorithm   local search algorithm  called.
hybrid  memetic evolutionary algorithm .
. related work.
    huge amount  research  graph.
partitioning    refer  reader  ., .
  material  multilevel graph partitioning .
 .   material  genetic approaches .
graph partitioning.  general purpose methods .
 able  obtain good partitions  large real world.
graphs  based   multilevel principle outlined .
section . well known software packages based  .
approach include, jostle ., metis .,  scotch.
. kaffpa .   mgp algorithm using local.
improvement algorithms   based  flows .
 localized  searches.  obtained  best results.
 many graphs  . since  use    base case.
partitioner   described   detail  section .
kaspar .   graph partitioner based   central.
idea  .contract   single edge  two.
levels. kappa .   .classical. matching based mgp.
algorithm designed  scalable parallel execution.
soper  . . provided  first algorithm.
 combined  evolutionary search algorithm .
 multilevel graph partitioner.  crossover .
mutation operators   used  compute edge.
biases,  yield hints   underlying multilevel.
graph partitioner. benlic  . . provided  multilevel.
memetic algorithm  balanced graph partitioning.
 approach  able  compute many entries .
walshaw. benchmark archive .   case . . .
probe .   meta-heuristic    viewed .
 genetic algorithm without selection.  outperforms.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 metaheuristics,    restricted   case.
 . .  . . .
 recently  algorithm called punch . .
 introduced.  approach   based  .
multilevel principle. however,  creates  coarse version   graph based   notion  natural cuts.
natural cuts  relatively sparse cuts close  denser.
areas.   discovered  finding minimum cuts.
 carefully chosen regions   graph.  introduced  evolutionary algorithm   similar .
soper  . ., . using  combine operator .
computes edge biases yielding hints   underlying.
graph partitioner. experiments indicate   algorithm computes  good partitions  road networks.
 instances without  natural structure   road.
networks, natural cuts    helpful.
. karlsruhe fast flow partitioner.
 now provide  brief overview   techniques.
used  kaffpa   used   base case graph partitioner later. kaffpa .   classical matching based.
multilevel graph partitioner. recall   multilevel.
graph partitioner basically  three phases. coarsening, initial partitioning  uncoarsening.
kaffpa makes contraction  systematic  separating two issues.  rating function indicates .
much sense  makes  contract  edge based  local information.  matching algorithm tries  maximize  sum   ratings   contracted edges.
looking   global structure   graph. .
 rating function allows  flexible characterization .
  .good. contracted graph ,  simple, standard definition   matching problem allows  reuse.
previously developed algorithms  weighted matching. matchings  contracted   graph  .small.
enough.  .   observed   rating function expansion., . . .,. works best among.
 edge rating functions,    rating function.
 also used  kaffpa.
kaffpa employs  global path algorithm .gpa.
  matching algorithm.   proposed  .
  synthesis   greedy algorithm   path.
growing algorithm .  algorithm achieves  halfapproximation   worst case,  empirically, gpa.
gives considerably better results  sorted heavy.
edge matching  greedy .  details see .
gpa scans  edges  order  decreasing weight.
 rather  immediately building  matching, .
first constructs  collection  paths  even cycles.
afterwards, optimal solutions  computed   .
 paths  cycles using dynamic programming.
 contraction  stopped   number .
remaining nodes   max ., . .
graph   small enough   partitioned  .
initial partitioning algorithm. kaffpa employs scotch.
  initial partitioner since  empirically performs.
better  metis.
recall   refinement phase iteratively uncontracts  matchings contracted   contraction.
phase.   matching  uncontracted, local search.
based refinement algorithms move nodes  block.
boundaries  order  reduce  cut  maintaining  balancing constraint. local improvement algorithms  usually variants   fm-algorithm .
 algorithm  organized  rounds.   round,.
 priority queue   used   initialized  .
vertices   incident    one block, .
 random order.  priority  based   gain.
. . maxp  .   .   decrease  edge.
cut  moving   block  . ties  broken randomly      one block  yields .
maximum gain  moving   . local search .
repeatedly looks   highest gain node .  node.
 moved    within  round.   node .
moved  unmoved neighbors become eligible, . .
unmoved neighbors  inserted   priority queue.
  stopping criterion  reached  movements .
 best found cut  occurred within  balance.
constraint  undone.  process  repeated several.
times   improvement  found.
  uncoarsening phase kaffpa additionally uses  advanced refinement algorithms. .
first method  based  max-flow min-cut computations  pairs  blocks, .,  method  improve.
 given bipartition. roughly speaking,  improvement method  applied   pairs  blocks .
share  non-empty boundary.  algorithm basically.
constructs  flow problem  growing  area around.
 given boundary vertices   pair  blocks .
  min cut   area yields  feasible bipartition   original graph within  balance constraint.
 yields  locally improved k-partition   graph.
 second method  improving  given partition .
called multi-try . roughly speaking,  k-way local.
search initialized   single boundary node  repeatedly started. previous methods  initialized  .
boundary nodes.
kaffpa extended  concept  iterated multilevel.
algorithms   introduced  .  main.
idea   iterate  coarsening  uncoarsening phase.
  graph  partitioned, edges   .
two blocks   contracted.  f-cycle works .
follows.   level  perform   two recursive.
calls using different random seeds  contraction.
 local search.  second recursive call  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
made  second time   algorithm reaches .
particular level.  soon   graph  partitioned,.
edges    blocks   contracted. .
ensures nondecreasing quality   partition since.
 refinement algorithms guarantee  worsening .
break ties randomly. figure . illustrates  f-cycle.
  called global search strategies   effective.
 plain restarts   algorithm . extending .
idea will yield  new combine  mutation operators.
described  section .
.
ncoarseningco.
.
.
.
.
graph  partitioned.
graph partitioned.
figure . schematic view   f-cycle.
. evolutionary components.
 general idea behind evolutionary algorithms . .
 use mechanisms   highly inspired  biological evolution   selection, mutation, recombination.
 survival   fittest.   starts   population  individuals .  case partitions   graph.
 evolves  population  different populations.
 several rounds.   round,   uses  selection rule based   fitness   individuals . .
case  edge cut.   population  select good individuals  combine   obtain improved offspring.
. note    use  cut   fitness function.
since  partitioner almost always generates partitions.
  within  given balance constraint, . .
  need  use  penalty function  something similar  ensure   final partitions generated  .
algorithm  feasible.   offspring  generated.
 eviction rule  used  select  member   population  replace    new offspring.  general.
one   take   consideration,  fitness  .
individual   distance  individuals  .
population .  algorithm generates  one offspring per generation.   evolutionary algorithm.
 called steady-state .  typical structure   evolutionary algorithm  depicted  algorithm .
  evolutionary algorithm    major importance  keep  diversity   population high .,.
.  individuals   become  similar,  order  avoid  premature convergence   algorithm.
  words,  avoid getting stuck  local optima .
procedure  needed  randomly perturbs  individuals.  classical evolutionary algorithms,   done.
using  mutation operator.   also important  .
operators  introduce unexplored search space  .
population.   new kind  crossover  mutation operators, introduced  section .,  introduce.
 elaborate diversification strategies  allow .
 search  search space  effectively.
interestingly, inayoshi  . . noticed  good.
local solutions   graph partitioning problem tend.
  close  one another. boese  . . showed.
  quality   local optima overall decreases .
 distance   global optimum increases. .
will see   following   combine operators.
 exchange good parts  solutions quite effectively.
especially     small distance.
algorithm . steadystateea.
create initial population .
 stopping criterion  fulfilled.
select parents ., .  .
combine .  .  create offspring .
mutate offspring .
evict individual  population using .
return  fittest individual  occurred.
. combine operators.  now describe  general combine operator framework.   followed .
three instantiations   framework.  contrast .
previous methods  use  multilevel framework .
combine operators   need perturbations  edge.
weights since  integrate  operators   partitioner    use    complete black box.
furthermore    combine operators assure.
  offspring   partition quality  least .
good   best   parents. roughly speaking,.
 combine operator framework combines  individual.partition  .  . , .,   .   fulfill  balance constraint.   clustering  .  . , .,  . . note.
  clustering   necessarily   fulfill .
balance constraint  .   necessarily given  advance.  instantiations   framework use  different kind  clustering  partition.  partition .
 clustering   used  input   multi-level.
graph partitioner kaffpa   following sense.  .
  set  edges   cut edges, . edges  run.
 two blocks,  either   .  edges   .
blocked   coarsening phase, .   .
contracted   coarsening phase.   words.
 edges   eligible   matching algorithm.
. copyright . siam.
unauthorized reproduction   article  prohibited.
match.
contract.
figure .   top  graph   two partitions,.
 dark   light line,  shown. cut edges .
 eligible   matching algorithm. contraction .
done   matchable edge  left.  best  .
two given partitions  used  initial partition.
used   coarsening phase  therefore  .
part   matching computed.  illustration  .
  found  figure .
 stopping criterion   multi-level partitioner.
 modified    stops   contractable edge.
 left. note   coarsest graph  now exactly .
   quotient graph .   overlay clustering.
      .see figure . hence vertices  .
coarsest graph correspond   connected components.
  . .,.   weight   edges .
vertices corresponds   sum   edge weights.
running   connected components  .
 soon   coarsening phase  stopped, .
apply  partition    coarsest graph  use.
  initial partitioning.   possible since  .
 contract  cut edge  . note  due  .
specialized coarsening phase   specialized initial.
partitioning  obtain  high quality initial solution.
   coarse graph   usually  discovered.
 conventional partitioning algorithms. since .
refinement algorithms guarantee  worsening  .
input partition  use random tie breaking  .
assure nondecreasing partition quality. note  .
refinement algorithms  effectively exchange good.
parts   solution   coarse levels  moving .
  vertices. figure . gives  example.
also note   combine operator   extended    multi-point combine operator, . .
operator  use  instead  two parents. however,.
  course   algorithm  sequence  two.
point combine steps  executed  somehow .emulates.  multi-point combine step. therefore,  restrict.
   case  . .   offspring  generated    decide  solution   evicted.
  current population.  evict  solution .
  similar   offspring among  individuals.
  population    cut worse  equal .
 offspring .  difference  two individuals .
defined   size   symmetric difference .
 sets  cut edges.  ensures  diversity .
 population  hence makes  evolutionary algorithm  effective.
. classical combine using tournament selection.  instantiation   combine framework.
corresponds   classical evolutionary combine operator .  means  takes two individuals ., . .
 population  performs  combine step described.
.   case  corresponds   partition   smaller cut   corresponds   partition.
  larger cut. random tie breaking  used .
 parents    cut.  selection process.
 based   tournament selection rule ., . .
  fittest   two random individuals ., . .
 population.    done  select . note.
  contrast  previous methods  generated offspring will   cut smaller  equal   cut .
. due   fact   multi-level algorithms .
randomized,  combine operation performed twice using.
  parents  yield different offspring.
. cross combine . transduction.   instantiation   combine framework .,  clustering  corresponds   partition  .  instead.
 choosing  individual   population  create  new individual   following way.  choose.
. uniformly  random  ., .  . uniformly.
 random  ., .   use kaffpa  create  .-partition   fulfilling  balance constraint.
max . . . . . .  general larger imbalances reduce  cut   partition   yields.
good clusterings   crossover.   best  .
knowledge     genetic algorithm  performs combine operations combining individuals .
different search spaces.
. natural cuts. delling  . . introduced.
 notion  natural cuts   preprocessing technique.
  partitioning  road networks.  preprocessing technique  able  find relatively sparse cuts close.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
.
.
.
figure .  graph   two bipartitions.  dotted.
  dashed line .top. curved lines represent  large.
cut.  four vertices correspond   coarsest graph.
  multilevel procedure. local search algorithms.
 effectively exchange .  .  obtain  better.
partition depicted   bottom .dashed line.
 denser areas.  use  computation  natural cuts.
 provide another combine operator, . combining .
k-partition   clustering generated   computation  natural cuts.  closely follow  description.
 computation  natural cuts works  rounds. .
round picks  center vertex   grows  breadth-first.
search .bfs. tree.  bfs  stopped  soon  .
weight   tree, .  sum   vertex weights.
  tree, reaches . ,   parameters .   .
 set   neighbors     .  called  ring.
.
figure .   top  see  computation  .
natural cut.  bfs tree  starts    grown.
 gray area   core.  dashed line   natural.
cut.    minimum cut   contracted.
versions   core   ring .shown   solid.
line.   computation several natural cuts .
detected   input graph .bottom.
 .  core     union   vertices added .
   size reached .   . .  another.
parameter.
 core   temporarily contracted   single.
vertex    ring   single vertex   compute.
 minimum s-t-cut   using  given.
edge weights  capacities.  assure  every vertex.
eventually belongs   least one core,  therefore.
 inside  least one cut,  vertices   picked.
uniformly  random among  vertices   .
yet  part   core   round.  process .
stopped      vertices left.
  original work .  connected component.
  graph  . .,.,     union .
 edges cut   process ,  contracted  .
single vertex. since    use natural cuts  .
preprocessing technique   place  . contract.
 components. instead  build  clustering   .
   connected component     block.
 technique yields  third instantiation .
 combine framework .   divided  two.
stages, .  clustering used   combine step .
dependent   stage   currently .  .
stages  partition  used   combine step .
selected   population using tournament selection.   first stage  choose  uniformly .
random  ., ., . uniformly  random  ., .
  set  . . . using  parameters .
obtain  clustering    graph    used.
  combine framework described .  kind.
 clustering  used   reach  upper bound .
ten calls   combine step.   upper bound.
 reached  switch   second stage.   stage.
 use  clusterings computed   first stage,.
.  extract elementary natural cuts  use .
 quickly compute new clusterings.  elementary.
natural cut .enc. consists   set  cut edges .
 set  nodes   core. moreover,   node .
  graph,  store  set   encs . .
contain    core.   data structures .
easy  pick  new clustering  .see algorithm .
   used   combine framework described.
.
algorithm . computenaturalcutclustering.
unmarked  nodes  .
   .   random order .
    marked .
pick  random enc   .
output .
mark  nodes  . core.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. mutation operators.  define two mutation.
operators,  ordinary   modified f-cycle. .
mutation operators use  random individual  .
current population.  main idea   iterate coarsening  refinement several times using different seeds.
 random tie breaking.  first mutation operator.
.  assure   quality   input partition.
  decrease.   basically  ordinary f-cycle.
   algorithm used  kaffpa. edges .
blocks   contracted.  given partition  .
used  initial partition   coarsest graph.  contrast  kaffpa,  now  use  partition  input.
  partition    beginning.  ensures.
nondecreasing quality since  refinement algorithms.
guarantee  worsening.  second mutation operator.
. works quite similar   small difference .
 input partition   used  initial partition  .
coarsest graph.  means  obtain  good coarse.
graphs     assure   final individual.
  higher quality   input individual.  .
cases  resulting offspring  inserted   population using  eviction strategy described  section .
. putting things together  parallelization.
 now explain  parallelization  describe .
everything  put together.  processing element.
. basically performs   operations using.
different random seeds .see algorithm . first .
estimate  population size .   performs.
 partitioning step  measures  time  spend.
 partitioning.   choose    .
time  creating  partitions  approximately ttotal.
  fraction    tuning parameter  ttotal.
  total running time   algorithm  given.
 produce  partition   graph.   .
builds   population, . kaffpa  called several.
times  create  individuals.partitions. afterwards.
 algorithm proceeds  rounds  long  time .
left.  corresponding probabilities, mutation .
combine operations  performed   new offspring.
 inserted   population.
 choose  parallelization.communication protocol   quite similar  randomized rumor spreading.
.   denote  number  pes used.  communication step  organized  rounds.   round,  .
chooses  communication partner  sends   currently best partition    local population.  selection   communication partner  done uniformly.
 random among  pes     already .
 send . afterwards,   checks    incoming individuals    inserts    local.
population using  eviction strategy described .
   improved,  pes   eligible.  .
repeated log  times. note   algorithm  implemented completely asynchronously, .    need.
  global synchronisation.  process  creating.
individuals  parallelized  follows.   makes.
. . . calls  kaffpa using different seeds  create . individuals. afterwards    following .
times.  root  computes  random cyclic permutation   pes  broadcasts    pes. .
  sends  random individual   successor .
 cyclic permutation  receives  individual .
 predecessor   cyclic permutation.  call .
particular part   algorithm quick start.
 ratio . .
.
.  mutation  crossover.
operations yields  tuning parameter .   will see.
 section .  ratio . . .   good choice.  .
experiments  fixed  ratio   mutation operators.
. . .  . . .   ratio   combine operators.
. . . . .  . . . . .
note   communication step   last line.
  algorithm  also  performed  every.
x-iterations .    tuning parameter.  save.
communication time. since  communication network.
  test system   fast .see section .,  perform.
 communication step   iteration.
algorithm . locallyevolve.
estimate population size .
 time left.
 elapsed time . ttotal. .
create individual.
insert  local population.
else.
flip coin   corresponding probabilities.
  shows head .
perform  mutation operation.
else.
perform  combine operation.
insert offspring  population  possible.
communicate according  comm. protocol.
. experiments.
implementation.   implemented  algorithm described  using . overall,  program .including kaffpa. consists   . . lines.
 code.  use two base case partitioners, kaffpastrong  kaffpaeco. kaffpaeco   good tradeoff.
 quality  speed,  kaffpastrong  focused  quality.   following comparisons  used.
scotch .,  kmetis . .pre.
system. experiments   done  two machines. machine    cluster  . nodes .
 node  equipped  two quad-core intel xeon.
. copyright . siam.
unauthorized reproduction   article  prohibited.
processors .  run   clock speed  .
ghz.  node  .   level . cache  .
run suse linux enterprise .  .  nodes  attached   infiniband . ddr interconnect .
 characterized    low latency   . microseconds   point  point bandwidth  two.
nodes    . . machine   two intel xeon ., . ram, running ubuntu .
 cpu  . cores . cores  hyperthreading .
active. running  . ghz. experiments  sections.
., ., .  .   conducted  machine.
,  experiments  sections .  .  .
conducted  machine .  programs  compiled.
using gcc version .  optimization level . using.
openmpi . henceforth,    one core.
instances.  report experiments  three suites.
 instances .small, medium sized  road networks.
summarized  appendix . rggx   random geometric graph  . nodes  nodes represent.
random points   unit square  edges connect.
nodes whose euclidean distance   .
.
lnn.
 threshold  chosen  order  ensure  .
graph  almost connected. delaunayx   delaunay.
triangulation  . random points   unit square.
graphs  ,.elt . body  . .memplus come .
walshaw. benchmark archive . graphs deu .
eur , bel  nld  undirected versions   road networks, used  . luxemburg   road network taken.
 .  default number  partitions   ., .,.
., ., ., . since    default values  .
   cases  additionally use .  . .
default value   allowed imbalance  . since .
 one   values used  .   default value .
metis.  default number  pes  .
methodology.  mostly present two kinds .
data. average values  plots  show  evolution.
 solution quality .convergence plots.   cases .
perform multiple repetitions.  number  repetitions.
 dependent   test   perform. average.
values  multiple instances  obtained  follows.
  instance .graph, .,  compute  geometric.
mean   average edge cut values   instance.
 now explain   compute  convergence plots.
 start explaining   compute    single.
instance . whenever   creates  partition  reports.
 pair ., cut.,   timestamp    currently.
elapsed time   particular   cut refers .
 cut   partition    created. .
performing multiple repetitions  report average values.
., avgcut. instead.   completion  kaffpae.
  left   sequences  pairs ., cut.  .
now merge  one sequence.  merged sequence.
 sorted   timestamp .  resulting sequence.
 called   . since   interested   evolution .
 solution quality,  compute another sequence  imin.
  entry . sorted order.     insert  entry.
.,mint. cut.   imin.  mint. cut.
.  .
minimum cut  occurred  time .  imin refers.
  normalized sequence, .  entry ., cut. .
 imin  replaced  ., cut.   . .  .
  average time  kaffpa needs  compute .
partition   instance .  obtain average values.
 multiple instances    following.  .
instance  label  entries   imin, . ., cut. .
replaced  ., cut, .   merge  sequences.
 imin  sort  .  resulting sequence  called.
.  final sequence  presents event based geometric.
averages values.  start  computing  geometric.
mean cut value  using  first value    imin .
.  obtain   basically sweep  .  .
entry . sorted order. ., , .    update , .
 cut value    took part   computation .
  replaced   new value ,  insert .,. .
. note      smaller  equal   old.
cut value  .
. parameter tuning.  now tune  fraction parameter    ratio  mutation .
crossover operations.   parameter tuning .
choose  small testset  runtimes   single.
graph partitioner call    large.  save runtime  focus   . .  tuning  parameters. .
 instance  gave kaffpae ten minutes time .
. pes  compute  partition.   test .
quick start option  disabled.
. . . .
.
.
.
.
.
.
.
.
.
.
.
.
normalized time  .
.
.
.
.
 .
.
 .
.
.
 . .
 . .
 . .
 . .
 . .
 . .
 . .
 . .
figure . convergence plot  tuning  fraction.
parameter  using  . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
. . . . . .
.
.
.
.
.
.
.
.
.
.
.
.
normalized time  .
.
.
.
.
 .
.
 .
.
.
 . .
 . .
 . .
 . .
 . .
 . .
 . .
figure . convergence plot  tuning  flip coin.
parameter  using  . .
 start tuning  fraction parameter  .  .
test  flip coin parameter   set  one.  figure . .
 see   algorithm    sensitive  .
exact choice   parameter. however, larger values.
  speed   convergence rate  improve .
result achieved   end. since  . .   . .
  best parameter   end,  choose  . .
  default value.  tuning  ratio . .
.
. .
mutation  crossover operations,  set   ten. .
 see   smaller values    algorithm  .
 sensitive   exact choice   parameter.
however,    exceeds .  convergence speed slows.
  yields worse average results   end. .
choose  . .     slight advantage  .
end.  parameter tuning uses kaffpastrong  .
partitioner.  also performed  parameter tuning.
using kaffpaeco   partitioner .see  .
. scalability.   section  study  scalability   algorithm.    following  obtain.
 fair comparison. basically  configuration  .
 amount  time, .  doubling  number.
 pes used,  divide  time  kaffpae  .
compute  partition per instance  two.   .
precise,   use one  kaffpae  . . .
 compute  partition   instance.  kaffpae.
uses  pes,   gets time  . .  compute .
partition   instance.    following tests .
quick start option  enabled.  save runtime  use.
 small sized testset  fix   .   perform.
five repetitions per instance.   see  figure .
 using  processors speeds   convergence.
speed     . . also improves  quality  .
end .  cases  speedups  optimal   end.
 might  due  island effects .   . . results  worse compared   . .    .
algorithm  barely able  perform combine  mutation steps, due    small amount  time given.
 kaffpae . seconds.   largest graph  .
testset .delaunay.  need  . seconds  create.
 partition   . . blocks.
 now define pseudo speedup .   .
measure  speedup   particular normalized time.
   configuration using one .  . .
 mean minimum cut  kaffpae  computed.
using  pes  normalized time .  pseudo.
speedup   defined  . . .
.
.
.
. .
. . minci. .
.  . . .
.
.    .
set . . . .  case  parallel algorithm  .
able  compute  result computed   sequential.
algorithm  normalized time .     case.
  . .   see  figure .    short.
amount  time  reach super linear pseudo speedups.
  cases.
. . . . .
.
.
.
.
.
.
.
.
normalized time  .
.
.
.
 .
.
 .
.
 .
.
.
.
 . .
 . .
 . .
 . .
 . .
 . .
 . .
 . .
 . .
. . . . .
normalized time  .
.
.
.
.
.
 .
.
.
.
.
.
.
.
.
.
.
.
.
 . .
 . .
 . .
 . .
 . .
 . .
 . .
 . .
figure . scalability   algorithm. convergence plot.
.top., pseudo speedup .bottom.  plots  .
found  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
. comparison  kaffpa   systems.   section  compare   repeated executions  kaffpa   systems. .
switch   middle sized testset  avoid  effect  overtuning  algorithm parameters   instances used  calibration.  use . pes  two.
hours  time per instance   use kaffpae.
 parallelized repeated executions  kaffpa .embarrassingly parallel, different seeds.  also gave .
pes  two hours  kaffpa.  look   .
., ., ., ., ., ., ., .  performed three repetitions per instance. figure . show convergence plots.
  . ., ., ., .  convergence plots  .
found  .  expected  improvements  kaffpae relative  repeated executions  kaffpa increase.
 increasing .  largest improvement  obtained.
  . .  kaffpae produces partitions .
  . smaller cut value  plain restarts  .
algorithm. note  using  weaker base case partitioner, . kaffpaeco, increases  value.  .
small sized testset  obtained  improvement  .
  . . compared  plain restarts  kaffpaeco.
tables comparing kaffpae   best results .
 ten repetitions  scotch  metis   found .
appendix table . overall, scotch  metis produce.
.  . larger .best. cuts  kaffpae respectively. however,  methods  much faster .
 .appendix table .
.algo. reps. kaffpae.
avg. impr. .
. . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
overall . . .
table . different algorithms  two hours  time .
. pes.
. . . .
.
.
.
.
.
.
.
normalized time  .
.
.
.
 .
.
 .
.
 repetitions.
kaffpae.
. . . . .
.
.
.
.
.
.
.
normalized time  .
.
.
.
 .
.
 .
.
 repetitions.
kaffpae.
. . . . .
.
.
.
.
.
.
.
.
.
.
normalized time  .
.
.
.
 .
.
 .
.
 repetitions.
kaffpae.
. . . .
.
.
.
.
.
.
.
normalized time  .
.
.
.
 .
.
 .
.
 repetitions.
kaffpae.
figure . convergence plots   comparison .
kaffpae  repeated executions  kaffpa.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. combine operator experiments.  now.
look   effectiveness   combine operator .
 conduct  following experiment.  compare .
best result  three repeated executions  kaffpa.
.   combine step . ., .  creating.
two partitions  report  result   combine step.
. combining  individuals.    done using.
 combine operator  soper . . . . ., . .
create two individuals using perturbed edge weights .
 .  report  cut produced   combine step.
proposed  . best    three individuals.
 also present best results   three repetitions.
 using perturbed edge weights   soper . .
. since  partitioner   support double.
type edge weights,  computed  perturbations .
scaled    factor  . . . .  . .
performed ten repetitions   middle sized testset.
results  reported  table .  table presenting.
absolute average values  comparing  runtime .
 algorithms   found  appendix table .
  see   large   new combine operator.
yields improved partition quality  compareable  less.
time . . .  importantly,   see .
edge biases decrease  solution quality . . .
  due   fact  edge biases make edge cuts.
optimial    close  optimial   unbiased.
problem.  example  . grid graphs,  .
straight edge cuts   optimal. random edge biases.
make bended edge cuts optimal. however,  cuts.
   close  optimal cuts   original graph.
partitioning problem. moreover, local search algorithms.
.flow-based, fm-based. work better     lot.
 equally sized cuts.
algo. . .  .
 avg. improvement .
. . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
table . comparison  quality  different algorithms.
relative  .
. walshaw benchmark.  now apply kaffpae  walshaw. benchmark archive . using .
rules used , ., running time    issue   want  achieve minimal cut values .
 . ., ., ., ., ., .  balance parameters . .
., ., ., .  focus  . . ., ., . since.
kaffpae . precisely kaffpa.   made  .
case . . .  run kaffpae   time limit .
two hours using . pes .two nodes   cluster. per.
graph,   .  report  complete list  results.
obtained    .   eight largest graphs .
 archive  gave kaffpae eight hours per graph,.
  . kaffpae computed . partitions  .
better  previous best partitions reported . .
 ., .  .  .  . moreover,  reproduced equally sized cuts  .   . remaining.
cases.   considering  . largest graphs .
. . ., .   able  reproduce  improve .
current result  .   . cases. overall  systems .including kappa, kaspar, kaffpa, kaffpae.
now improved  reproduced  entrys  .  .
. cases . . . ., ., .
. comparison  punch.   section.
 focus  finding partitions  road networks. .
implemented  specialized algorithm, buffoon,  .
similar  punch .   sense   also uses.
natural cuts   preprocessing technique  obtain .
coarser graph    graph partitioning problem.
 solved.   information  natural cuts, .
refer  reader  . using  .shared memory.
parallelized version  natural cut preprocessing .
obtain  coarse version   graph. note  .
preprocessing uses slightly different parameters .
punch .using  notation  .,  use  . .,  .
. . . . ,  . ., . . . since partitions   coarse.
graph correspond  partitions   original graph,.
 use kaffpae  partition  coarse version  .
graph.
 preprocessing,  gave kaffpae teur, .
 . . min  europe  tger, .  . . min.
 germany,  compute  partition.   cases .
used  . cores .hyperthreading active.  machine .
 preprocessing   kaffpae.  experiments.
 repeated ten times.  summary   results .
shown  table . interestingly,  germany already .
average values  smaller  equal   best result.
  . repetitions obtained  punch. overall.
 .   . cases  compute  best cut  .
better  equal   best cut obtained  punch.
note   obtaining  best cut values  invest.
significantly  time  punch. however, .
machine    factor two faster . cores running.
 .ghz compared  . cores running  .ghz.
  algorithm   tuned  road networks. .
table comparing  results  road networks .
kaffpa, kaspar, scotch  metis   found .
. copyright . siam.
unauthorized reproduction   article  prohibited.
grp,  algorithm.runtime .
ger. pbest ttotal bavg tavg bbest.
. . . . . .
. . . . . .
. . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
eur. pbest ttotal bavg tavg bbest.
. . . . . .
. . . . . .
. . . . . .
. . . . . . . . .
. . . . . . . . .
. . . . . . . . .
table . results  road networks. best results .
punch .   . repetitions  total time .
needed  compute  results. average  best cut.
results  buffoon .  well  average runtime .
.including preprocessing.
appendix .  algorithms produce ., ., .
 . larger cuts  average respectively.
. conclusion  future work.
kaffpae   distributed evolutionary algorithm .
tackle  graph partitioning problem. due  new.
crossover  mutation operators  well   scalable.
parallelization   able  compute  best known.
partitions  many standard benchmark instances .
   minutes.  therefore believe  kaffpae.
 helpful   area  high performance computing.
regarding future work,  want  integrate .
partitioners   implement  possibility  block.
edges   coarsening phase  use  given.
partitioning  initial solution.    interesting.
 try  domain specific combine operators, .
 social networks    interesting  use .
modularity clusterer  compute  clustering  .
combine operation.
acknowlegdements.   like  thank sanaz.
mostaghim   helpful discussion  evolutionary.
algorithms.
</doc>
<doc title='015.txt'>
exact combinatorial branch-and-bound  graph bisection.
daniel delling. andrew . goldberg. ilya razenshteyn. renato . werneck.
abstract.
 present  novel exact algorithm   minimum.
graph bisection problem, whose goal   partition.
 graph  two equally-sized cells  minimizing.
 number  edges  .  algorithm.
 based   branch-and-bound framework , unlike  previous approaches,   fully combinatorial.
 present stronger lower bounds, improved branching.
rules,   new decomposition technique  contracts.
entire regions   graph without losing optimality.
guarantees.  practice,  algorithm works particularly well  instances  relatively small minimum.
bisections, solving large real-world graphs . tens .
thousands  millions  vertices.  optimality.
. introduction.
 consider  minimum graph bisection problem. .
input   undirected, unweighted graph  . .,.,.
  goal   partition   two sets    .
 ., . . . .   number  edges .
   . cut size.  minimized.  fundamental.
combinatorial optimization problem   special case .
graph partitioning,  asks  arbitrarily many cells.
  numerous applications, including image processing ., ., computer vision ., divide-and-conquer.
algorithms ., vlsi circuit layout ., distributed computing .,  route planning . unfortunately, .
bisection problem  np-hard .  general graphs,.
  best known approximation ratio  .log . .
  restricted graph classes,   grids without holes .  graphs  bounded treewidth .,.
 known polynomial-time solutions.
 practice,   numerous general-purpose.
heuristics  graph partitioning,   metis .,.
scotch ., ., jostle .,  kaffpae .
successful heuristics tailored  particular graph classes,.
  dibap . . meshes.  punch . .
road networks.,  also available.  algorithms.
.microsoft research silicon valley. dadellin.microsoft.com.
.microsoft research silicon valley. goldberg.microsoft.com.
.lomonosov moscow state university. ilyaraz.gmail.com.
 work  done   author   microsoft research.
silicon valley.
.microsoft research silicon valley. renatow.microsoft.com.
 quite fast .often running  near-linear time. .
 handle  large graphs,  tens  millions .
vertices.  , however, prove optimality .
provide approximation guarantees. moreover,  .
 algorithms  perform well   certain degree .
imbalance  allowed.
  also  vast literature  practical exact algorithms  graph bisection . partitioning., mostly.
using  branch-and-bound framework .  .
 algorithms use sophisticated machinery  obtain.
lower bounds,   multicommodity flows ., ., .
linear ., ., ., semidefinite ., ., .,  quadratic.
programming . computing  bounds  quite expensive, however,  terms  time  space.  .
result, even though  branch-and-bound trees  .
quite small   graph classes, published algorithms.
  solve instances  moderate size . hundreds.
   thousand vertices.  optimality, even  .
 hours  processing. .see armbruster .   survey. combinatorial algorithms .  offer  different.
tradeoff.  provide weaker lower bounds,  compute  much faster .often  sublinear time. .
works well  random graphs    . vertices,.
   scale  larger instances.
 paper introduces  new exact algorithm .
graph bisection.  use novel combinatorial lower.
bounds    computed  near-linear time .
figure . example   minimum bisection.
. copyright . siam.
unauthorized reproduction   article  prohibited.
practice. even ,  bounds  quite strong, .
  used  find optimum solutions  real-world.
graphs  remarkably many vertices .  .
million  road networks,  tens  thousands  vlsi.
 mesh instances. see figure .   example. .
 best   knowledge,  method   first .
find exact solutions  instances   scale.  fact,.
 turns    running time   algorithm.
depends    size   bisection   .
size   graph.
 paper  four main contributions. first, .
introduce . section . new  improved combinatorial lower bounds  significantly strengthen previous.
bounds. second,  propose . section . elaborate.
branching rules  help  exploit  full potential .
 bound. third, section . introduces  new decomposition technique  boosts performance substantially.
 finds  optimum solution   input  solving .
small number  .usually much easier. subproblems independently. finally,  present . section .  careful.
experimental analysis   techniques.
. preliminaries.
 use  . .,.  denote  input graph, .
 . . . vertices   . . edges.  vertex.
 .  may   associated integral weight, denoted.
 .,   edge  .    associated integral.
cost .   .
.
. .  partition   .
 partition   , .,  set  subsets    .
disjoint  whose union   .  say   .
subset   cell, whose weight  defined   sum .
 weights   vertices.  cost   partition  .
sum   costs   edges whose endpoints belong.
 different cells.  bisection   partition  two.
cells.  bisection  .-balanced   cell  weight.
  . . .  . . .,  say  partition.
 perfectly balanced . just balanced.  minimum.
graph bisection problem    finding  minimumcost balanced bisection.
 simplify exposition, unless otherwise noted .
consider  unweighted, balanced version   problem,  . . .    .  , . . .    . ,.
 . . .  must therefore partition   two cells,.
  weight   .,  minimizing .
number  edges  cells. .section . shows .
  handle less restrictive settings.
 standard technique  finding exact solutions.
 np-hard problems  branch-and-bound ., .
 performs  implicit enumeration  dividing .
original problem  two   slightly simpler.
subproblems, solving  recursively,  picking .
best solution found.  node   branch-andbound tree corresponds   distinct subproblem. .
 minimization context,  algorithm keeps  global.
upper bound    solution   original problem,.
   updated   algorithm finds improved.
solutions.  process  node   tree,  first.
compute  lower bound    solution  .
corresponding subproblem.   .  ,  prune .
node.   lead   better solution. otherwise,.
 branch, creating two   simpler subproblems.
  concrete case  graph bisection,  node.
  branch-and-bound tree corresponds   partial.
assignment .,.,  , .   . . . .
say  vertices      assigned,   others .
free . unassigned.  node implicitly represents .
valid bisections ., .   extensions  .,.,.
.,    . .   . .  particular, .
root node,  represents  valid bisections,  .
form .,. . ., . .note   root  fix .
arbitrary node   one cell  break symmetry.
 process  arbitrary node .,.,  must compute  lower bound .,.   value   extension ., .  .,.  fastest exact algorithms ., ., ., ., ., . usually apply mathematical.
programming techniques  find lower bounds.  .
paper,  use  combinatorial bounds.  particular,  basic algorithm uses  well-known ., . flow.
bound .  minimum . cut    .   .
valid lower bound   extension ., . must.
separate   .   minimum cut happens  .
balanced,   prune . update  ,  possible.
otherwise,  choose  free vertex   branch  ,.
generating subproblems . . ., .  ., . .
note   flow lower bound   work well.
     similar sizes. even   case,.
 corresponding minimum cuts  often far .
balanced,  one side containing many  vertices.
  .  makes  flow bound rather weak.
 .  overcome  issues,  introduce  new.
packing lower bound.
.  packing lower bound.
 .,.   partial assignment.  make  .
balanced bisection,  least . . . free vertices.
must  assigned  , obtaining  extended set .
. similar argument   made  . suppose ,.
  possible extension .  ,   compute.
 maximum flow .    . .
.   minimum  flow value .  possible.
. .  clearly  lower bound   value  .
bisection consistent  .,. finding . exactly.
seems expensive. instead,  propose  fast algorithm.
 compute  lower bound  .
 works  follows .see figure .  . . .
.   subgraph   induced   vertices  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure .  packing bound. filled circles  vertices  .  free neighbors .filled squares. form  set.
. left.  first partition  free vertices  connected cells,     one element  . middle.
given  extension . .hollow circles.,  number  nontrivial cells  touches .eight.   lower bound  .
minimum .,. cut. right.  extension .  hits  fewest cells .three.   lower bound   valid.
extension.
currently unassigned,      set  vertices .
.   least one neighbor   . .  partition.
 vertices  .  connected cells,  containing.
  one element  . .  partition  valid.
  shall see,  get better lower bounds   cells.
containing elements     large  possible .
 roughly   size.  say   cell  .
nontrivial   contains exactly one element  . .
call  element  root   cell  denote  .
. cells   element    trivial.
lemma .  .   valid extension  ,  .
.   number  nontrivial cells hit  . .
.   lower bound   maximum flow .,.
   .
proof.  claim   find . disjoint paths  .  ,    different nontrivial cell. take.
 nontrivial cell  containing  element   .   cell  connected,    path  within .
    root .  . belongs .
,    edge  .  original graph . .
.   vertex   .  concatenation   .
   path  .  . since  valid extension.
must contain  least one edge     .
disjoint paths,  lemma follows.
recall   need  lower bound   possible.
extension .  .  get one  finding  extension.
  lemma . gives  lowest possible bound.
.  fixed partition  connected cells.  .
build  extension   greedy packing algorithm.
first, pick  vertices  trivial cells.   .
associate  cells  paths,    increase .
lower bound.   point ,  must pick vertices.
 nontrivial cells. since  lower bound increases.
 one regardless   number  vertices picked  .
cell,  makes sense  pick entire cells   . one.
vertex  picked, others   cell  free.  .
increase  bound.  optimal strategy   pick.
cells  decreasing order  size, stopping   sum.
  sizes   picked cells .trivial  nontrivial. .
 least . .   thus shown  following.
theorem .  greedy packing algorithm finds .
lower bound   value   bisection consistent .
.,.
. computing packing lower bounds. note.
  packing lower bound  valid   partition,.
  quality depends strongly   one  pick.
  choose  partition  forces  worstcase extension .  hit  many nontrivial cells .
possible.  means minimizing  total size  .
trivial cells,  ensuring  nontrivial cells  .
 number  vertices.  problem  hard ., .,.
  propose two heuristics  work well  practice.
 first heuristic   constructive algorithm .
builds  reasonable initial partition  scratch. starting  . unit cells .  one element  ., .
 step  adds  vertex   cell whose current size .
minimum.  algorithm   implemented  linear.
time  keeping   cell   list .  potential expansion edges, ., edges ., .    . .
  . . vertices    reachable   .
assigned  trivial cells.   algorithm progresses,.
 cells will run   expansion edges,   neighboring vertices will already  taken.  may lead .
 unbalanced solutions.
 improve  partition,  use  second heuristic.  local search routine  makes neighboring cells.
 balanced  moving vertices  . .
  efficiently,  maintains  spanning tree  .
nontrivial cell , rooted  . initially,   .
tree built   constructive algorithm.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
.
figure . packing local search. left.  boundary.
edge ., . determines  path  cells .  .
.triangles  subtrees. right. splitting  path  .
different point leads    balanced partition.
 local search works  moving entire subtrees.
 neighboring cells.  processes one boundary.
edge   time. consider one  edge ., ., .
 . .   . . without loss  generality, assume.
cell .   vertices  .  improve .
solution,  attempt  move  entire subtree  .
 .  find  best subtree  switch  traversing.
 path .  spanning tree  .,  largest cell.
   . .see figure .  vertex   .
path  associated   possible move. removing .
subtree rooted    .  inserting   .
among ,  .   vertex corresponding  .
 balanced final state .   sizes  . .
.   closest.     balanced  .
current state,  switch.
 local search runs   local optimum, .
 improving switch exists.  implement  efficiently,.
 keep track  boundary edges  subtree sizes explicitly.  ensures  algorithm runs  polynomial.
. superlinear. worst-case time.  practice, however,.
 reach  local optimum    moves,  .
local search    fast   constructive algorithm. .note  theoretical improvements  .
possible using  dynamic-tree data structures ., .
 practice   quite costly  graphs  moderate.
diameter .,    case.
. combining packing  flows. although .
 two lower bounds, based  packing  flows, .
 simply add   obtain  unified lower bound,.
since  may interfere  one another.   easy .
see .  method finds .implicitly.  set  edgedisjoint paths    least one edge   .
path must    solution. .  flow bound, .
  paths   flow decomposition. simply adding.
 bounds  require  sets  paths found .
 algorithm   mutually disjoint,   usually.
  case.  combine  bounds properly,  must.
first compute  flow bound,   packing bound .
takes  flow  account.
 precisely,  first compute  flow bound  .
usual.   remove  flow edges  , obtaining.
 new graph  . finally,  compute  packing lower.
bound    . now  .    valid lower bound.
  cost   best bisection extending  current.
assignment .,., since    overlap  .
paths considered   method .flow  packing.
 algorithm provides valid lower bounds regardless   flow decomposition used,   packing portion  better     edges  work . .
therefore favor flow decompositions    edges.
 possible. instead  using  standard push-relabel.
approach .,  prefer  augmenting-path algorithm.
 greedily sends flows along shortest paths.  implementation uses  simplified version   ibfs .incremental breadth first search. algorithm .,  .
  fast  push-relabel   test instances.
. forced assignments. assume   already.
computed  flow bound  followed   additional.
packing lower bound  .using  neighbors   .
roots.   free vertex ,  .   set .
neighbors   . graph without flow edges., .
deggf . . .,      cell . .
packing partition. containing .   often use.
logical implications  assign   one   sides .
 . without actually branching  .  idea .
simple.    show  assigning   one side.
 increase  lower bound   least match .
upper bound,   safely assign     side.
first, consider   happen    added.
 .  .,  expansion  ,   number .
nontrivial cells .  packing bound.  contain.
vertices  . note  . . . . deggf .
assigning     create . disjoint paths .
  , effectively increasing  flow bound   . .
. .see figure . note, however,   . may.
   valid lower bound, since  new paths may.
interfere   .pure. packing bound. instead, .
compute  restricted packing lower bound ., taking .
trivial  cells  intersect . . just assume .
belong  .   .   least  high   current.
upper bound,   proven   must  assigned.
 .  general,  test will succeed   .
cells  unevenly balanced .otherwise  increase .
flow  offset   decrease   packing bound.
conversely, consider   happen   .
added  .   split   deggf . cells, one.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  .
figure . illustration  forced assignments. left. state  initial bounds   computed . flow.
edges already removed. filled circles belong  ,    free. middle. assigning     increase .
flow bound. right. assigning     increase  packing bound  splitting  cell  several ones.
rooted   neighbor  .  size   new.
cell   computed  constant time, since  know.
 subtree sizes within  original spanning tree .
.   recompute  packing lower bound .using.
 original cells,   replaced   newly-created.
subcells.  add    original flow bound  . .
  least matches  current upper bound, .
  proven   must actually  assigned  .
 works particularly well  trivial cells . packing.
bound  unlikely  change  nontrivial ones.
note   forced assignments  work .
lower  upper bounds   close.  main benefit   eliminate vertices    good candidates.
 branching. since  tests   fast,  .
still worth running.
. extensions.   easily generalize  packing bound  handle .-balanced partitions.   case,.
cells must  size   . . .  .
least . . .  packing bound must distribute.
. vertices instead  . dealing  weighted.
vertices  also quite simple.  packing bound  .
minimum number  cells containing  least half  .
total weight.  creating  packing partition, .
 therefore strive  make cells balanced  weight.
instead  number  vertices.   easily  incorporated   local search.  handle small integral.
edge weights,   simply use parallel edges. additional extensions .  arbitrary edge weights  partitions    two cells.  possible,  .
complicated.
. branching.
  lower bound   given subproblem .,. .
 high enough  prune ,  must branch  .
.note ,   cell containing   nontrivial,  .
split   deggf . . . cells  keeping  original root. .
simplicity  performance,  implementation    .
unassigned vertex , creating subproblems . ., .
 .,.  experiments show   choice.
 branching vertices   significant impact   size.
  branch-and-bound tree .  total running.
time. intuitively,   branch  vertices .
lead  higher lower bounds   child subproblems.
given  lower-bounding algorithms,   infer .
properties  branching vertex   .
first,  flow  packing bounds   benefit    assigned vertices evenly distributed.
.  sides   optimum bisection. since  .
 know   bisection ,  reasonable strategy.
  spread vertices   graph  branching .
vertices   far     . .note .
 single bfs  find  distances   .   .
vertices.  call   distance criterion.
second,  prefer  branch  vertices  appear.
 large cells .  packing bound.  branching.
  large cell,  allow    split, thus improving.
 packing bound.
finally,  help  flow bound,   like .
send  large amount  flow   branching vertex .
   .  suggests branching  vertices .
 well-connected   rest   graph.  proxy .
connectivity   degree  ,  trivial upper bound .
 flow   .
 practice, connectivity tends    important    criteria,   branch   vertex   maximizes . . dist. . csize. . conn.,.
 dist. indicates  distance     closest.
assigned vertex, csize.   size   cell containing.
,  conn.   connectivity .degree.  .
. filtering.   graph classes .notably road.
networks., high-degree vertices  often separated  .
small cut   rest   graph .  makes.
degrees poor proxies  connectivity.   obtain.
  robust measure  connectivity  reusing .
packing algorithm described  section .  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
vertex ,   run  algorithm   . . .
 . .  find  partition   . .  deg.
cells.    well-connected,  cells   roughly.
  size.  ,  cells will  much smaller.
 others. unfortunately, computing  bound .
every vertex   graph   quite expensive,.
particularly  large road networks.
instead  explicitly computing  packing bound.
 every vertex   graph,  propose  filtering.
routine.  goal   modest. determine  .
   promising vertices .   highest.
degrees.  actually well-connected   rest  .
graph.   done  two stages.
first,  determine whether  vertex  separated   cut  exactly one  two edges   remainder   graph.  use  algorithm  pritchard.
 thurimella .  find  .-cuts  .-cuts  .
graph  linear time. . cuts  quite numerous .
road networks .   vertex , define cut. . .
   inside  .-cut  size   . otherwise,.
   contained   .-cut  size   ., .
cut. . .    vertices ,  cut. . deg.
 second stage  filtering computes  packing.
bound   set  containing  . vertices   .
highest cut. values .recall     best known.
upper bound.,  ties broken  random.  pack.
  corresponding values.  .   floor  .
average value  pack.   vertices  . .  .
vertices  . ,  set pack. . .
 branch-and-bound algorithm  uses .
standard criterion .dist. .csize. .conn.  choose.
 next vertex  branch ,  using  modified.
definition  connectivity. conn. . cut. . pack.
. contraction.
 lower bounds  consider depend crucially .
 degrees   vertices already assigned. .
precisely,       sum   degrees .
 vertices already assigned    , respectively,.
  .  .without loss  generality.   easy.
 see   flow bound   larger  ,.
   packing bound    . .
 regions  perfectly balanced.   maximum.
degree   graph   small constant .  often.
 case  meshes, vlsi instances,  road networks,.
 example.,  branch-and-bound algorithm .
prune anything  deep   tree. arguably, .
dependency  degrees     strong. .
fact  increasing  degrees     vertices.
 make  large instance substantially easier  solve.
 counter-intuitive.
 natural approach  deal    branching .
entire regions .connected subgraphs.  .  .
like  pick  region  add    vertices   .
one branch,       . since  .degree.
  region .,  number  neighbors outside.
 region.  substantially higher, lower bounds .
increase much faster   traverse  branch-andbound tree.  obvious problem   approach .
  optimal bisection may actually split  region.
 two. assigning  entire region      .
 exhaust  possibilities.
one way  overcome    make  algorithm.
probabilistic. intuitively,   contract  small number.
 random edges,  reasonable probability none .
 will actually  cut   minimum bisection. .
   case,  optimum solution   contracted.
problem  also  optimum solution   original.
graph.   boost  probability  success .
repeating  entire procedure multiple times .
multiple randomly selected contracted sets.  picking.
 best result found.  high probability,  will .
 optimum.
probabilistic contractions   natural approach.
 cut problems,  indeed known.  example, .
feature prominently  karger  stein. randomized.
global minimum-cut algorithm .,  uses  fact.
 contracting  random edge  unlikely  affect .
solution.  idea   used   minimum.
bisection problem  well. bui  . . use contraction.
within  polynomial-time method ,   input.
graph, either outputs  minimum bisection  halts.
without output.  show  algorithm  good.
average performance   class  d-regular graphs.
 small enough bisections.
since  goal   find provably optimum bisections, probabilistic solutions  inadequate. instead,  propose  contraction-based decomposition algorithm,   guaranteed  output  optimum solution   input.   . course. still exponential,.
  many inputs   much better performance.
  standard branch-and-bound algorithm.
 algorithm   follows.     upper.
bound   optimum bisection. first, partition  .
. disjoint sets ., ., . . . ,  .   subset ,.
create  corresponding .weighted. graph   taking.
 input graph   contracting   edges  .
, use  standard algorithm  find  optimum.
bisection    graph  independently,  pick.
 best.
theorem .  decomposition algorithm finds .
minimum bisection  .
proof.  . .    minimum bisection cost.
 must prove  min. . .
. first, note .
 . .  every , since  bisection    .
. copyright . siam.
unauthorized reproduction   article  prohibited.
trivially converted   valid bisection  . moreover,.
 argue   solution   least one  will.
correspond   optimum solution   . .
.   set  cut edges   optimum bisection .
. .     one optimum bisection, pick.
one arbitrarily.  . . .    sets.
 disjoint, . .    nonempty   .
. sets . therefore,    least one   .
. .  . . contracting  edges    .
change  optimum bisection, proving  claim.
 decomposition algorithm solves  . . independent subproblems,   high-degree vertices introduced  contraction  make  subproblem.
much easier   branch-and-bound routine. besides,.
 subproblems   completely independent. .
  share   best upper bound.  fact, .
 think   algorithm   single branch-and-bound.
tree   special root node    . . children,.
 responsible   distinct contraction pattern. .
subproblems   necessarily disjoint .  partial assignment may  reached  different branches.,.
    affect correctness.
. finding  decomposition.  decomposition.
algorithm  correct regardless   edges  partitioned among subproblems,   performance may.
vary significantly.  make  subproblems  comparable degree  difficulty,  edge partitioning algorithm  allocate roughly   number  edges.
  subproblem. moreover,  choice  .
edges  allocate   subproblem  also matters.
 effect   branch-and-bound algorithm  .
pronounced    create vertices  much higher.
degree.   achieve   making sure  edges.
assigned   induce relatively large connected components . clumps.  . . contrast,   edges .
  disjoint,  degrees   contracted vertices .
 will   much higher     remaining.
vertices. finally,  shape   clump matters. .
else  equal,   like  expansion .number .
neighbors outside  clump.    large  possible.
 achieve  goals,  perform  decomposition  two stages.  clump generation partitions .
 edges   graph  clumps,   allocation.
stage ensures   subproblem  assigned  wellspread subset   clumps  comparable total size.
 goal   generation routine   build  set .
 clumps .initially empty.  partition   edges .
 graph.     maintaining  set   candidate.
clumps,    necessarily disjoint  may .
include  edges   graph.  clumps    highexpansion subpaths extracted  bfs trees grown.
 random vertices. .  minimize .
number  internal edges,  paths tend   high.
expansion.    enough candidates  , .
algorithm transfers   clumps     final set.
 .  clumps  picked   greedily, according.
  expansion,  observing  constraint .
clumps   must  edge-disjoint.    longer.
 suitable clumps  high enough expansion .higher.
  certain threshold .,  new iteration  .
algorithm starts.  repopulates   growing new bfs.
trees,  transfers    resulting candidate.
clumps   .  algorithm stops    complete,.
.,  every edge   graph belongs   clump.
  .  ensure convergence,  algorithm gradually.
decreases  threshold .  iterations. initially.
 clumps   high expansion  added .
 ,  eventually even single-edge clumps  allowed.
. interested reader will find additional details .
section ,   appendix.
 allocation phase distributes  clumps  .
 . . subproblems ., ., . . . ,  .,   initially.
empty.  allocates clumps one   time,  decreasing.
order  expansion .high-expansion clumps  allocated.
first.   step,  clump   assigned   set.
 whose distance    maximum,  ties broken.
arbitrarily.  distance      defined  .
distance   vertex sets,  infinity   .
empty. . efficiency,  keep  voronoi diagram .
  explicitly, updating  whenever  new clump.
 added.  ensures clumps  well spread  .
subproblem.
. experiments.
 implemented  algorithms  . using visual.
studio .  ran  experiments  one core.
  intel core . duo . running windows .
enterprise  . ghz  .   ram.   couple.
 particularly hard instances .clearly marked.,  ran.
 distributed version   code using  dryadopt.
framework . draydopt  written  .,  calls.
 native . code  solve individual nodes  .
branch-and-bound tree.  distributed version .
run   cluster   machine  two . ghz.
dual-core amd opteron processors, .   ram,.
 runs windows server .  used . machines.
.  always report  total cpu time,  sum.
  times spent   . code   . cores.
.   cluster plus .   standard machine.
note   excludes  communication overhead,.
  negligible. unless otherwise mentioned,  find.
perfectly balanced partitions . . .
. parameter evaluation.  start  considering  effects   improvement  propose  perfigure . running times  increasingly sophisticated versions   algorithm   function   upper bound .
  inputs alue. .left.  mannequin .right.
formance.  concreteness,  focus  two instances.
alue.   vlsi instance . grid graph  holes.
used   benchmark instance   steiner problem.
 graphs .  . vertices, . edges,  optimum bisection opt . . mannequin   mesh .triangulation. used  computer graphics studies .  .
vertices, . edges,  opt . .
figure . shows  running times  several versions.
  algorithm   input bound  varies  .
 opt . . .  . opt ,  algorithm simply.
proves     valid lower bound.  version.
builds   previous one. version     basic.
 uses  flow bound,  packing bound .using .
 constructive algorithm  find cells.,  branches.
 random vertices. version  improves  packing.
partition using local search. version  adds forced.
assignments. versions    improve  branching.
criteria . random.  uses distances, cell sizes,.
 degrees,   filters well-connected branching.
vertices  well . explained  section . versions.
   decompose  problem  . subproblems.
 partitions  edges  random,   uses clumps.
 alue.,  version   algorithm  faster.
  previous one.  effect  minor   features,   forced assignments  random decomposition .since  subproblems  generates   much.
easier.  improvements.notably local search, sophisticated branching,  decomposition  clumps.
clearly improve  asymptotic performance   algorithm. .note   vertical axis uses  logarithmic scale. finally,  note   packing bound  leads  huge speedups. using   flow bound,.
 algorithm  take   . minutes  .
 . . slow  appear   plot.
 results  mannequin  similar, although decomposition    helpful . even hurts  edges .
distributed  random., since mannequin  higher original degrees  much fewer fixed edges per subproblem.
.  alue. .
  instances, version  spends half  time.
 process  node   flow computation, .
  half split roughly evenly among  remaining.
routines. constructive, local search, forced assignments,.
 branching.  indicates  processing  branchand-bound node takes essentially linear time. recall.
 filtering  done   preprocessing stage .separately.
  subproblem.,   alue. .  .
opt . .  almost  expensive  traversing  actual.
branch-and-bound tree.  mannequin,  takes roughly.
.   total time .   help  much.
  remaining experiments,  usually   use.
filtering .except  noted,  large road networks.
finally,  note   versions   algorithm.
 exponential dependence   .  suggests .
obvious algorithm  finding  optimum bisection.
opt   instance . case    known.  .
simply run  algorithm repeatedly  increasing.
values   .  algorithm will find  solution .
soon   gets  input  . opt . since  algorithm.
 exponential   ,  total running time  .
approach   much higher  running directly .
opt . . since  focus   lower bounds . .
minimize fluctuations.,  actually use  . opt . .
  remaining experiments, unless otherwise noted.
section . will examine  issue   detail.
. asymptotics.  now run  algorithm .
synthetic graphs  get  better understanding  .
asymptotic behavior.   test version  .without.
decomposition.  three graph classes.  first one.
figure . running times  various synthetic graph classes.
consists  delaunay graphs,  representing  delaunay triangulation   points picked  random .
 unit square.  second class consists  .-regular.
random graphs, built   union  . random perfect.
matchings. finally,  consider .-regular graphs .
planted bisections  size . . take  union  two.
.-regular random graphs  . vertices   add.
. random edges  . note   three.
classes  roughly   density . . ., .
differ significantly   expected minimum bisection.
size. approximately .
.
  delaunay, .  random.
graphs,  exactly .  planted bisections. figure .
.left. shows  average running times . . runs. .
 algorithm   varies.  always use  . opt . .
  clear  running times depend  strongly.
  bisection   graph size.  method quickly.
becomes impractical  random graphs . takes .
 two minutes  graphs  . nodes.,   much.
 practical  delaunay triangulations.  random.
graphs  small planted bisections,  running time.
 essentially linear  .  branch-and-bound trees.
 roughly . nodes . small fluctuations.
figure . .right. also considers .-regular random.
graphs  planted bisections,  now   . .
 varying bisection size.  expected, running times.
increase exponentially   bisection size.
. dimacs instances.  analysis indicates.
 algorithm   able  handle fairly large.
real-world inputs,  long   optimum bisection.
   large.  test ,  consider instances.
  . dimacs implementation challenge .
since  challenge  meant  evaluate mainly heuristics,  instances  quite large .  hundreds .
millions  vertices.   large bisections. still,.
 algorithm  solve  wide variety  .smaller. instances  optimality.  consider instances  four.
classes. clustering, delaunay triangulations, road networks,  instances  walshaw. graph partitioning repository .  clustering instances,  .
smaller,  use version    algorithm.   three.
remaining series .delaunay, streets,  walshaw., .
 larger  sparse,  also use decomposition .
clumps.
table . shows  detailed performance  .
algorithm.   instance,  show  number .
vertices .,  number  edges .,   optimum.
bisection value .opt., followed   total number .
nodes   branch-and-bound tree .   total.
running time   algorithm  seconds.
 expected, running times depend  heavily.
  size   bisection    graph . .
particular,  algorithm  easily solve luxembourg.
. road network., even though     .
thousand vertices.
  also find  minimum bisections  reasonably large delaunay graphs,   delaunay triangulations  random points   plane. note .
 version   algorithm . decomposition. .
actually asymptotically better   one tested .
figure . .without decomposition.
  also deal   inputs   walshaw repository .  every instance   table,.
 show .  first time,   best   knowledge.   best previously known bisections.found.
 heuristics ., ., ., ., . indeed optimal.
 algorithm  also find exact solutions .
 small clustering graphs.   instances, .
minimum bisection value  much larger relative  .
graph size.
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . instances   . dimacs implementation challenge  . . .    number  branchand-bound nodes  time   total cpu time.  runs  sequential except  data,  uses dryadopt.
class name   opt  time .
clustering karate . . . . .
chesapeake . . . . . .
dolphins . . . . .
lesmis . . . . . . .
polbooks . . . . .
football . . . . . .
power . . . . . . .
delaunay delaunay . . . . . . . . .
delaunay . . . . . . . . .
delaunay . . . . . . . . . .
delaunay . . . . . . . . . . .
streets luxembourg . . . . . . .
walshaw data . . . . . . . . . . .
.elt . . . . . . . .
 . . . . . . . .
add. . . . . . . .
whitaker. . . . . . . . .
 .elt. . . . . . . . .
.elt . . . . . . . .
table . performance  various large instances  . . .    number  branch-and-bound nodes, time.
  total cpu time.  runs  sequential except  dragon-.,  uses dryadopt.
class name   opt  time .
mesh dolphin . . . . .
mannequin . . . . . . .
venus-. . . . . . . .
beethoven . . . . . . . .
venus . . . . . . . .
cow . . . . . . . .
fandisk . . . . . . . . .
gargoyle . . . . . . . . . .
feline . . . . . . . . .
dragon-. . . . . . . . . . . .
road  . . . . . . . .
bay . . . . . . . .
col . . . . . . . . .
fla . . . . . . . . . .
 . . . . . . . . . .
vlsi alue. . . . . . . . .
alue. . . . . . . . .
alue. . . . . . . . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
. assorted large instances.  now consider.
 natural classes  large instances  relatively.
small . nontrivial. bisections.  take three classes.
 inputs. meshes .triangulations. representing various.
objects ., road networks .  . dimacs.
implementation challenge .,  shortest paths., .
vlsi instances . .grid graphs  holes. .
performance   algorithm  summarized  table .
 use decomposition  clumps   three classes,.
 filtering  road .  mesh  vlsi.  ,.
 use . . .   . opt . .
 table . shows,  performance   algorithm.
 depends  strongly   bisection  .
graph size.  particular,   solve fla  , .
   million vertices,  less   hour. .
  road networks need surprisingly  branchand-bound nodes.   instances,  large fraction .
 total time  usually taken  clump decomposition.
 filtering.   two classes considered .vlsi.
 mesh.  larger bisections,  need substantially.
 branch-and-bound nodes. even ,   handle.
vlsi instances  tens  thousands  vertices, .
well  reasonably large meshes.  figures .  . .
 appendix illustrate,  instances    means.
trivial.  particular,  solve dragon-. .whose.
optimal solution  illustrated  figure .,   .
use  distributed implementation.  contrast,  .
solve feline,   similar size  solution value .
 much  regular,  less  two cpu hours.
. comparison   approaches. .
now compare  algorithm   best mathematical.
programming techniques   aware . table .
compares  running times   algorithm .version.
.   best results reported  armbruster . .
hager  . .    publicly available . instances.
  literature, including meshes .mesh., vlsi.
instances .gap, taq.,  graphs derived  sparse.
symmetric linear systems .kkt.   instance .
use   common value  .   literature .either.
.  .  instances  edges  small.
integral weights,   converted  parallel edges.
  algorithm .  accounted    value .
 reported   table. note   algorithms.
 run  different . roughly comparable. intel.
machines. pentium . . . ghz.  armbruster .,.
xeon . . ghz.  hager  . .,  core.
. duo . . ghz.   algorithm.  runs .
sequential.
besides running  algorithm   . opt . .
  standard experiments.,  also consider  version.
   upper bound   given.  version.
repeats  basic algorithm  increasing values .
 . starting  . . .,  sets  . .uie  .
step   stops   finds  bisection   strictly.
better   current .
 table shows  either version   algorithm.
  faster .sometimes substantially .  .
mathematical programming approaches  instances.
table . comparison   exact approaches  armbruster .  hager  . .  two versions .
 method,  different input upper bounds  . note   results  hager  . .   available.
running times   seconds.
 . opt . .   given  algo.
name   . opt  time  time .arm. .hpz.
unauthorized reproduction   article  prohibited.
 relatively small bisections.  stress, however,.
  algorithms based  mathematical programming  handle graphs  large bisections . shown.
  table. much better.  algorithm   competitive   cases.  example, armbruster  solve.
 instance alue.  . minutes, whereas .
algorithm   prove opt . .   day, even.
  . opt . . given.
. final remarks.
 presented  novel branch-and-bound algorithm .
 find exact solutions  remarkably large real-world.
instances, particularly   small bisections. .
resulting algorithm  quite practical,   conceivably  used within graph partitioning heuristics,.
 often need  find bisections  small subproblems ., ., ., .  may  possible  obtain  speedups. improved branching heuristics, primal.
algorithms,  strengthened versions   packing.
bound . weighted edges.   help.  potential topic  future research  whether  techniques.
 propose .particularly decomposition,  also .
packing lower bound.   effectively integrated .
mathematical programming methods.  combination.
 recent results ., . suggests   minimum bisection problem  fixed-parameter tractable .parameterized  minimum bisection size.  planar  almost planar graphs,   road networks, vlsi, .
meshes.    interesting  know whether similar ideas  give nontrivial performance guarantees.
  variant   algorithm.
acknowledgments.  thank diego nehab .
 benchmark meshes  visualization tools, tony.
wirth  discussions   hardness  various subproblems,   referees   helpful comments.
</doc>
<doc title='016.txt'>
leveling  grid.
sabine cornelsen. andreas karrenbauer. shujun .
abstract.
motivated   application  image processing, .
introduce  grid-leveling problem.  turns  .
  dual   minimum cost flow problem  .
apex graph   grid graph   basis.  present.
 . algorithm   problem.  optimum.
solution recovers missing  coefficients  image.
 video coding  discrete cosine transform used .
popular standards like jpeg  mpeg. generally, .
prove     . min-cost flow algorithm.
 networks ,  removing one node,  planar,.
 bounded degrees,   bounded capacities.
 costs may  arbitrary.
. introduction.
 consider  recovery problem   context .
image  video coding.    easy  restore.
missing image information,    brightness .
isolated pixels  missing.   intuitive  set .
missing brightness   average   neighboring.
pixels    highly correlated. however,.
image  video data  typically transformed . .
 higher compression ratio  de-correlating redundant.
information  neighboring pixels. one  .
 used methods   discrete cosine transform.
.dct. .,    adopted  many image .
video coding standards like jpeg  mpeg.
briefly speaking, transform based coding works .
follows. first,  image .  video frame.  partitioned.
  .  blocks,     normally . ,.
 block  transformed independently   invertible.
linear map,   specify  sect. . precisely. .
one   transformed values  missing,  .
whole block will  affected, particularly,   .
important value, called   coefficient,   .
average brightness   block,  concerned.
.sabine cornelsen   department  computer . information science, university  konstanz, germany. email address.
sabine.cornelsen.uni-konstanz.
.andreas karrenbauer    zukunftskolleg.
  department  computer . information science, university  konstanz, germany. email address.
andreas.karrenbauer.uni-konstanz.
.shujun    department  computing, university .
surrey, guildford, . email address. shujun.surrey.
setting  missing  coefficients  .  computing  inverse transform yields  deviation  .
pixel. brightness   average   corresponding.
block.  obtain  initial guess   original image.
  shift  block    values just become.
non-negative .see middle  fig. .  average brightness   block   initial guess  certainly  lower.
bound   actual average brightness   block. .
thus remains  find  non-negative offset   block.
 level   artifacts along  block boundaries.
missing  coefficients   caused  selective.
encryption, transmission errors,  deliberate removal.
 malicious attackers.  instance, light-weight perceptual encryption   achieved  encrypting important transform coefficients . consider  live.
broadcast   sports event  paying subscribers.
 computational demands   customers. devices.
knowing  secret key remains low,    sufficient.
 spoil  pirates   effort   high  recover.
 stream without  key  acceptable quality .
 real-time.    hand,    efficient.
algorithms   recovery problem,  less data .
 sent  save bandwidth without reducing  quality.
noticeably.
. related work.  dct-transformed images.
 videos, researchers  proposed  implement.
perceptual encryption  selectively encrypting parts.
  transformed values,  include encrypting.
different subsets . certain bits   ., .
one widely used setting   encryption, . .
 coefficients  encrypted.  main purpose.
 perceptual encryption  twofold.  one side, .
encrypting  part   image  video data .
additional computational load  reduced.   .
hand, keeping  dct coefficients untouched leaves.
 space   postprocessing . watermarking.
  unencrypted part. without access   key.
normally  encryption part  guaranteed  using.
 cryptographically strong cipher like aes. however,.
 attacker might cheat  dismissing  encrypted.
part  instead recovering    unencrypted.
information.   encryption,  means recovering.
missing  coefficients  known data.
  image processing field,   widely thought.
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure .  original    left,  remainder without  missing  coefficients    middle,  .
recovery  solving  grid-leveling problem    right.
 missing  coefficients   effectively recovered,  uehara  . reported  .  one .
approximately recover missing  coefficients  exploiting  fact   difference  neighboring pixel.
values  natural images observes  laplace distribution.
 zero mean  small variance .  method.
generally works well   computationally efficient,.
  perceptual quality   recovered image  .
always good enough.
 improved  recovery method  reported.
 .  method  slower,   produce better.
recovery results  general.    based   explicit.
mathematical optimization model,    empirical.
observation.  .,   .  developed  .
recovery problem  modeling    linear program,.
  produce even better results.   almost.
impossible  distinguish  original   optimum.
solution  fig. . moreover,   approach allows .
recovery       coefficients, .
  possible   methods proposed .
.  contribution.  present  first exact.
combinatorial algorithm  dc-recovery  transforming  linear program  .   combinatorial optimization problem called grid-leveling problem.  show.
    dual   minimum cost flow problem .
bounded capacities.  allows   improve  time.
 compute  optimum solution  two orders  magnitudes   demonstrate   experiments. moreover,  prove     combinatorial algorithm.
 finds   flow  minimum cost  . .
apex graphs  become planar graphs  bounded.
degrees  removing one node.  best previously.
known running time bound   problems comes.
   general analysis  interior point methods.
  minimum cost flow linear program  planar.
graphs .   .
.
log  log.,   . .
 upper bound   absolute values  costs  capacities,  generalizes   graphs   separator.
theorem, hence, including  graph classes mentioned.
.  bound   depend   costs  .
dominates  small capacities  large costs.  becomes.
.cmax . .  arbitrary capacities    cmax.
recently, cornelsen  karrenbauer  presented.
 . algorithm  planar graphs  bounded.
face-degree, bounded costs,  infinite capacities .
however,  conditions   fulfilled   gridleveling problem.
    want  consider  block size  .
  constant   grid-leveling problem,  obtain .
running time  . logn.   algorithm,.
     number  blocks.   logn comes.
 sorting  numbers,  may  reduced .
 log logn   input data  integer  integer.
sorting   unit-cost-ram  used .
 paper  organized  follows.  sect. ., .
introduce  mathematical model   dc-recovery.
problem.    transformed   combinatorial.
problem  sect. .  sect. .,  show  .
efficiently solve  grid-leveling problem   min-cost.
flow problem.   end,  follow  divide .
conquer approach  sect. . using planar separators,.
   introduced   seminal work .
lipton  tarjan .,     used.
  last three decades  various forms  planar.
flow problems . ., ., ., mainly  shortest-path.
 max-flow.  conclude   presentation .
computational experiments  sect. .
.  dc-recovery problem.
  self-contained,  mention briefly  concept.
  block-wise dct typically used  image coding.
first,  image  partitioned  blocks  size  . .
 xij . .xmin, xmax. denote  values   pixels .
  block, . . . ,  .  .  dct coefficients.
.  defined    . two-dimensional dct .
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure .  illustration   basis vectors   twodimensional dct.  vector corresponding   .
coefficient    top-left, .  . . . .
follows.
.
xij .
.
.,.
., , , . . .
.
.
.
.
.
.,.
.
., , , . . .,.
.
., , , . . ckc. cos.
.
.
 .
.
cos.
.
.
 .
.
,.
  .
.
.   . . .
.
.   . .
note  . .   linear map   indices .
relative   block.  will use  .  .   denote.
 block-wise dct   following. since  dct .
invertible,    considered   basis transform .
 vector space.  illustration  given  fig. .
 .   coefficient   uniform vector.
 .   component,   called   coefficient due   analogy  direct current.  others.
 called  coefficients  reference  alternating current. note   contribution    coefficient .
equal   pixel    block.
  recovery problem  based   property,    well-known feature   natural images .
property .  differences  neighboring.
pixels  well described   laplace distribution .
zero mean   small variance.
note   consider  .-neighborhood    pixels .  ,  difference   left, right, top,.
 bottom neighbor   pixel  accounted. hence,.
 pair  pixels  considered twice  alternating.
sign.  distribution  therefore symmetric . .
mean  .
 wish  recover  missing  coefficients .
  resulting pixel values maximize  likelihood.
according  property .  ,  shall minimize.
 maximum likelihood estimator .mle.   standard deviation . since  probability density function   laplace distribution  mean .  given .
. . .
.
.
.
exp.
. . .,  mle  .  . .
    number  observations .
thus,    solve  following linear optimization problem .
.
min.
.
,.
.xij . ., . .xij . ,.
.  .  . ,.
xmin . xij . xmax,.
. . .
.
.    coefficients.
 last equality fixes  coefficient ykl   known.
value .   coefficient .   block remains.
   variable.
. transformation   combinatorial problem.
  following,  first transform  noncombinatorial linear program .     .
integral constraint matrix. afterwards,  derive  mincost network flow problem   dual.  enables.
  solve  recovery problem   efficient combinatorial algorithm.
since many variables  .  pre-determined,.
 will simplify  formulation  follows.  first.
note     one free variable   block.
 consider  arbitrary block    following. .
. denote  dc-free part  xij , .  contribution.
   coefficients.  mentioned   introduction,.
.   deviation   average brightness  .
block. formally,   xij .
.
 . .
.
 .  .
.
min.
  minimum   .   block. since .
 pixel values  integers   range  xmin.
 xmax, typically  ., . . . , .,  obtain integers.
. . .
.
 . .min . xmin,  correspond   initial.
guess   middle  fig. .   introduction. hence.
 may assume  xij . . ,    variable.
   integer offset   added   shifted dc-free.
pixel values .   block .
since   value   block,  thus also .
corresponding h-variable, contributes   pixels  .
 block equally,   pairs  neighboring pixels.
 belong  different blocks  relevant.
hence,  may restrict    pairs. put.
differently,   consider  .-neighborhood relation   pixels   grid graph,  may contract .
edges within  block  obtain  grid multi-graph,.
say .  edges   graph  multiplicity  .
  pair     neighboring blocks,  .
parallel edges     correspond   pairs.
., .  ., ., . . ., . . . ,   neighboring pixels.
  ., .  contained  block   ., . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
block  block .
.
., .
.
.
.
offset.
.
figure .  illustration   grid-leveling problem.
contained  block    set ., . . .,. .
.,. . ., . see fig. .   illustration. .
 now ready  describe  mathematical model.
 throughout  paper,  consider  . . .grid  -multi-graph  . ., .   . . . .
vertices, .
 . ., . . .  . ., . .  . .,.
 . ., ., ., . .  .  .
. . . . . . . ., .
 . .  . , . . . . .
 grid-leveling problem . . ., ., , .  defined.
 follows. given  .  . .   .  .  .
., . . ., . find  .  .  .
minimize.
.
.,.
max., . . ., . . .
.,.
subject .
. . . . .   . .
note  ., . . ., . . . . . .
., . . .,. . .,. .  adding  inequalities . ., . . ., .  ., . . .
 ., . .  ,  obtain  proper linear programming formulation.   matter  fact,    .
  integer polyhedron since  constraint matrix.
 totally unimodular.    hard  see   constraint matrix  made    transpose   network.
matrix   identity matrices  attached.
 implies     integer optimum solution vector whenever  optimum  finite.  may.
compute   vector  polynomial time   ellipsoid method .   interior point methods .
 general,  yields   weakly polynomial bound,.
 using  result  tardos .,  obtain  strongly.
polynomial time algorithm   problem.  holds.
 general  computing least absolute deviation regressions  equations   totally unimodular matrix, .
 integer right-hand side,    integer variables.
may  bounded  unbounded integer.
  remainder   paper,  give  combinatorial algorithm  solves  grid-leveling problem.
efficiently.  algorithm  based   dual  .
obtain   reformulation   maximization problem, .,   problem    objective function.
 replaced  .max.
.
.,. ., .  use.
 primal.dual relation.
max.ctx .  . ,  . . .
min.  .   . ,  . .,.
 translates  grid-leveling  finding  function.
 .  .  . .  minimize.
.
. .
.
.,.
., ., .
subject .
. .
.
.,.
., . .
.
.,.
., . . .
  .  .
., . . .
 ., . .  .
. solving  min-cost flow problem.
 min-cost flow network  consists   directed.
.multi.graph  . .,., edge capacities  .  . .
., node demands  .  .   . . . .,.
 edge costs  .  . .  pseudo-flow     map.
 .  . .  . . .   . .  pseudo-flow.
  flow   deficiency.
 . . . .
.
.
 head  .
.
.
.
 tail  .
.
  node  .   zero.  map  .  . .  .
min-cost flow       flow    minimizes.
 cost.
.
. . among  flows.
 residual network . . ., .,  ,  , dpi.  .
min-cost flow network  . ., , , .,  pseudo-flow.
 ,  node potentials  .  . .  defined .
follows.   edge  .       edge.
set  contains   dpi. . . . . . .
  . . . . . . .   reversed copy .
     dpi. . . . . . . .
 . . . . .  costs dpi  called .
reduced costs     residual capacities. .
node potentials  valid  dpi. . .    .  .
note   flow  minimum cost     .
valid node potentials.
    path   residual network . .
., .,  , dpi.   . .   minimum capacity.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  edges  . augmenting  pseudo-flow   .
path   . . . . means adding .     edges.
    original edges    subtracting . .
   edges      reversed copies .
edges  .
 successive shortest-path algorithm . works .
follows.  starts   node potentials  . . .
 pseudo flow     edges  negative costs.
 saturated, . . . .  . . .  . . .
otherwise.  long     node   positive.
deficiency,  algorithm tries  find  shortest path.
       node   negative deficiency.
.  edge distances  dpi.  augments   .
 min. .,  .,. .   step   .
 .   length distf,., .   shortest sv-path .
. , dpi.  added  ., thus maintaining  valid. see.
algorithm .   pseudocode.
algorithm . successive shortest-path .
input . min-cost flow network ., , . .
. .  . . .
output. min-cost flow  .  . .  ., , .
 valid node potentials  .  . .,.
 initialized  .
successiveshortestpath., , .
  edge   . . . .
. .
    node    . . . .
singlesourceshortestpath. , dpi, .
  .  .
. . . distf,., .
augment   min. .,  .,. . .
shortest st-path       . . .
return ., .
  planar .multi-.graph  . .,.  . .
. , .   apex graph   one additional node.
.  added       .   edge .
  .  added  ., ., . .  . . .
. .  . ., ., ., .  .  .
 now . . ., ., , .   instance .
 grid-leveling problem.  dual problem  .
modeled   min-cost flow problem ., ,  . ., . .
follows.   edge  . .  . . .   .  .
infinite otherwise. ,  ., . . .,  .  ,.
 ., . . .,  .  .   optimum solution .
 min-cost flow problem ., ,  . ., .   optimum.
solution   dual   grid-leveling problem. see.
fig. .   illustration.
moreover,  node potentials computed  .
successive shortest-path algorithm yield  optimal.
 .
., . ., .
., .
.
.
.
. grid-leveling problem.
.
.
.
., . . .
., . . .
., . .
., .
., . . .
., . .
., . .
. flow network.
figure .   grid-leveling problem   associated min-cost flow problem.
solution   dual problem   min-cost flow.
problem, , hence,   primal problem. .
explicitly state  property   special case, . .
 grid-leveling problem.
lemma .   . ., ,  . ., .   min-cost.
flow problem   instance ., , .   grid-leveling.
problem.     flow    valid node potentials.
.  . . . . .   optimal solution .
., , .
proof.    infinite capacities,  ., .
 ., .    residual network.  follows .
. . . . . .  . . . . . . thus,.
. . . . . , hence,    feasible solution .
 grid-leveling problem.  next show .
.
.dpi. .
.
.,.
.max., . . ., .
  . . assume first   . ., . .  . .
., . . . . .  ., .    residual network.
thus, ., . . ., . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
. .
.
. .
. . . .
.
. .
. .
.
. .
. .
.
. .
.
.
.
.
.
.
. .
.
.
. .
. .
. .
. .
.
. .
.
.
. .
. .
. .
. .
.
figure . illustration  algorithm . .  instance   min-cost flow problem associated   gridleveling problem   . . .-grid .-multi-graph. horizontal edges  cost .   left hand side  edges.
pointing downward  cost .   edges   apex  cost .   right hand side  edges pointing.
upward  cost .   edges   apex  cost .  edges  dotted. .  grid  divided  two.
parts,  apex  duplicated. .  recursive solution   two parts. node labels indicate node potentials.
edges  non-zero flow  solid. .  potential   apex  set   maximum   potentials  .
two copies, adjusting  potentials   respective component. .  final flow  computed.
. , hence, max., . . . . ., . . . .
., . . .  ., .    residual network.
, hence, . . ., . . . . . . ., . .
. . .  follows  .max., . . . .
., . . . . ., . . dpi., . .
 cases  follows .
.dpi. . .max., . . ., .
assume now   . . .    . . . since.
  infinite capacity  follows  ,   . .
  residual network. thus, dpi. . . since   .
flow  follows .
.
. .
.
.
.dpi.
.
.
.,.
.max., . . ., .
 thus,   weak duality,    optimum solution.
  grid-leveling problem     optimum.
solution   dual min-cost flow problem.
.  divide  conquer approach.  .
section,  show   use  divide  conquer approach  efficiently solve  min-cost flow problem associated   grid-leveling problem.  generally,.
 show  following theorem.
theorem .  min-cost flow   apex graph .
  removal  one node yields  planar flow network  . edges, capacities   cmax  node.
degree   .   computed  .cmax.
.
.
time.
proof.   following,  denote  apex  .  .
write . . .
.
. . .  .
. .  .  may assume.
algorithm . recursive min-cost flow.
input . min-cost flow network.
 . . . . . ., ., , , ., .
., . . ., . .,  . .
output. min-cost flow     valid node.
potentials ,  initialized  .
recursivemcf., , , .
., . cut.
  . ., . .
. . , pii. recursivemcf., ,.
  . . ., .
. max., .
  . ,  . ., . .
. pii. pii. . .
return ., .
successiveshortestpath. ,  ,  , dpi.
.    edges ., ., ., .  infinite.
capacity    .  , since  may add  edges.
 sufficiently large costs, say  sum   absolute.
values   original costs plus .  auxiliary.
edges may lay  parallel  existing edges  still .
number  edges remains  .  instance .
 auxiliary edges  always feasible   original.
instance  infeasible      auxiliary edge .
used   optimum solution.
  . . . . . ., ., , , .   mincost flow network    subgraph  . .,.
induced    planar.  algorithm works  follows.
.see algorithm .   pseudocode  fig. .  .
illustration.
 compute  cut ., . .  . .    linear.
time .   . . . . .,  . ., .,  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
set  cut-edges ., ., .,  set  edges .
 incident  ,  vertex  .  ., contains.
. edges.  . . . . ., .,  . ., .  .
subgraph  . induced   . .
  recursively compute min-cost flows  . ,.
 . ., .  valid node potentials pii  . note.
  modify . . .   respective recursive call.  merging  two recursive solutions,  set . . .    . ., . since.
. . . . .  follows   . . . .
thus    flow  . furthermore,  exploit .
fact  node potentials remain valid   .
value  added    .  allows   achieve.
valid node potentials   edges  . . .  setting . . max., .   adjusting .
potentials   respective component. note, however,   edges  ., . might  negative.
reduced costs.  will  fixed   call   successive shortest path algorithm.  saturating .
edges  negative reduced costs,  sum   deficiencies   vertices  positive deficiency  .
bounded .
.
.,. . . .cmax.
.
. hence,.
    .cmax.
.
. iterations within successiveshortestpath. since  shortest-path computation   performed  linear time .  recursive step , hence,  whole algorithm finishes .
.cmax.
.
. time.
. dealing  multiple edges.   gridleveling problem,   multiple edges  two.
vertices. since   pair  adjacent vertices , .
  residual edge      minimum.
reduced cost    considered,  shortest-path.
computation    performed   simple directed.
graph.  decide  edge among  parallel edges.
 two adjacent vertices    considered.
  next shortest-path computation,  first sort.
 edges  totally . logn. time  maintain.
 pointer   edge  minimum cost among .
parallel edges   residual network. note  .
pointer   updated  asymptotically  extra.
costs.
  bidirected grid graph,  originates .
 .-neighborhood   application,   . . .
since cmax . . due   uniform objective   gridleveling problem,  obtain  following theorem .
applying theorem .  multiplying  number .
edges   cut   .
theorem .  grid-leveling problem   grid.
 -multi-graph   vertices   solved .
. logn . time.
note   balanced cut    . cut.
edges   easily constructed   grid  -multi-graph.
 dividing  longer   two sides   middle. .
shall remark   simple implementation  dijkstra.
 binary heaps computes shortest paths  . log .
 graphs  . edges   thereby  lose .
log-factor.  ,  obtain  practical . log .
algorithm  solving  min-cost flow problem  .
case. furthermore,   use  variant  extend.
 .-neighborhood  obtain  .-neighborhood .
adding four nodes   corners,   also often.
used  image processing. note     planar.
  minor closed anymore,   edge separator.
 still  size .
.
.
. experiments.
  implemented  combinatorial algorithm .
. custom-tailored  solve  grid-leveling problem.
efficiently. since  range  valid pixel values .
typically ., . . . , .   application,  shortest.
path distances  bound  twice  range.  thus.
use  bucket queue  queue operations  constant.
time   implementation  dijkstra. shortest path.
algorithm,   also runs  .  therefore.
relieves   implementing  much  involved.
algorithm  . moreover,  edge-separator .
trivially computed   grid  dividing  longer .
 two sides   middle.
 test set consists  . instances  result.
 . images  original size . . .  .
 down-scaled  square images  side lengths.
 ., ., .,  . pixels  measure  scaling.
behavior.  experiments   carried   .
dell . laptop   intel dual core cpu .
 .ghz.  .  ram.  first compare.
 computation times   implementation  .
combinatorial algorithm  solving   model .
 cplex . concert . framework .see fig. .
 measured computation times comprise  time .
solve  instance  ram.  ,  exclude  time.
 reading  writing image data    disk,.
  setup time   corresponding data structures.
  fair comparison,  take  cpu time  .
consumed   barrier optimizer .  fastest.
  available  algorithms  cplex .  .
type  problem.   cpu time   consumed.
  combinatorial algorithm.   small instances.
  new algorithm,  time  measured  .
runs    instance  scaled  accordingly.
   lower precision   built-in timing.
functionality .linux kernel ., . compiler .
 one  see  fig. .,  combinatorial algorithm   two orders  magnitudes faster  average   interior point method  solve  equiva. copyright . siam.
unauthorized reproduction   article  prohibited.
. . .
pixels.
.
.
.
.
.
.
.
.
tio.
 .
tim.
 .
.
cplex .
 algorithm.
figure . comparison   lp-model solved  cplex .   flow model solved  .
implementation.  two lines correspond   fitted functions . . .  . . .  top .
bottom, respectively.  parentheses indicate uncertain digits due   statistical error.  error bars show.
 standard errors   means.
lent   images    size  . . although.
 fitted exponent   combinatorial algorithm .
larger   one  cplex,  two curves intersect   . pixels, .  images  height.
 width  one million. needless  say   will.
 happen  practice   near future, since moreover,  memory requirement  cplex   .
.   images  size . . . whereas less .
.   allocated   combinatorial algorithm .
images   size. note   algorithms produce.
nearly   results . image quality compared.
  original images . average ssim  . .
 approaches   average psnr  .  .
combinatorial algorithm  .  . although.
 algorithms compute  optimum solution,  optimum      unique.  explains .
tiny difference   image quality measures.
 remains  discuss  depth  recursion  .
one  compute  min-cost flow   subinstance.
directly.  data  fig. .   recursion level .,.
  define   recursion. since  sample means.
  levels  recursion almost coincide  .
plotted ones,    show   avoid clutter. .
rather concentrate   images  size . . .
demonstrate  effect   recursion depth  fig. .
  negligible   mean computation time, .
 variance decreases  stagnation  recursion.
level .
note     test  scaling </doc>
<doc title='017.txt'>
evaluation   mso-solver.
alexander langer. felix reidl. peter rossmanith. somnath sikdar.
abstract.
 fundamental theorem  courcelle states  every problem definable  monadic second-order logic.
.mso.  solvable  linear time  graphs  bounded.
treewidth.   paper,  report   ongoing effort  develop  general purpose software tool designed.
 solve mso-definable optimization  decision problems  graphs  small treewidth.  discuss  theoretical underpinnings   tool  present experimental results,  indicate    natural optimization problems mso based approaches might  .
suitable alternative  ilp solvers.
. introduction.
several real-world optimization problems   modeled  graphs  small treewidth. interesting examples include optimization problems  train .
road networks   underlying network  low.
treewidth.  instance, many local railway networks.
  generic star-like structure connecting  central.
station  nearby suburban stations.
 well-known example   station location.
problem ., ., .    given  railway.
network together  information   population.
  use   railway infrastructure.  problem.
  add new stops   existing railway network  .
 maximize accessibility   railway infrastructure.
  population.  variation   bus stop.
location problem .,  one   locate .
minimum number  bus stops required  ensure .
 passenger need walk    specified distance.
  normal boarding point  reach  express bus.
stop.
 practice, one strategy  tackle  problems.
  artificially transform  problem  easier subproblems  path-like graphs.  instance, one  .
approaches wagner lists   survey .   decompose  original np-complete set-cover-type problem.
. work  supported   deutsche forschungsgemeinschaft .dfg.  grant  .  mso-solver  .
found  http.tcs.rwth-aachen.sequoia.
.theoretical computer science, department  computer science, rwth aachen university, germany,.
.langer,reidl,rossmani,sikdar.rwth-aachen.
 subproblems   modeled     line.
segments.   subproblems,  underlying set.
covering problem   .consecutive ones property.
 ensures     solved  polynomial time.
  lp-relaxation ., . unfortunately,  .
cases   consecutive ones property   hold,.
   given input instance   splittable .
appropriate subproblems.  example,   task  .
find good locations  transmitters  cover  existing.
railway network  mobile internet access, interference  obstacles  easily destroy  consecutive.
ones property. similarly,  problems often become.
much harder   add additional constraints. .
example, connectivity   important aspect  meshlike wireless networks   ieee . finally,.
   multiple optimization criteria like using.
 minimum number  frequencies  reach  maximum number  customers,  add  minimum amount.
 new bus stops  benefit  maximum number  customers .  course,   ilp solvers   used.
  problems admit  ilp formulation.  large.
number  problems  practical interest fall  .
category. however, ilp-solvers   take  account  underlying tree-like structure   original.
instance. another disadvantage   one   first.
translate  original problem   ilp-formulation.
  able  use  tool.   problem.
might  several ilp formulations   time taken.
 different  different formulations.    art .
find   formulation  yields  best running.
time . particularly, connectivity constraints  .
 convenient  express   ilp, see ., . .
several ways    .
another option   develop tailor-made algorithms.
 exploit  underlying tree-like structure.  ,.
however,  clear whether  algorithms will .
faster  general ilp solvers. moreover,  take.
considerable time  energy  develop. generic.
solvers  hence   useful tool  ,  .
alleviate  need  develop customized algorithms,.
 usually  takes  lot less effort  implement.
 problem specification   come   good.
algorithms.
  paper,  report   generic software tool.
 solves mso definable optimization  decision.
. copyright . siam.
unauthorized reproduction   article  prohibited.
problems  graphs  small treewidth. mso  .
powerful language     rich expressive power.
 allows  express optimization problems   natural.
manner.  example, connectivity constraints .
easily  modeled. many people, however, consider .
theorems ., ., . underlying  approach  purely.
theoretical.  instance, niedermeier writes   wellknown textbook  parameterized algorithms.
 must  emphasized, however,   now.
described methodology   purely theoretical.
interest   associated running times.
suffer  huge constant factors  combinatorial explosions  respect   parameter treewidth. . . . .  establishing fixedparameter tractability   way,   second step one   head   concrete,.
problem-specific algorithm  improved efficiency ., . .
  paper,    first time systematically compare  performance   mso-solver   established commercial ilp solver,  somewhat surprising.
results.
overview.  paper  organized  follows.
firstly,  briefly recap treewidth, mso   msodefinable optimization problems   solved  theory.   highlight  technical difficulties .
implementing  theoretical algorithms,   .
try  circumvent  problems.   provide experimental results  four important, natural graph.
problems, namely minimum vertex cover, minimum dominating set, .-colorability,  minimum connected dominating set.  majority.
  instances   deal   grids  subgraphs  grids.   instances, minimum vertex.
cover  .-colorability  solvable  polynomial time .  graphs  bipartite.  .
lp-relaxations   respective ilp formulations already yield optimal results. hence,  tool  limited.
practical utility   problems. however,   two.
domination problems,  tool outperforms  commercial cplex software.  large instances, even  .
allow cplex  return non-optimal solutions. finally,.
 provide experimental results   graph obtained.
  real world railway network.
. mso-definable optimization problems.
 graph theory, treewidth  pathwidth  two important parameters  describe  close  given.
.http.www-.ibm.com.software.integration.
optimization.cplex-cp-optimizer.
graph    tree   path, respectively. measuring  tree-likeness   graph  helpful   .
 gives structural insight,   many npcomplete problems  easy  solve  graphs  small.
treewidth. indeed courcelle. celebrated result states.
  problem expressible  monadic second order logic .mso.  linear time solvable  graphs .
bounded treewidth .  mentioned , instances.
 real-world problems often  low treewidth. .
fact coupled  courcelle. theorem gives hope .
 exist algorithms  many np-complete problems.
 compute optimal solutions  real-world instances.
  reasonable time. however, one  blindly implement  approach  .   requires  construction   tree automaton,    power set.
construction easily consumes  much memory. hence,.
   interest  develop  generic software tool .
 tackle  problems  produce optimal solutions.
  reasonable time.
monadic second-order logic .mso. extends firstorder logic  quantification  sets  objects, see,.
., . mso   convenient logic  express properties since  resembles  way  specify properties.
  natural language. therefore, mso typically allows.
  natural expression  constraints.   linmso.
framework, . ., .,  mso-definable constraints.
  used  express linear optimization problems.
 ., . . . , .   mso-formula  free set variables ., . . . , ,   ., . . . , . .   integers. .
 graph  . .,.  problem  computing.
min.
. .
.
.
.
., . . . ,  .    . ., . . . , .
.
 called  linmso-definable optimization problem. .
example,  following well-known graph problems minimum vertex cover  minimum dominating.
set   decision problem .-colorability  .
written .
. min. . .  .    . .,.
. min. . .  .    . ., .
. min. . .  . .col .,.
.
. . .adj ., . .  .  .  . .,.
. . . .  . . .  . adj ., .,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.col . .
.
. .
.
. . . .
.
.
. .  . . . .
.
.
.
.
.adj ., . .
.
.
. .  . . . .
.
.
furthermore, mso allows  take  transitive closure   edge relation .  example, connectivity.
constraints  easily  added  expressing  .
set   connected iff   non-empty, proper subsets       edge     . . .
mso,  translates   formula connected. depicted  figure .  minimum connected dominating set problem   conveniently  written.
 min.
. . .  .    . . . connected.
 mso model checking problem  defined  follows. given  mso-formula .   graph , decide.
whether    model  .   problem .
pspace-complete .  general graphs,   significantly easier  graphs  bounded treewidth. treewidth.
  graph parameter  essentially measures  similar  graph    tree.   graph  small treewidth,.
 allows   tree  path decomposition  small width,.
  essence exposes  underlying tree structure .
 graph.  definition  treewidth   details .
constructing  tree-decomposition   required .
following  paper  hence  omitted.  refer.
 reader  surveys   ., .
courcelle. theorem . states   problem.
definable  mso   solved  linear time  graphs.
 bounded treewidth.    generalized   rich.
class  counting  optimization problems including.
 linmso-framework ., .   well-known .,.
.   model checking problem  mso  .
solved  constructing  finite-state bottom-up tree.
automaton.  methods   extended  tree.
automata  recognize  tree decomposition  .
input graph      graph   model  .
mso formula, see, . ., .
however,  turns   even  trivial problems.
like testing connectivity,  straightforward approach.
 constructing  tree automaton  infeasible  practice ., ., ., ., .   formulas,  problem.
lies   state explosion   required power-set construction.   even  case .  optimized.
software like mona .  used,    designed  overcome    difficulties .
recently,     couple  approaches.
 avoid  state explosion problems.  ., .,.
 authors consider monadic datalog.  ., ., .
automata  constructed on-the-fly   power-set.
construction  avoided  considering  existential.
formulas without universal quantifiers.  ease .
specification   fly-automata, .special treewidth.
 introduced  .
  use  new approach  essentially works.
 follows . details   .  starting point .
 simple algorithm  evaluates  formula .  .
input graph  . .,.   recursive manner. , .
example,  formula  .   set variable , .
algorithm checks whether  . . holds   sets.
 .  .   structure   elements,  straightforward recursive model-checking algorithm takes time.
.   formula    nested quantifiers,.
  requires polynomial space.  particular,.
one   need  use  expensive power-set.
construction  turned   cause problems .
 practical application   automata theoretic.
approach.   modified  simple algorithm .
use dynamic programming   tree decomposition.
 extra information  need  save   tables .
 dynamic programming   shown   bounded.
 terms   length .   input formula .
 treewidth  . therefore,  bounded treewidth.
 constant .,  total running time  . .
general  constant factors   .  .
bounded   elementary function .  concrete.
problems   sometimes give rather precise upper.
bounds   size   tables.  instance, .
 minimum dominating set problem,   show.
  table contains   . entries, .
  entry  size    polynomial  .
 running time   generic approach   .
bounded  .wpoly. .  remark  .
currently best specialized algorithm   problem .
requires subset convolution techniques  process .
. entries  time .wpoly.
. implementation.
 implementation  written  .  development started  .,   first prototype  able .
solve minimum vertex cover  minimum dominating set  small grids .  took  large.
amount  time  memory  standard computer.
hardware,  indicated  table . since   .
introduced several improvements   algorithm .
 implementation.  current version consists .
roughly .,. lines  code.  use  google sparse.
table library.  efficient hash sets  hash maps,.
  significantly faster   stl versions pro.http.code.google.com.google-sparsehash.
. copyright . siam.
unauthorized reproduction   article  prohibited.
connected. . . . .  . . .     subset   ,.
. . . . .    empty, .
. . .  .  . .   also  proper subset   ,.
. .adj., . .  .  .  .  .  . .     edge beween    .
figure .  mso formula expressing   set   connected.
minimum dominating set.
graph memory usage running time.
path . . . .  . .
grid . . . .  . .
minimum vertex cover.
graph memory usage running time.
path . . . .  . .
grid . . . .  . .
table . running times  memory usage   first prototype implementation developed  .  two.
standard graph optimization problems.
vided  gcc.  implementation   utilize.
multiple threads  benefit  today. multi-core architectures,   principle  approach  well-suited.
 parallelization due   way  dynamic programming works.  plan  add multi-threading support.
  future.  note    also able  solve.
problems beyond  linmso framework. courcelle.
theorem   extended   much richer class .
problems.  particular, using appropriate semiring homomorphisms one ,  example, also enumerate .
solutions  count  number . therefore, even.
 complicated optimization criteria   specified.
consider,  example,  case  one wants  find.
pareto solutions  two optimization goals,  .
minimizing  number  new bus stops  benefit .
maximum number  customers. , one  needs .
provide  appropriate homomorphism  .evaluation.
function.  standard homomorphism  decision.
 optimizing solutions .find  minimum  maximum size solution  output   solution.  already.
available.   future,  plan  implement  plugin.
system   arbitrary homomorphisms  easily.
 used.
  follows,  shall briefly describe  improvements   implementation   underlying.
algorithms    largest impact   running.
times  memory usage.
implementation improvements.   dynamic programming framework, objects  stored .
tables  looked  multiple times.  usual  .
 table   node   tree decomposition, .
.http.google-sparsehash.googlecode.com.svn.trunk.
doc.performance.html.
contains  set  objects  describe partial solutions.
  pigeon-hole principle,  know  many .
 objects  contained  many different places .
  time,  wastes  lot  memory. additionally, full comparisons  store  retrieve  objects.
  expensive.  now guarantee   complex object  stored  .   possible .
  usually  modified.  implemented  pooling mechanism , given  complex object, returns .
pointer   equal, existing object,  stores  object.
 future use.  approach considerably decreased.
 total memory consumption  allows   replace.
deep equality tests  cheap pointer comparisons.
caching  result  complex operations  another large impact   running time. , .
pigeon-hole principle . number  vertices  assumed.
  much larger   treewidth. tells   .
computations  applied   large number  times,.
 instance   discover  new vertex   input.
graph.  now cache  results   expensive.
operations.   apply  expensive operation,.
 check   hash map whether   computed.
 operation ,   much faster  .
 computation .  practice  noticed massive.
speedups. table . compares running times   .
graph  caching caching.
grid . . .
grid . . .
grid . . .
table .  effect  caching complex operations .
 running time   minimum dominating set.
problem.
. copyright . siam.
unauthorized reproduction   article  prohibited.
small grid graphs   without caching.  .
notice  particularly large effect due   many .selfsimilarities.  grids.
algorithmic improvements. besides improving.
 implementation ,  also revisited  dynamic.
programming algorithm.  found  frequently .
 decide rather early whether    no-  yesinstance.  example,   subgraph seen  far.
  three-colorable,    clear   graph.
   non-instance    immediately discard.
 colorings.   able  generalize  concept.
 arbitrary mso formulas .  distinguish three.
cases. .yes.,  formula holds   graph, .,. .
formula   hold,  .unknown,. .,   .
continue   dynamic programming approach .
find  answer.  general  state  .unknown.
however, since   recursively apply  concept.
 subformulas,  resulting simplifications  many.
entries become identical.  saves  lot  time .
space,   consider   major reason  .
large improvements   running time relative  .
first prototype implementation  .
. experiments.
  section,  provide experimental results  several graph problems.  selected three standard graph.
problems  cover  range  packing, covering .
coloring problems, namely minimum vertex cover,.
minimum dominating set  .-colorability.
additionally,  consider minimum connected dominating set,   applications  .wireless. network design ., ., ., .  adds  connectivity.
constraint.
 problem instances  consider  subgraphs.
 grids, obtained  using  fixed probability  either.
include  edge  exclude .   denote .
probability   edge  kept   graph, implying.
   . .  grid remains unchanged.  created.
grids  small width , ranging  .  .  .
experiments, whereas  height    grid .
kept fixed  .  grids  treewidth . .
edge-probability   set  values  ., . .
 increment  .   run ten tests  .
 .  one   . .  total,  therefore.
created . graphs   . .  . .  .
, grids  width . .  . .  considered .
minimum vertex cover,  width . .  . . .
minimum dominating set,  width . .  . . .
.-colorability,   width . .  . .  minimum.
connected dominating set.
 choice  grids . subgraphs  grids. stems.
 two considerations.   one hand, many optimization problems related  traffic  exhibit  pathor grid-like structure . latter    case .
 width , say,  road   neglected. .
  hand grids offer  readily available bound .
 treewidth, namely  width  height .whichever .
smaller.
  second series  tests   minimum connected dominating set problem,  created grids.
  total number    . vertices .depending   width,  height  adjusted accordingly .
match  size.,   edge probability  .
 .   consider grids   width  .
 .   problem  much harder  solve.  best.
known deterministic algorithm . needs time .wwn.
 treewidth .   , five graphs  considered.
finally,   somewhat  realistic scenario .
used  data available  openstreetmap  created  graph   hannover urban railway. .
graph obtained  cleaning  raw data  openstreetmap  treewidth .   graph,  added.
possible locations  wireless base stations.  .
edges,  used  disc graph model, since  base station  assumed    bounded maximum range.
however,  assume  obstacles might hinder transmission  nearby vertices,    include edges.
 nearby nodes   probability  . .
resulting graph, depicted  figure .,  . vertices,.
. edges,  treewidth bounded  .  task now.
  select  minimum size connected set  base station locations, .,    solve  instance  .
minimum connected dominating set problem.
   instances mentioned ,  created.
suitable ilps  describe  instances.  minimum vertex cover, minimum dominating set,.
 .-colorability,  used  standard formulations.  minimum connected dominating set,.
 used  formulation  .,   connectivity.
 guaranteed  requiring  flow   nodes .
 solution.
 test setup   follows.  focus  multipurpose frameworks capable  solving  wide range .
problems,  therefore   include  specialized.
algorithms,  might  advantages  running.
time  usually take  long time  develop. naturally,.
 measured  running time   tool  asked.
 solve  problems. ,   given  mso specification   problem   told  minimize .
solution size. furthermore,  solved  instances.
 letting cplex find optimal  nearly optimal solutions   ilps. since  consider . solvers .
.state   art.  optimization,    include.
  frameworks   sat-solvers.
.http.www.openstreetmap.org.browse.relation.
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure .  cover  hannover urban rail network  wireless access generates  minimum connected.
dominating set problem.   left side   whole resulting graph    right side   find .
  parts  detail.
  tool  used  .bit linux machine .
 intel core . quad cpu running  . ghz  .
 ram.   solver   run single-threaded,.
    four individual test instances  run .
parallel  measured  cpu time used.  tool.
 compiled  gcc version .   .-flag.
cplex academic research edition .  used.
 solve  ilp instances.    run  dedicated.
. bit linux machines  equipped   intel core .
duo cpu running  . ghz .meaning  cplex.
 able  use two dedicated threads.  .  ram.
  cplex stop   integrality gap  . .
reached .set mip tolerances mipgap ., ., .
  insist  optimal solutions. cplex  given.
 time limit  . times  cpu time  tool required.
 solve  instances  optimality.
results. cplex performs  well  minimum vertex cover  .-colorability. since .
graphs  bipartite,   relaxation already provides  optimal solution.  tool  oblivious .
 fact  proceeds       graph.
  running time  cplex  less  one second   problems   include  results .
 mso-approach.  running times  minimum.
dominating set  minimum connected dominating set, however, show   certain instances.
 low treewidth  tool  compete  even outperform cplex   denser graphs.  sparser graphs.
  relaxations  turn    optimal  close.
 optimal.
 present  runtime results   grids .
size  . .   following figures  summarize.
 running times   problem  presenting .
minimum, median  maximum   running times.
  grid size.  .   runs  minimum.
dominating set, cplex found  optimal solution.
 . cases, cplex hit  time limit.   remaining.
cases,   able  shrink  integrality gap  .
within  given time limit,   solution found .
 optimal.
 solving minimum connected dominating set  grids  size  . ,    . .
  . .,  one exception cplex always hit .
time limit, ., within . times  cpu time   mso.
solver cplex   able  shrink  integrality gap.
 .  one exception   case  cplex ran .
 memory.    cases, cplex  find  optimal solution,    guarantee optimality since.
 integrality gap  still  large.   hardest.
graphs,   dimension . . .,  results depicted.
 table .  obtained.
  large railway network graph depicted .
figure .,  optimal solution  .  found  .
mso solver   . seconds   . .
 memory usage.    instance,  stopped.
cplex  . real time computation.  .
point,  best integer feasible solution found  far .
.,   remaining integrality gap  .
figure . running time  cplex  minimum dominating set  dense subgraphs  grids .edge probability.
 . .   . ., respectively.   majority   sparse instances   relaxation  optimal .
close  optimal.  problem becomes significantly harder  denser instances. even though  allowed .
return non-optimal solutions within  integrality gap  ., cplex took considerably  time   dense.
instances   exact mso solver.
. copyright . siam.
unauthorized reproduction   article  prohibited.
running time error condition best solution found optimal solution.
.   memory . .
. time limit . .
. time limit . .
. time limit . .
. time limit . .
table . cplex running times   minimum connected dominating set problem  subgraphs  .
. . grid   edge probability  .  time limit  hit  ten times   cpu usage required .
 mso solver  compute  optimal solution.
. discussion  conclusion.
  previous results show,  tool surprisingly.
performs much better  cplex   instances.
 small treewidth.  course, cplex  much better.
  instances     expected   highly.
optimized commercial ilp-solver.  main advantage.
  tool possesses    allow problems  .
specified   natural logic-based language   .
appropriate  many problems    graphs .
small enough treewidth, certain problems   solved.
much faster     tool.  time, .
plan  add   functionality  make  software.
 practical tool.  next big challenge will probably .
 include  kind  lazy evaluation  set variables.
 tool   tried    modern webbrowser   project. homepage .
</doc>
<doc title='018.txt'>
fast compressed tries  path decompositions.
roberto grossi.
universit.  pisa.
grossi.unipi.
giuseppe ottaviano.
universit.  pisa.
ottavian.unipi.
abstract.
tries  popular data structures  storing  set.
 strings,  common prefixes  represented .
common root-to-node paths.  fifty years  usage.
 produced many variants  implementations .
overcome    limitations.  explore new.
succinct representations  path-decomposed tries .
experimentally evaluate  corresponding reduction .
space usage  memory latency, comparing  .
state   art.  study two cases  applications.
.  compressed dictionary  .compressed. strings,.
 .  monotone minimal perfect hash  strings.
 preserves  lexicographic order.
 .,  obtain data structures  outperform.
 state-of-the-art compressed dictionaries  space.
efficiency,  obtaining predictable query times .
 competitive  data structures preferred  .
practitioners.  .,  tries perform several times.
faster   trie-based monotone perfect hash.
functions,  occupying nearly   space.
. introduction.
tries   widely used data structure  turn  string.
set   digital search tree. several operations .
 supported,   mapping  strings  integers,.
retrieving  string   trie, performing prefix.
searches,  many others. thanks   simplicity.
 functionality,   enjoyed  remarkable.
popularity   number  fields.computational biology,.
data compression, data mining, information retrieval,.
natural language processing, network routing, pattern.
matching, text processing,  web applications, .
name  .motivating  significant effort spent  .
variety   implementations   last fifty years.
however  simplicity comes   cost.  .
tree structures,  generally suffer poor locality .
reference due  pointer-chasing.  effect  amplified.
 using space efficient representations  tries, .
performing  basic navigational operation,  .
.part   work done   author   intern .
microsoft research, cambridge.
visiting  child, requires accessing possibly several.
directories, usually  unpredictable memory access.
patterns. tries  particularly affected   .
unbalanced structures.  height     order.
  number  strings   set. furthermore, space.
savings  achieved   exploiting  common.
prefixes   string set,     clear  .
compress  nodes   labels without incurring.
 unreasonable overhead   running time.
  paper,  experiment  path decompositions  tries help     mentioned issues,.
inspired   work presented  .  using  centroid path decomposition,  height  guaranteed  .
logarithmic, reducing dramatically  number  cache.
misses   traversal. besides,   path decomposition.
 labels   laid    way  enables efficient.
compression  decompression   label   sequential.
fashion.
 keep two main goals  mind. . reduce  space.
requirement,  . guarantee fast query times using.
algorithms  exploit  memory hierarchy.  .
algorithm engineering design,  follow  guidelines.
.  proposed algorithms  data structures .
  simplest possible  ensure reproducibility  .
results,   performance   similar  .
better    available   state   art.
.  proposed techniques  possibly lay  .
theoretical ground. .  theoretical complexity .
 operations  allowed   worse   known.
  best solutions     clear experimental.
benefit., since  seek   best performance .
practice.
 literature  space-efficient  cacheefficient tries  vast. several papers address  issue.
  cache-friendly access   set  strings supporting.
prefix search, . ., ., ., .     deal.
 space issues except .,  introduces  elegant variant  front coding.  papers aiming .
. example,   folklore   sequential scan   small.
sorted set  keys  faster   binary search   former.
method   friendly  branch prediction  cache prefetching  modern machines.
. copyright . siam.
unauthorized reproduction   article  prohibited.
succinct labeled trees  compressed data structures.
 strings, . ., ., ., ., ., ., ., support powerful.
operations.  path queries.   good .
compressing data,     exploit  memory.
hierarchy.  papers ., . combine .nearly. optimal.
information theoretic bounds  space occupancy .
good cache efficient bounds,   experimental analysis  performed.  references  compressed string.
dictionaries   found  .
 paper  organized  follows.  apply  path.
decomposition ideas  string dictionaries  section .
  monotone perfect hash functions .hollow tries.
 section ., showing    possible  improve.
 performance    small space overhead.
 section .,  present  optimizations  .
range min-max tree ., .,   use  support.
fast operations  balanced parentheses, improving .
 space  time   existing implementations .
 experimental results  discussed  section .,.
  implementations compare  favorably.
    best implementations.  provide.
 source code  http.github.com.path.
decomposed.tries   reader interested  .
comparisons.
. background  tools   following .
make extensive use  compacted tries  basic succinct.
data structures.
compacted tries.  fix  notation  recall quickly.
 definition  compacted tries.  build recursively.
 trie   following way. basis.  compacted.
trie   single string   node whose label   string.
inductive step. given  nonempty string set ,  root.
  tree  labeled   longest common prefix .
.possibly empty.   strings  .   character.
    set  . . . .  nonempty, .
compacted trie built    attached   root  .
child.  edge  labeled   branching character.
.  length   label .  also called  skip, .
denoted  . unless otherwise specified,  will use.
trie  indicate  compacted trie   rest   paper.
rank  select operations. given  bitvector ,.
  define  following operations. rankb. returns.
 number  occurrences  bit  . .,.   first.
 positions  . selectb. returns  position  .
i-th occurrence  bit   .  operations .
 supported  constant time  adding  negligible.
redundancy   bitvector ., .
elias-fano encoding.  elias-fano representation.
., .   encoding scheme  represent  nondecreasing sequence   integers  ., . occupying.
.
.
log .
.
. . bits,  supporting constanttime access   i-th integer.  scheme   simple.
 elegant,  efficient implementations  described.
 ., ., .
balanced parentheses .   sequence  balanced parentheses  open parenthesis .   associated   mate . operations findclose  findopen.
  defined,  find  mate  respectively .
open  closed parenthesis.  sequences  .
represented  bitvectors,  . represents .  .
represents .,   adding  negligible redundancy .
 possible  support   defined operations .
constant  nearly-constant time ., .
. string dictionaries.
  section  describe  implementation  string.
dictionaries using path-decomposed tries.  string.
dictionary   data structure   string set  . .
 supports  following operations.
. lookup. returns .   .    unique.
identifier  ., . otherwise.
. access. retrieves  string  identifier . note.
 access.lookup. .    . .
path decomposition.  string dictionaries, inspired.
  approach described  .,  based  path.
decompositions   trie built   .recall  .
use trie  indicate compacted trie   rest  .
paper.  path decomposition     trie    tree.
  node    represents  path   .  .
defined recursively   following way.  root-to-leaf.
path    chosen  represented   root node.
  .   procedure  applied recursively  .
sub-tries hanging   chosen path,   obtained.
trees become  children   root. note  .
  procedure  order   decomposed subtries  children   root  arbitrary. unlike .,.
 arranges  sub-tries  lexicographic order, .
arrange   bottom-to-top left-to-right order since.
 simplifies  traversal. figure . shows  path  .
  resulting node   .
   one-to-one correspondence   paths.
root-to-node paths    correspond  root-to-leaf paths.
  trie  , hence  strings  .  implies also.
    exactly . nodes,   height   .
   larger     . different strategies.
 choosing  paths   decomposition give rise .
different properties.  describe two  strategies.
. leftmost path. always choose  leftmost child.
. heavy path. always choose  heavy child, . .
one whose sub-trie    leaves .arbitrarily.
breaking ties.    strategy adopted  .
 borrowed  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
 . . . . . .
 . . . . . .
 . . . . .
figure . path decomposition   trie.  . denote  labels   trie nodes,     branching characters.
.depending  whether     path  .
remark .   leftmost path  used   path.
decomposition,  depth-first order   nodes   .
 equal   depth-first order   corresponding.
leaves   . hence    lexicographically ordered, .
  .  call   lexicographic path decomposition.
remark .   heavy path  used   path.
decomposition,  height   resulting tree  bounded.
 .log .  call   decomposition  centroid.
path decomposition.
 two strategies enable  time.functionality tradeoff.  lexicographic path decomposition guarantees .
 indices returned   lookup  lexicographic, .
cost   potentially linear height   tree . never.
higher   trie.    hand,   order .
 indices  irrelevant,  centroid path decomposition.
gives logarithmic guarantees.
 exploit  crucial property  path decompositions.
since  node    corresponds   node-to-leaf.
path   ,  concatenation   labels   nodeto-leaf path corresponds   suffix   string  .
 simulate  traversal   using     need.
 scan sequentially character-by-character  label .
 node   find  needed child node. hence,.
 representation   labels  supports sequential.
access .simpler  random access.  sufficient. besides.
 cache-friendly,   will see   next section,.
 allows  efficient compression   labels.
. .  authors show    lexicographic indices  .
centroid path-decomposed trie, using secondary support structures.
 arranging  nodes   different order.  navigational.
operations  noticeably  complex,  require  powerful.
primitives   underlying succinct tree,  particular  access.
trie representation.  represent  pathdecomposed trie  three sequences .see figure .,.
containing  example   root node.
.  bitvector  encodes  trie topology using.
dfuds .  node  represented   run  .
 length  degree   node, followed   single.
.  node representations   concatenated.
 depth-first order.
.  array  contains  branching characters .
 node.   written  reverse order per.
node,   concatenated  depth-first order.
note   branching characters   one-to-one.
correspondence   .   .
.  sequence  contains  labels   node.
 recall   label represents  path .
 trie.  encode  path augmenting .
alphabet .  . . . special characters, . .
. . .,., . . . , . . ., alternating  label .
 branching char   node   path .
 number  sub-tries hanging   node,.
encoded   new special characters. .
concatenate  representations   labels .
depth-first order   sequence ,   .
label   correspondence   .   . note .
 labels  represented   larger alphabet. .
will show later   encode . also, since .
label representations  variable-sized,  encode.
 endpoints using  elias-fano sequence.
trie operations.  implement lookup  start .
 root  begin scanning  label.   character  .
special character,  add    accumulator, otherwise.
 check   mismatch   string   current.
. copyright . siam.
unauthorized reproduction   article  prohibited.
position.     mismatch,  accumulator.
indicates  range  children   root . thus.
 branching characters.  branch   point.
  path   original trie. hence   find .
right branching character . conclude   .
 none, .  string     set.   .
child   jump.   proceed recursively .
 string  fully traversed     extended.
.  index returned   value  rank.  .
final node   former case .  depth-first index.
  node.,  .   latter case. note   .
possible  avoid   rank calls needed  access .
   using  standard trick  double-counting,.
. exploiting  observation   two mates.
   equal number  .  .
access  performed similarly    bottomup fashion.  node position  obtained  .
index   select.,   path  reconstructed.
jumping   parent   node  reached. since.
 know   node  child  came , .
 scan  label   sum  special characters.
encountered exceeds  child index.  normal.
characters seen   scan  appended  .
string   returned.
time complexity.   lookup,   node .
 traversal  perform  sequential scan   labels.
  binary search   branching character.  .
pattern  length ,   never see   .
special characters   scan. hence   assume.
constant-time findclose  elias-fano retrieval .
total number  operations  .  log .,  .
number  random memory accesses  bounded  .,.
    height   path decomposition tree.
 access  symmetric except   binary search.
  needed   . ,   number  operations .
bounded  .     length   returned.
string. ,  number  random memory accesses.
 bounded  .
labels encoding  compression.  previously.
mentioned,  need   scan sequentially  label.
  node,    use  encoding  supports.
sequential scan   constant amount  work per.
character.   uncompressed trie,   baseline, .
simply use  vbyte encoding . since  bytes .
 datasets   exceed .   value,   .
noticeable space overhead.   less sparse alphabet,.
 sophisticated encodings   used.
 freedom  choosing  encoding allows  .
explore  trade-offs.  take advantage   .
compress  labels,   almost negligible overhead.
  operations.
 adopt  simple dictionary compression scheme .
 labels.  choose  static dictionary  variable-sized.
words .   drawn   alphabet.  will.
 stored along  tree explicitly,    overall.
size   dictionary  bounded   given parameter.
.constant.  node labels   parsed  words.
  dictionary,   words  sorted according.
  frequency   parsing.  code  assigned .
 word  decreasing order  frequency,   .
frequent words  smaller codes.  codes  .
encoded using  variable-length integer encoding. .
use vbyte  favor performance.  decompress  label,.
 scan  codes    code  scan  word .
 dictionary, hence  character requires  constant.
amount  work.
 remark   decompression algorithm .
completely agnostic    dictionary  chosen.
   strings  parsed.  example, domain.
knowledge   data   exploited.  texts,.
  frequent words  probably   good.
choice.
since   looking   general-purpose scheme,.
 used  modified version   approximate re-pair.
. described  .  initialize  dictionary .
 alphabet .  scan  string  find   .
frequent pairs  codes.   select   pairs.
whose corresponding substrings fit   dictionary.
 substitute    sequence.   iterate.
  dictionary  filled .    .
repeated pairs.    obtain simultaneously.
 dictionary   parsing.  allow  labels .
 accessed independently,  take care   pairs.
 formed  label boundaries,  done  .
note   principle  dictionary representation.
 less space-efficient  plain re-pair,   words.
 represented recursively  pairing rules. however.
accessing  single character   recursive rule  .
cost dependent   rule tree height,    fail.
 requirement  constant amount  work per decoded.
character.
implementation notes.    vector  use.
 range min tree described  section . rank.
 supported using  rank. structure described .
.,  select  implemented   one-level.
hinted binary search.  search   branching.
character  replaced   linear search,   .
cardinalities considered  actually faster  practice.
 dictionary  represented   concatenation .
 words encoded  .-bit characters  fit  larger.
alphabet . . ., .  dictionary size bound .
 chosen   .,    word endpoints .
 encoded  .-bit pointers.  small size  .
dictionary makes also  likely  . least  .
frequently accessed part .   kept  cache.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. monotone minimal perfect hash  strings.
minimal perfect hash functions map  set  strings .
bijectively  ., . monotone minimal perfect hash.
functions . . monotone hashes. also require .
 mapping preserves  lexicographic order  .
strings .   confused  generic order-preserving.
hashing.  remark ,   standard minimal hash.
functions,  lookup  return  number  strings.
outside  , hence  data structure    .
store  string set.
 hollow trie .   particular instance .
monotone hash.  consists   binary trie  , .
   trie topology   skips   internal.
nodes  stored,  succinct form.  compute  hash.
value   string ,  blind search  performed. .
trie  traversed matching   branching characters.
.bits,   case.  .   . ,  leaf reached.
  correct one,   unique identifier  ., .
 returned. otherwise,    longest prefix match.
 , useful   applications.
 cost  unbalancedness  hollow tries  even.
larger    normal tries. since  strings  .
   converted   binary alphabet,  height .
potentially multiplied  .log .  respect  .
  trie  .  experiments  . show indeed .
 data structure   practical compared  .
monotone hashes analyzed   paper.
path decomposition  lexicographic order. .
tackle  unbalancedness,  apply  centroid path.
decomposition idea  hollow tries.  construction.
presented  section .   used directly, .
 want   preserve  lexicographic ordering.
  strings  guarantee  logarithmic height.
however   binary alphabet   fact .
   need  access operation come   aid.
first, inspired   .,  arrange  sub-tries .
lexicographic order.  means   sub-tries  .
left   path  arranged top-to-bottom,  precede.
    right   arranged bottom-to-top.
  path decomposition tree  call left children .
ones corresponding  sub-tries hanging   left side.
  path  right children  ones corresponding .
 hanging   right side. figure . shows  new.
ordering.
 now need  small change   heavy path.
strategy. instead  breaking ties arbitrarily,  choose.
 left child.  call  strategy left-biased heavy path,.
 gives  following.
remark . every node-to-leaf left-biased heavy path.
  binary trie ends   left turn. hence, every.
internal node   resulting path decomposition  .
least one right child.
trie representation.  bitvector   defined .
 section .  label associated   node .
 sequence  skips interleaved  directions taken.
  centroid path, excluding  leaf skip,  .
figure . two aligned bitvectors lhigh  llow .
used  represent  labels using  encoding inspired.
 . codes.  skips  incremented  one . exclude.
.   domain.   binary representations.
.without  leading .  interleaved   path.
directions  concatenated  llow. lhigh consists .
runs  length corresponding   lengths   binary.
representations   skips, followed  .,   .
endpoints  .skip, direction. pair encodings  llow.
correspond   .  lhigh. thus  select directory.
 lhigh enables random access   .skip, direction.
pairs sequence.  labels   node  concatenated.
 depth-first order.  .     one-to-one.
correspondence   .skip, direction. pairs.
trie operations.   section .,  trie traversal .
simulated   path decomposition tree.   root.
node,  .skip, direction. pairs sequence  scanned.
. lhigh  llow.   scan  number.
 left  right children passed   kept.  .
mismatch   string  found,  search proceeds .
 corresponding child.    ordering  .
children,   mismatch leads   left child  child.
index   number  left children seen   scan,.
   leads   right child    node degrees.
minus  number  right children seen . .
latter  stored  right  left.  search proceeds.
recursively   string. characters  consumed.
  search ends,  depth-first order  .
node found   yet  number   looking .
  ancestors   turned left come  .
found node  depth-first     lexicographic.
order. besides,   found node    leaf,  .
strings   left sub-tries   corresponding path.
 lexicographically smaller   current string. .
 easy  fix  issues.   traversal  .
count  number  left turns  subtract  .
 final index.  account   left sub-tries, using.
remark .   count  number   leaves .
jumping   first right child   findclose. .
number  nodes skipped   jump  equal  .
number  leaves   left sub-tries   node.
time complexity.  running time   lookup.
  analyzed   similar argument   .
 lookup  section .   scan  .
  skips   pattern length. besides .
  binary search. hence  number  operations.
 .min., .,   number  random memory.
accesses  bounded  .
implementation notes.  support  select .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lhigh . .
llow . . . . . .
 . . . . .
figure . path decomposition   hollow trie.  . denote  skips.
lhigh  use  variant   darray . since .
.   sequence    . bits apart,  .
bound  size   blocks      need .
overflow vector .called   .
. balanced parentheses.  range min tree.
  section  describe  data structure supporting.
findclose  findopen.     restricted  tries,.
 believe    independent interest.
 begin  discussing  range min-max tree .,.
   succinct data structure  support operations.
 balanced parentheses  .log . time.   shown.
 .     efficient  practice. specifically,.
   data structure  ., .,. sequences .
supports  forward search fwdsearch., . given .
position    target value , return  first position.
 .     sum   values   sequence.
     equal  .  application .
balanced parentheses  straightforward.   sequence.
takes value .  open parentheses  .  closed.
parentheses, findclose. . fwdsearch., .  .
words,    first position  zero excess, defined.
  difference   number  open  close.
parentheses    given position. backwards search.
 defined similarly  findopen.
 data structure  defined  follows.  sequence.
 divided  blocks    size   tree .
formed   blocks, storing  minimum  .
 maximum    sequence cumulative sum .
excess,  balanced parentheses.   block   .
leaves,    sub-trees   nodes.  forward.
search traverses  tree  find  first block   .
  target value       . since.
 sequence  ., .,., block  contains  .
intermediate values     ,    must.
contain .  linear search   performed within .
block .usually  lookup tables.
 fit   data structure  support .
findopen  findclose, thus reducing   space.
requirement   time performance.  list  two.
modifications.
halving  tree space.  discard  maxima .
store   minima,  call  resulting tree range.
min tree.   block search,   check .
target value  greater   block minimum. .
following lemma guarantees   forward search .
correct.  symmetric argument holds   backwards.
search.
lemma .   balanced parentheses sequence, .
range min tree forward search   . . finds  .
block   range min-max tree.
proof. since  min search   relaxation   minmax search,  block . returned   search  .
min tree must precede  block  found  min-max.
search, . . . . suppose  contradiction  . . .
since  sequence  parentheses  balanced,  .
positions  two mates  excess greater  .
excess   opening parenthesis.  .  greater.
  excess   opening parenthesis,   .
target value. hence .   valid block   forward.
search   min-max tree,  since . .    .
contradiction.
broadword in-block search.  in-block search.
performance  crucial     inner loop   search.
 practical implementations   usually performed byteby-byte   lookup table  contains  solution.
  possible byte  excess.  involves many.
branches  accesses   fairly big lookup tables .
 byte. supposing instead   know  byte.
. copyright . siam.
unauthorized reproduction   article  prohibited.
contains  closing parenthesis,    use .
lookup table    byte.
 find  byte   use   trick  .
range min.  first byte  min-excess smaller .
 target excess contains  closing parenthesis. .
find    hybrid lookup table.broadword approach.
 divide  block  machine words.  .
word   compute  word .   i-th byte.
contains  min-excess   i-th byte   .
inverted sign,     non-negative.   achieved.
  pre-computed lookup table  contains .
min-excess   possible byte.    time .
compute  byte counts .  ,   i-th byte.
contains  number  .   i-th byte  , using.
 algorithm described  .
using  equality excess. . . . rank. .  .
 easily compute  excess   byte  .  .
  excess   starting position  ,  word .
whose i-th byte contains  excess   i-th byte  .
  obtained   following formula.
. . . . . . . . . . .
. . . . .
now     need.  closing parenthesis .
  byte   excess function crosses  zero,.
  words   byte whose excess added  .
min-excess  smaller  zero. hence   looking.
  first byte position   .  smaller  .
.recall   bytes  .  negated.   .
done using  . operation described  .  compute.
 mask . . . . .,   i-th byte  .  .
   i-th byte  .  smaller   i-th byte.
 .   .  zero,  word   contain .
closing parenthesis. otherwise,  lsb operation quickly.
returns  index   byte containing  solution.
  algorithm   applied symmetrically .
 findopen.
  ,  performed . lookups    small.
table,   arithmetic operations  one single branch.
. check whether  word contains  solution .
.   experiments,  approach described .
results  . . faster operations  tree-traversal.
benchmarks,  respect  byte-by-byte search. .
similar improvement occurs   trie implementations.
. subtlety  needed    correct search.  excess .
 negative, hence  carry   subtraction corrupts  bytes.
  first byte  contains  zero. however,  means.
  word contains  solution,   closing parenthesis .
  byte  precedes  one   sampled excess goes.
negative.
. experimental analysis.
  section  discuss  series  experiments .
performed   real-world  synthetic data. .
performed several tests   collect statistics .
show   path decompositions give  algorithmic.
advantage  standard tries,   benchmark .
implementations comparing    practical.
data structures.
setting.  experiments  run   .-bit .ghz.
core . processor  . . cache  . ram,.
running windows server . .   . code.
 compiled  msvc .,   java  used .
sun jvm .
datasets.  tests  run   following datasets.
. enwiki-titles .mib, . strings.  .
page titles  english wikipedia.
. aol-queries .mib, . strings. .
queries   aol . query log .
. uk-. .gib, . strings.  urls  .
. crawl   . domain .
. webbase-. .gib, . strings. .
urls   stanford webbase  .
. synthetic .gib, . strings.  set .
strings dicjbt. . . . .     range .
., .,  ranges  ., ., .   distinct .
equal   string.   . .  resulting.
tries   unbalanced,   constant suffix.
. . . . . stresses  in-bucket search  bucketed.
front coding   redundancy   exploited.
 front coding  non-compressed tries.  .
 time,  strings  extremely compressible.
average height. table . compares  average height.
 plain tries   path decomposition trees.  .
 real-world datasets  centroid path decomposition.
cause  . . times reduction  height compared .
 standard compacted trie.  gap  even .
dramatic  hollow tries,   binarization  .
strings causes  blow-up  height close  log ., .
 centroid path-decomposed tree height   small,.
actually much smaller  log .   interesting .
note  even   lexicographic path decomposition.
 unbalanced,  still improves   trie, due  .
higher fan-out   internal nodes.
 synthetic dataset   pathological case  tries,.
  centroid path-decomposition still maintains .
extremely low average height.
string dictionary data structures.  compared  performance   implementations  pathdecomposed tries   data structures. centroid.
. copyright . siam.
unauthorized reproduction   article  prohibited.
enwiki-titles aol-queries uk-. webbase-. synthetic.
compacted trie avg. height . . . . .
lex. avg. height . . . . .
centroid avg. height . . . . .
hollow avg. height . . . . .
centroid hollow avg. height . . . . .
table . average height.  tries  average height   leaves  considered,   path-decomposed tries  .
nodes  considered .see  comments  remark .
 centroid compr. implement  centroid pathdecomposed trie described  section .,   versions.
without   labels compression. likewise, lex. .
lex. compr. implement  lexicographic version.
re-pair  htfc  respectively  re-pair.
 hu-tucker compressed front coding  . .
htfc  chose bucket size .   best space.time.
trade-off. comparison  front coding   particular.
interest    one   data structures generally.
preferred   practitioners.
   popular open-source straightforward implementation   .non-compacted. trie  uses louds.
.  represent  tree.  code   downloaded.
 .  made  slight changes  avoid keeping.
  string set  memory   construction.
 measure  running times,  chose . million.
random . randomly shu. strings  .
dataset   lookup  . million random indices.
  access.  test  averaged  . runs. .
construction time  averaged  . runs.
re-pair, htfc     support files bigger  .gib,     run  tests .
webbase-. also re-pair   complete .
construction  synthetic  . hours,    .
kill  process.
string dictionaries results.  results   tests.
  seen  table .   datasets  compressed.
tries obtain  smaller space, except  uk-. .
 come  close second.  centroid versions .
also  fastest lookup times,   access time .
better  re-pair  occasionally htfc, whose time .
although within .     centroid trie.  .
consistently  largest  slowest    datasets.
maybe surprisingly,  lexicographic trie  .
much slower   centroid trie   lookup .
access. however   synthetic dataset  unbalanced.
tries    . times slower   balanced.
ones. htfc exhibits  less dramatic slowdown  still.
  order  .  lookup compared   centroid.
trie. although  behavior   occur  .
real-world datasets,  shows   assumptions  .
made  unbalanced tries.  example   adversarial.
environment  attacker  exploit  weakness .
perform  denial  service attack.
 remark   labels compression adds .
almost negligible overhead   lookup  access,.
due   extremely simple dictionary scheme, .
obtaining   good compression. hence unless .
construction time   concern .  case .
dictionary selection strategies  also  explored.  .
always convenient  compress  labels.
monotone hash data structures.  monotone.
hashes,  compared  data structures  .
implementations  . centroid hollow implements.
 centroid path-decomposed hollow trie described .
section . hollow   reimplementation   hollow.
trie  .  using  range min tree  place   pioneerbased representation. hollow .sux.  paco .sux. .
two implementations  .  first   hollow trie,.
 second  hybrid scheme.  partially compacted.
trie  used  partition  keys  buckets,  .
bucket  hashed   mwhc function. among .
structures  ., paco gives  best trade-off .
space  lookup time.  implementations  freely.
available  part   sux project .
 measure construction time  lookup time .
adopted   strategy   string dictionaries. .
sux,  suggested  .,  performed . runs  lookups.
 measuring  lookup time,    jit warm.
  optimize  generated code.
monotone hash results. table . shows  results.
 monotone hashes.   real-world datasets .
centroid hollow trie  . . times faster  .
implementation   hollow trie  . . times faster.
.  fair  need  say  sux  implemented  java.
  structures  implemented  . however, .
recent developments   java virtual machine  made .
abstraction penalty gap smaller  smaller. low-level optimized.
java .  one  sux.    par  .   tasks,.
  slower  .  respect  .    tasks.
.  remark   hollow trie construction  actually faster.
  sux version   , although  algorithm  .
similar.
. copyright . siam.
unauthorized reproduction   article  prohibited.
enwiki-titles aol-queries uk-. webbase-. synthetic.
. bps . bps . bps . bps . bps.
string dictionaries.
ctps .ratio lkp acs ctps .ratio lkp acs ctps .ratio lkp acs ctps .ratio lkp acs ctps .ratio lkp acs.
centroid compr. . . . . . . . . . . . . . . . . . . . .
lex. compr. . . . . . . . . . . . . . . . . . . . .
centroid . . . . . . . . . . . . . . . . . . . .
lex. . . . . . . . . . . . . . . . . . . . .
re-pair . . . . . . . . . . . . .        htfc . . . . . . . . . . . . .     . . . .
 . . . . . . . . . . . . .     . . . .
monotone hashes.
ctps bps lkp ctps bps lkp ctps bps lkp ctps bps lkp ctps bps lkp.
centroid hollow . . . . . . . . . . . . . . .
hollow . . . . . . . . . . . . . . .
hollow .sux . . . . . . . . . . . . . . . .
paco .sux . . . . . . . . . . . . . . . .
table . experimental results. bps  bits per string, ctps   average construction time per string, .ratio  .
compression ratio   data structure   original file sizes, lkp   average lookup time  acs  average.
access time.  times  expressed  microseconds.
  sux implementation.  centroid hollow trie .
competitive  </doc>
<doc title='019.txt'>
solving  minimum string cover problem.
stefan canzar. tobias marschall. sven rahmann. chris schwiegelshohn.
december ., .
abstract.
 string cover    set  strings    set  substrings.
    every string     written  .
concatenation   strings  . given costs assigned.
  substring  ,  minimum string cover.
.msc. problem asks   cover  minimum total cost.
 np-hard problem   far   approached.
  purely theoretical perspective.  previous integer linear programming .ilp. formulation  designed.
  special case,    string   must .
generated   .small. constant number  substrings.
  restriction  removed,  ilp   exponential number  variables,    show  pricing.
problem   np-hard.  propose  alternative flowbased ilp formulation  polynomial size, whose structure  particularly favorable   lagrangian relaxation.
approach.  making use   strong bounds obtained   repeated shortest path computation .
 branch-and-bound manner,  show   first time.
 non-trivial msc instances   solved  provable optimality  reasonable time.  also provide .
solve real-world instances derived   classic text.
.alice  wonderland.  almost  instances, .
lagrangian relaxation approach outperforms  cplexbased implementation   order  magnitude. .
software  available   terms   gnu general.
public license.
. introduction.
    set  strings.  call  set  substrings.
  strings    cover    concatenations .
 substrings generate  original strings.  .
unweighted minimum string cover .msc. problem, .
want  find  cover  minimal cardinality.   .
.supported  dfg sfb . .providing information .
resource-constrained data analysis.
.centrum wiskunde . informatica .cwi., science park .,.
.  amsterdam, netherlands.
.genome informatics, faculty  medicine, university .
duisburg-essen,  bioinformatics, computer science ,.
 dortmund, germany.
.algorithms  complexity theory, computer science ,.
 dortmund, germany.
general version,  assign  cost   substring .
aim   cover  minimal total cost.
 paper  organized  follows. first,  briefly.
review  history   problem  define  problem formally.  ,  discuss  existing integer linear programming .ilp. formulation  hermelin.
 . .  exponential size .section .  present.
 new polynomial-size flow-based formulation  section . additionally,  section .,  show   certain lagrangian relaxation   formulation leads  .
shortest path problem   directed acyclic graph associated   strings   problem instance. .
properties result   first practical method  solve.
non-trivial msc instances.  describe  implementation .section .  evaluate   benchmark instances .section .  brief discussion concludes .
paper .section .
. previous work. bodlaender  . . used .
name dictionary generation  msc,   computer linguistics,    common task  find words,.
stems, suffixes  affixes,  syllables  text corpora  unknown structure,  msc thus might.
complement language-specific stemming algorithms .
discovering  building blocks .semi-.automatically.
bodlaender  . . also suggested  msc might .
applicable  discover protein domains  collections.
 protein sequences. furthermore, msc may  relevant  data storage   msc optimization yields .
compact representation   string set . despite .
potential applications,  none   areas mentioned.
, real problems  solved  msc algorithms.
 might  due   lack  efficient  practical algorithms  msc,  previous work  mostly.
addressed theoretical aspects  msc.
np-completeness   unweighted msc problem.
 determined  .  .raud .,  showed .
  co-np-complete  decide whether  given set .
strings  elementary.  set  strings   elementary .
 exists  set  strings   . . . .,  .
 strings     written  concatenations  .
strings   .  example, .abc,bca.  elementary,.
 .abc,bca,.     strings  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
written  concatenations  strings   smaller set.
.,.
hermelin  . . generalized  unweighted msc.
problem  assigning costs   substring  showed.
 approximating  solution within factors  . .
 bmaxs. . . . . .,    . .   .
. . .,  np-hard.  addition,  authors presented .
ilp formulation .see section .  two approximation.
algorithms based  dynamic programming  .
rounding, respectively.
 ilp formulation appears  never  .
implemented,     aware   .
algorithm  ever  used  solve real instances.
either.  summary,  practical exact method exists.
yet  solve non-trivial msc instances.  purpose.
  article   provide   method  .
make  tool available  researchers working  .
aforementioned domains.
. notation  problem definition. given .
finite alphabet .   string  . .,  length  .
 denoted  .   characters  indexed starting.
 zero, .  . . . . . . . .
substrings  written . . . . . . . . . . . .
set   .distinct. substrings   excluding  empty.
string  denoted   .  string  contain  .
substring   . therefore,  distinguish.
 substrings  intervals   string. .
substring  .  .   string  ., intervals .
denoted  tuples ., , . referring   range  .
   .  set   intervals    written . .
write .  denote  set   intervals  spell .
 , formally . . ., , . . . . . . . . . . .
 factorization     sequence  intervals  ,.
., ., ., . . . , .,  , .    . .  . . .
 .    . ., . . . ,. . . .    . ., . . . ,.
  . . . .,    concatenation  .
substrings spelled   intervals  .  set .
 factorizations    denoted   . note .
. . . .  exponentially large   string.
length.   given  .  .,  slightly abuse notation.
 define  .    set   substrings   spelled.
  intervals   . furthermore, . . . .  . .
 .  . denotes  set   factorizations containing.
 substring  .  .  least .
throughout  paper,  denotes  finite set .
strings.  definitions   ,    naturally extend.
 sets  strings   . .
.
.  ., etc.
 set  strings  .  .   cover   , .
every  . ,  exists  factorization  .  . .
  . . .
problem . .minimum string cover.   given.
finite alphabet .,  finite string set  . .,  .
cost function  .  . . . ,  minimum string.
cover problem consists  finding  cover   .
   total cost . .
.
. .  minimal.
among  covers  .  tuple .,.  called .
instance   minimum string cover problem, .
underlying alphabet .  derived  .   . .,.
 problem  called  unit cost .also unweighted.
minimum string cover problem.
.  initial ilp formulation.
 briefly restate  ilp formulation introduced .
hermelin  . .  every substring  .  . .
use  binary variable  indicating whether substring .
 contained   sought string cover .  every.
string  .   every factorization  .  .,  binary.
variable , indicates whether   used  factorize .
using  variables,  minimum string cover.
problem    cast   following ilp scfact.
min.
.
. .
. ,.scfact.
.
.
.
, .  .  . ,  .  .,.
.
. .
, . . .  . ,.
, , . ., . .  .  .,.
 . ,  .  .
 first set  constraints . ensures   factorization   used  cover  input string    .
substrings  contained   solution cover . constraints . require   strings  covered  .
least one factorization.
ilps  solved  commercial solvers   repeated.
solution   linear programming . relaxation .
variants   problem. therefore, besides  strength.
  obtained bound,  ability  solve   relaxation efficiently plays  key role   practical performance   ilp-based approach.  scfact, however,.
 number  factorizations  thus  number .
y-variables grows exponentially   length  .
strings. previous work, including ., therefore focused.
  .-cover problem,  variant    string.
must  produced   concatenation    . substrings,  .  assumed   constant. thus, .
number  factorizations   longer exponential  .
string length,  solving  ilp becomes feasible .
reasonably small .   general minimum string.
cover problem  consider , solving  ilp directly  infeasible. alternatively, one  study .
pricing problem,  equivalently,  separation problem   exponentially large class  constraints .
. copyright . siam.
unauthorized reproduction   article  prohibited.
 dual    relaxation.   separation problem   solved  polynomial time,   optimal.
solution    relaxation  still  found  polynomial time .   case, practically efficient algorithms  solving   relaxation based  delayed.
column generation, respectively cutting planes, might.
exist. however,  show next   efficient algorithm  solving  separation problem   dual .
  relaxation  scfact,   constraints .
 replaced  constraints , , . .,  unlikely .
exist.   equivalence  separation  optimization .  conclude     polynomial time.
algorithm  solve   relaxation, unless .
theorem .  separation problem   dual .
scfact  np-hard.
proof. consider  dual    relaxation  scfact,.
taking  account  every optimal solution  .
primal problem satisfies , , . .,.
max.
.
.
,.dscfact.
.
.
. .
, .  . . , . .  .,.
, . . . . , .  .  .,.
, , . . . . , .  .  .
 details    obtain  dual   linear.
program,  refer  textbooks   . .
separation problem consists  deciding whether  given.
vector ., .  feasible  dscfact ,  ,  find .
violated constraint.  constraints .  . .
  trivial task.  constraints .    decide.
 every string , whether minf. .
.
. . , .
. computing  left hand side   inequality .
equivalent  solving  minimum string cover instance.
     input string  costs given .
. . ,. note  constraints .   pose.
 restriction   minimum string cover instance,.
since  costs .  always  scaled accordingly.
 claim now follows   following lemma.
lemma . minimum string cover  . . . .
np-hard.
proof. given  instance  . .,.   unweighted.
minimum string cover problem, .  . ., .
 . ., ., . . . , .   . .,  construct .
equivalent instance  . . ., .  . . .  follows.
 concatenate  strings     single string  .,.
separated   character .,   assume   .
present  . thus . . . . . . .  define .
cost function .  . . .   .  ., . . .
  .  . . . . . .,  . . . clearly,.
 set  .  . .   feasible solution  instance.
 .  thus  provides  upper bound   cost .
 optimal solution . therefore,  every substring.
 . .  holds  . . .  . . . .  thus .
  feasible solution     cost.   reverse.
direction,   derive   optimal solution .
   feasible solution  .   .   cost  simply.
setting  . . . . .
.  polynomial-size ilp formulation.
 propose  polynomial size ilp formulation  .
minimum string cover problem.  idea   model.
factorizations   string  paths   substring graph.
  string,   define   following.  essence,.
 directed edges correspond  substring intervals, .
 nodes  positions  characters. formally, .
 string   length , .
 . ., ., ., ., . . . , ., .,.
 . ., . ., . .  . , ., . . , ., . . .
 directed edge ., . . ., . represents  substring interval ., , ., spelling  substring  length.
.  now ,  identify  interval ., , . .
 edge ., . .,  . .
 factorization    now equivalent   path .
 substring graph  . ., ., starting  ., . .
ending  ., .  write .  .   sets.
 incoming  outgoing edges   . , respectively.
 ilp formulation scflow uses  binary variable.
,,  every edge, . interval ., , . . ., .
models  path   source ., .   sink ., .
  unit flow.   . .  . ., ., ., .
min.
.
. .
. , .scflow.
,, . . . ., , . . .,.
.
.,,.,.
,, . . .  . ,.
.
.
.,,.
,, .
.
.,,.
,, .  . ,  .  . ,.
, ,, . ., . .  .  .,.
., , . . .
note  constraints .  . together imply.
  unit flow arrives   sink ., .  also.
call .  .flow balance constraints.  solve.
scflow using  lagrangian relaxation approach,  described   next section.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. lagrangian relaxation.
 ilp formulation derived   previous section.
exhibits  structure   favorable   lagrangian.
relaxation approach.  general idea  lagrangian.
relaxation   relax  .complicating. constraints .
penalize  violation   objective function, .
  .easy-to-solve. subproblem remains.  .
case, solutions satisfying constraints . encode.
 unit flow  thus  path  node ., .  node.
., .   substring graph  every string  . .
 link   paths   chosen substrings.
 established  constraints . therefore, .
relaxing  .linking constraints.   penalizing.
 violation  non-negative multipliers .  .
objective function,  optimal solution   resulting.
problem   obtained  computing shortest paths.
  substring graphs independently   string.
min.
.
. .
. .
.
.,,.
.,,.,, . .,.
.
 .
.,,.,.
,, . . .  . ,.
.
.,,.
,, .
.
.,,.
,, .  . ,  .  . ,.
, ,, . ., . .  .  .,.
., , . . .
 denote  problem  finding  optimal solution   lagrangian relaxation  given lagrangian.
multipliers .,, . .  .,   optimal cost .
.
 shortest paths  computed  respect .
weights .,, assigned   z-variables   objective.
function.  set ,, . .   edge  node ., .
 node .,  . . lies   shortest path  ., .
 ., .   substring graph    ,, . .
otherwise.
since  x-variables    constrained .
.,  simply set  . .   associated coefficient.
  objective function  non-positive,   . .
otherwise.
.  .
.
.  .,,. .,, . .,.
. otherwise.
 .,, . .   ., , . . .,   terms.
  second sum  objective function . .
 non-positive   solution  also feasible  .
original problem formulation scflow   particular .
 satisfies constraints . since every solution feasible.
  original problem formulation scflow  also.
feasible   lagrangian relaxation ., .
provides  lower bound   optimal cost  problem.
scflow. naturally,   interested  strong bounds.
  optimal cost  order   able  prune large.
parts   solution space  implicit enumeration.
performed  branch-and-bound approaches. hence .
want  determine multipliers .,,. . .   .
cost   optimal solution   lagrangian relaxation.
  large  possible.  problem  referred   .
lagrangian dual problem.
. . . argmax.
.
.
since  lagrangian function . . .   concave function  .   differentiable  points .
 optimal solution  .   unique,  commonly used approach .  determine near-optimal multipliers efficiently  based   vector  subgradients.
associated   given .  subgradient   point.
.  given   vector  slacks   dualized constraints . given  optimal solution  . .
iterative approach proposed  held  karp . generates  sequence  lagrangian multipliers ., ., . . .
 taking  iteration .  step   direction opposite   subgradient  ., projecting  resulting.
point onto  non-negative orthant.  refer  . .
details   approach.
. implementation.
using  subgradient optimization approach described.
  previous section, convergence towards  optimal.
lagrangian multipliers   slow  practice. therefore,  opt  near-optimal multipliers  employ .
resulting lower bounds   branch-and-bound .
framework  efficiently find  global optimum. generally,  proceed  described  .   remainder.
  section,  provide  algorithmic details needed.
 reproduce  results.
 node   . tree represents  set  substrings.
 must  included   solution   set  substrings   forbidden. furthermore,  contains .
current lagrangian multipliers. branching   specific.
substring means cloning  current node  two child.
nodes  including  given substring  one  forbidding    . included substrings   taken.
 account  solving  lagrangian dual problem.
 forcing  . .  every included substring , .
setting  multipliers   corresponding intervals .
zero.  respect forbidden substrings,  respective.
edges   substring graphs  deleted.
  nodes  substring graphs  ordered .
. copyright . siam.
unauthorized reproduction   article  prohibited.
construction,  know  topological sorting  .
solve  shortest path problem  every  .  .
straightforward dynamic programming.  sum .
lengths   shortest paths    .  yields .
lower bound  explained  section .  selecting .
substring  part   shortest path   source.
node   sink node,  obtain  feasible solution.
 therefore  upper bound   optimal cost. .
 iteration,  check whether  feasible solution.
improves  best one known  far ,  , store .
finally,  need  address  questions  node.
 variable selection.  ,    decide .
 string  branch   given branching node .
  order  process  nodes   . tree.
 choose  substring  branch ,  consider .
multipliers associated   edges   shortest.
path computed   given branching node.  .
substring  .  .,  sum  multipliers  .
selected edges  divide   total sum  multipliers.
  edges associated   substring,  , .
compute  quantity.
 .
.
.,,. .,, . ,,.
.,,. .,,.
.
intuitively,  ratio    measure  whether .
substring    included   final solution.
 .   branch   substring  .
 ratio  closest  . meaning    .
uncertain. whether  include   .  keep .
branching nodes    yet  considered .
 priority queue  process  following  best-node.
first strategy  aims  minimize  total number.
 nodes evaluated   tree . according  .
strategy, always  node   lowest lower bound,.
.  node  potentially permits  best solution,.
 chosen.
 performance   subgradient optimization.
 strongly  influenced   choice   initial.
multipliers.  set  .
.,, .
. . . . .
. .
 initial multipliers   special property .
 coefficients   variables   objective function.
. become zero. therefore,  lower bound  solely.
determined   sum  lengths   shortest paths.
  edges belonging   substring  chosen, .
 complete weight   substring contributes  .
lower bound. furthermore,  multipliers encourage.
 use  substrings  occur frequently . .
low weight. , intuitively,  beneficial  obtaining.
 good initial feasible solution.
  subgradient optimization approach,  size.
  step taken   direction opposite   subgradient .see section .  controlled   parameter . concerning  adaption,  approach slightly differs .
 classical held-karp method .   branching.
node, .  initially set  .  halved  five iterations    lower bound    improved.
  . iteration    gap  lower .
upper bound    reduced   least . . .
. reaches .  lower  upper bound meet, .
branch.   branching tree. root node,  invest.
 effort  computing strong bounds.  decrease.
.  . non-improving iterations  . iterations .
reducing  gap   least . .  iterate  .
reaches .
. evaluation.
despite  theoretical considerations  sections .  .,.
 experiments  show  approach works best.
 practice.  now, however,  practical approach.
 solve minimum string cover existed  hence .
benchmark data sets  publicly available. therefore,.
 generate benchmark data sets  random sampling.
 using  sentences   novel.
 purpose  section .   provide guidance.
   kind  problem instances . terms .
alphabet size, input size, solution size, etc.  .
solved  provable optimality  reasonable time  .
implementation,   compare  performance .
 commercial general-purpose ilp solver cplex .
 lagrangian-based . approach.  contrast, .
purpose  section .   attempt  model  realworld problem .word boundary detection   english.
text.  msc, using  appropriate cost function.
 software   implemented  . .
 compiled using gnu gcc version .   available   terms   gnu general public license  http.string-cover.googlecode.com. .
solve  ilp introduced  section . directly,  commercial general-purpose ilp solver cplex . .http.
.www.cplex.com.  concert technology  .
used. time measurements  taken   compute.
cluster whose nodes  equipped  two intel quadcore processors  clock-rates  . ghz .
. ghz  .   ram, running . bit linux.
. random instances.  order  compare .
approaches   controlled setting   provide .
overview  runtimes   expected  facing .
string cover problem  practice,  randomly generated.
 total  . . instances divided  . groups .
instances .  every group,  instances .
sampled using different parameters  detailed .
. copyright . siam.
unauthorized reproduction   article  prohibited.
 used three different alphabet sizes  ., ., .
.,  first two  inspired   dna  amino.
acid alphabets, respectively.  obtain instances .
non-trivial solutions,    use completely random.
texts  sampled  solution set first  subsequently.
generated problem instances  randomly concatenating strings   solution set. sampling  solution.
set  controlled  two parameters,  range  .
set size   range   string length. within .
given ranges,  set size   length   solution string  sampled uniformly.  characters .
 solution string  drawn independently  uniformly.   solution set constructed   way,.
 prespecified number  strings  constructed .
concatenating randomly drawn strings   solution set.  length   string  determined .
sampling  lower bound   length   interval.
given  parameter.  long   lower bound  .
reached, another string  drawn   solution set.
 appended.  used parameter values  summarized  table .  groups  parameters  obtained.
 considering  combinations excluding  .
 number  strings   solution set   larger.
  number  generated strings.
 instances  alphabet size four  twenty,.
 introduced  additional constraint restricting .
minimum length   string   solution  three .
two, respectively.  allows avoiding trivial solutions.
containing just  input alphabet.   benchmark,.
 considered   unit weight case  choosing  appropriate weight function greatly depends .
 specific application.  section .,   consider one specific example   problem instance .
 application-tailored weight function.  instances.
 .attempted  . solved  cplex  .
lagrangian relaxation approach within  time limit .
.  using   .   memory.  either .
time   memory limit  exceeded,  computation  aborted. cplex  able  solve . .
table . overview  .alternative. parameters used .
 generation  random instances.
general parameters.
alphabet size. ., ., .
parameters controlling solution.
solution size. ., .
solution string lengths. ., .
parameters controlling instance strings.
number  strings. ., .
string lengths. ., .
instances . .   lagrange implementation.
successfully solved . . instances . .  .
instances successfully solved, minimum, median, .
maximum runtimes  shown  table .   group.
 instances.     groups,  approach outperforms cplex  terms  minimum, median, .
maximum runtime, often  orders  magnitude.
. alice  wonderland.  investigate  .
extent msc might  useful  recognize building.
blocks .  words.  natural language texts. .
english texts,  unit cost msc problem will usually.
yield  alphabet   optimal solution. therefore,.
choosing  reasonable cost function  essential.
  report results   instance derived .
alice  wonderland  lewis carroll  follows. .
text  obtained  http.www.gutenberg.org.
files.txt   header removed. double.
dashes .  potential sentence separators .
 replaced  full stops, simple dashes  newlines.
 spaces.  text  split  sentences  .
resulting full stops.  letters  converted .
lower case.  principle, instances  alphabet size.
.  now  obtained  considering  sentence.
.without  full stop.  one string  removing .
spaces  words   sentence.  goal  .
recover  word boundaries   solution   msc.
problem.
however,  generate non-trivial  still solvable.
instances,  adjustments  necessary. allowing.
words  size .  . leads  trivial solutions, .
 prescribed  minimum word length  . ., .
  kept sentences   least . words .
total length  least .  also ensured  .
word  occurs   occurs  least twice. .
aimed  instances   . ., ., ., ., ., .
sentences,  maximally many sentences. due .
  restrictions,  desired values   .
 always  obtained exactly,   next obtainable.
larger value  taken. costs  computed .
every occurring substring  length    .
.shorter  longer strings  excluded  assigning.
infinite costs.  follows.  estimated markovian.
text models  orders . . model.  .  .
instance  counting  frequency  single letters .
.-grams, respectively.  p-value   string   .
observed occurrences  defined   probability .
 occurs  least  times   set    size .
 given one, chosen according   random text.
model.  conditional p-value   corresponding.
conditional probability, given   string occurs .
least .  score     natural logarithm .
 conditional p-value. intuitively,  measures .
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . performance comparison  cplex   lagrange-based optimization.  ,  minimal,.
median,  maximal runtime  reported along   number  instances aborted due  memory . .
time . constraints .column .abrt.
solution solution string runtime cplex . runtime lagrange .
size str. len. lengths abrt. . min . median . max abrt. . min . median . max.
instances  . strings.
alphabet size .
</doc>
<doc title='020.txt'>
computing  consensus  multilabeled trees.
katharina . huber. vincent moulton. andreas spillner. sabine storandt.
rados law suchecki.
abstract.
  paper  consider two challenging problems.
 arise   context  computing  consensus .
 collection  multilabeled trees, namely . selecting .
compatible collection  clusters   multiset  .
ordered list   clusters  . optimally refining.
high degree vertices   multilabeled tree. forming.
  consensus  part   approach  reconstruct.
 evolutionary history   set  species  .
events   genome duplication  hybridization.
 occurred   past.  present exact algorithms.
 solving .  .    exponential runtime   worst case.  give  impression  .
performance  practice,  apply   simulated.
input    real biological data set highlighting .
impact  several structural properties   input .
 performance.
. introduction.
  paper  develop exact algorithms  two nphard problems involving so-called multilabeled trees .
mul-trees,  short.   rooted trees  whose.
leaves  labeled   elements   finite set .
  element  .  may label   one.
leaf   . since  problems admit polynomial time.
algorithms  case every label  allowed  occur .
 ,  identify parameters  seem  capture.
quite well  hard    deal   particular input.
 focus   two particular problems  arise .
biology   context   approach  reconstruct.
 evolutionary history   set   species  .
events   genome duplication  hybridization.
 occurred .see . ., .  parameters .
 structural properties  mul-trees employed  .
.university  east anglia, school  computing sciences,.
norwich, . ., . katharina.huber.cmp.uea., vincent.moulton.cmp.uea., .suchecki.uea.
.universita. greifswald, institut . mathematik und informatik, . greifswald, germany. andreas.spillner.unigreifswald.
.universita. stuttgart, institut . formale methoden der.
informatik, . stuttgart, germany. sabine.storandt.fmi.unistuttgart.
new algorithms also appear    promise .
tackling  problems involving  trees.
 reconstruct  evolutionary history   set.
  species, one  first reconstruct  collection .
 mul-trees,  describing  evolutionary history.
  single gene sequenced   species   .
 form  consensus   trees   . .
consensus will    mul-tree   .
 turned   network describing  evolutionary.
history  explicitly. note   trees  .
 multilabeled since, due  genome duplication .
hybridization events   past, several copies  .
 gene might  present   genome   species.
      copies might  evolved along.
different evolutionary paths.
 method  computing  consensus   presented  . works  first breaking  trees   .
subsets   multiset, so-called clusters.  clusters.
 ranked   ordered list  according   often.
 particular cluster occurs   trees  . , .
form  consensus mul-tree,  following two problems.
need   solved.
. given  ordered list   clusters   multiset,.
select  suitable subcollection   clusters  .
compatible,  ,   represented   single.
mul-tree.
. compute  mul-tree  induces  supercollection   clusters    minimizes .
number  genome duplication  hybridization.
events needed  explain  tree.
note ,  view   fact     np-hard.
problem  decide whether  given unordered collection.
 clusters   multiset  compatible .,  follows.
 .  np-hard , using  similar reduction.
 employed  ., one  show  . also leads.
  np-hard subproblem.  mentioned , .
present exact algorithms  solving .  . .
demonstrate, using simulated inputs   biological.
data set ,   help   algorithms, .
approach presented  .  feasible  computing.
 consensus  collections  mul-trees  .
several hundred leaves.
. copyright . siam.
unauthorized reproduction   article  prohibited.
related work includes algorithms  comparing.
mul-trees .,  computing mul-trees  optimally.
represent collections  so-called triplets .,   optimally pruning mul-trees  obtain  usual phylogenetic tree .,  ,  rooted tree    leaves.
  one-to-one correspondence   underlying.
set .
. preliminaries.
. basic definitions  view  multiset   .
map  .  . .   finite set   call.
.  multiplicity   . .  set   called .
underlying set    denoted   .  will also.
write  .    .  holds ,  describe specific.
multisets,  will just list  elements  .
multiplicities, . ., , , , , , .  addition,  .
multiset  ,  define  size . . ., .
thin part . . . .  . . . .,   deviation.
. .
.
. . .     underlying.
set .  multiset  .   . .   . .
   .  .  called  submultiset     use.
 . .   denote  fact. non-empty submultisets.
   also referred   clusters   .  cluster.
 trivial    size .  union  .  .  two.
multisets    .    underlying set .
contains every  .   multiplicity . .  .
similarly,  difference  . . contains every  . .
 multiplicity max.,. .
 mul-tree  . ., .   multiset  consists.
 .  rooted tree  . .,, .  root .  .
every vertex  either none   least two children,.
 .  labeling map . . . . .    set.
. .  leaves   onto   ,  every  . ,.
. . . . . . . . . . holds . figure .
 say    binary  every non-leaf vertex  .
 precisely . children. two mul-trees . . ., .
 . . ., .  isomorphic   exists  graph.
isomorphism .  .  .   . . .
holds    . . ,  addition,  root  .
 mapped   root  .
 every vertex    mul-tree  onm ,  denote.
   rooted subtree   consisting   vertices.
      path    . contains . .
cluster  induced     submultiset   formed.
  labels   leaves   . figure .
 addition,  . . denote  collection  clusters.
induced   vertices    multiplicities taken.
 account,  , . .  also considered  .
multiset. note ,  every  .  , . . contains.
 trivial cluster .  multiplicity .  .
following  will mostly consider collections  clusters.
   property   will say   collection.
  clusters   multiset   compatible   exists.
. .
      .
.
.
   .
.
.
    .
.
.
.
    .
.
.
.
      .
figure . .  mul-tree   ., , , , , , . .
 subtree .  cluster induced     .
., , , .   multiplicity  cluster ., .  .
. well   . .  . .  phylogenetic network .
 ., , , , .  ret. . . . .  network .
resulting  processing vertex  .    network.
. .   . .  refinement   mul-tree.
 .
 mul-tree      . . . otherwise  say.
   incompatible.
 phylogenetic network  . .,.   set .
consists   directed acyclic graph  . .,. .parallel.
edges allowed.   labeling map . . .  .
 set .  leaves  ,  ,  vertices .
 outgoing edge, onto  . figure .  require.
   precisely one vertex .   incoming.
edges, called  root   . moreover, every vertex.
   either .  outgoing edge  precisely one.
incoming edge,  .  least two outgoing edges, .
.iii.  least two incoming edges. note   .
several  definitions  phylogenetic networks  .
literature, see . .  reticulation number  .
 defined  ret. . . .degin. . . .
degin. denotes  number  incoming edges  vertex.
. note   number   viewed   estimate.
  many genome duplication  hybridization events.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
        .
.
.
    .
figure .  example illustrating one step  .
algorithm  constructing  networkn . .   given.
mul-tree  . .  network .   vertices.
  suitable set  marked  empty circles. . .
resulting network .
 occurred   evolutionary history   set .
species  represented   . therefore,  described.
next,  use  reticulation number  score  given.
mul-tree.
  remainder   paper  will use  following constructions     phylogenetic network   mul-tree  vice versa. first note .
 every phylogenetic network    one  associate  canonical mul-tree  . .   multiset .
  .   follows.  ., ., . . . , .   topological ordering   vertices   .  construct .
sequence  phylogenetic networks .,., . . . ,. .
. .  . assume   already constructed . .
  . ., ., . . . , .      one incoming.
edge  put  . . otherwise  make degin.
copies   subgraph induced   set  vertices .
.    reached   directed path  .
 attach one separate copy   incoming edge.
 , suppressing  resulting vertices   one.
incoming  one outgoing edge . figure . .
  hard  see , discarding  directions  .
edges, .  indeed  mul-tree   multiset .
  .      depend   chosen.
topological ordering.   case  will say  .
phylogenetic network  displays  mul-tree  . .
 .  polynomial time algorithm  presented .
  viewed  reversing  construction   . .
yielding,   mul-tree    multiset  , .
phylogenetic network  . .     .  . . .
   noted, however,   exist phylogenetic networks    .  . . .  algorithm.
 .  constructs  sequencen.,., . . . ,.  phylogenetic networks,  .   given mul-tree .
  edges directed away   root  .  .
resulting network  . .  .   shown , .
relatively mild assumptions,  . .   minimum.
reticulation number among  phylogenetic networks.
 display  .  mentioned ,  suggests using.
 number  score  .
 close  section  recalling  facts .
 construction    .,  . ., ., . . . , .,.
 will  used   description   algorithm.
 problem . later . first  set    least.
two vertices  .  selected   .  every.
vertex  .  ,  subnetwork  . formed  .
vertices    reached   along directed.
paths   contain  vertices   .
one incoming edge, implying   subnetwork .
actually  mul-tree , .  mul-trees ,  .  ,.
 pairwise isomorphic, .iii. every vertex   .
  isomorphic      .   contained.
  ,  .  size   cluster  induced .
 vertices  .   maximum among   satisfying.
.iii.  algorithm  replaces  collection .
trees ,  .  ,   single copy    tree .
 attached   vertex   . . incoming edges, .
representing one   original trees . figure .
. random mul-tree generator  used.
hardware.software  generate simulated input .
evaluating  algorithms,  used  following approach.  given values , .  ., random multrees  generated  follows. first  random binary.
rooted tree    leaves  generated according .
 yule-harding model ., .   random multiset   . . . , . . .  . . . .
generated ,   bijections    . .,.
one  selected uniformly  random  obtain  labeling.
map .  multiset   generated  first creating.
. elements,   multiplicity one,  constitute . , putting . .  . . ., additional.
elements ., ., . . . , .  generated   order, assigning ,  . ., ., . . . ,.
. . .,  random multiplicity.
.   selected uniformly  random   range.
 .  . finally,.
element .  assigned multiplicity .
. . note   values . ., . .
.   completely independent.  example,.
 . tends  . ., . tends  . therefore, .
 experiments  will usually mention . .  .
.  computational experiments presented  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
paper  performed   intel harpertown dual quad.
core system  scientific linux . operating system using .  main memory.
. brief description   overall approach.
 briefly recall  key facts   method described  .   given  collection   multrees,     multiset  .  mul-trees .
turned   list   clusters   sorted according .
 often  particular cluster  induced   trees .
 input collection.   take clusters  account.
  induced   least  certain percentage  .
mul-trees  .  percentage   chosen  .
user.   computational experiments  used .
   want  select  compatible collection.
 clusters  running  .   problem .
mentioned   introduction.  step    .
collection   compatible clusters already selected .
. ,   next cluster   ,  check whether.
 .   compatible.     case  add  .
  obtain . otherwise  put . . . .
resulting compatible collection  clusters  denoted .
.
next  search   suitable mul-tree   .
 . . . holds.   problem . mentioned  .
introduction. note      superpolynomial.
number   trees.  select  biologically meaningful.
candidate   trees,  score . .  associated.
  mul-tree  .  score  defined  .
minimum   reticulation number   networks.
 . .   .   binary mul-tree  refines .
. figure .,  ,  exists  sequence.
., ., . . . ,   mul-trees  .
. . .    .  .,.
.    . ., ., . . . ,  . .,  mul-tree .
 obtained    adding  new vertex ,.
connecting    new edge   vertex  .
   least three children, deleting  edges.
    least two .  .  .
children,   connecting  children, .
  new edge,  vertex     become.
children    .
  following  will refer   process described .
. also   single refinement step, ,  case  need.
   precise,  refinement  vertex   vertex.
.
. problem . . selecting  compatible.
collection  clusters.
 approach  based   fixed-parameter algorithm.
described  .  decide whether  given collection.
 clusters   multiset  compatible.  use .
algorithm  check,   step , whether   next.
cluster    list   collection .  compatible.
  process, two dynamic programming tables .
used.   first one, denoted  .,  rows .
indexed   submultisets  . .    columns.
 indexed   subcollections . . .  entry.
 .   .
.  .  either .  .,  .
. means   exists  mul-tree  .   . .
. . . .  . means      multree  .  computation   entry  . involves.
 look-up   entries  .    use.
 second table  describe next.
 second table, denoted  .,   row .
certain collections  . .,., . . . ,.  submultisets   ,   column   subcollection . . .
,  entry  .  given   .  either .
 .,  . means  .   partitioned  ,.
possibly empty, subcollections ., ., . . . ,   ,.
 every  . ., ., . . . , .,  exists  mul-tree .
     . . holds,   entry  . .
.   partitioned    way.  collections.
 considered  . result   preprocessing step.
described  .  partitions  given multiset .
 independent submultisets. checking compatibility.
   essentially amounts  checking whether .
exists  assignment   clusters     submultisets  . . resulting   partitioning  ,.
    .,  collection  clusters assigned .
 .  compatible  viewed  clusters   . .
computation   entry  . involves  look-up .
 entries  .  well   look-up  entries .
.
 follows   key observation  .  .
suffices  consider   submultisets   .
 dynamic programming tables    empty.
intersection   thin part .   .  .
consequence  size   tables   bounded .
.   constant  . . still,  practically.
relevant values  .,  size   tables  .
large   used   straight forward way. however,.
 computational experiments . figure .
 found    tables usually   small.
fraction   entries  actually accessed   run.
  algorithm. therefore, using  sparse matrix.
implementation   tables   stores .
entries   accessed  least ,   able.
 overcome  problem.
  speed-up  computation  , .
developed  following simple, yet remarkably effective.
rule  helps  reduce  number  accessed entries.
 . ,  turn, also reduces  number .
accessed entries  .  describe  rule, consider.
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure . percentage  accessed entries  . .
. plotted   size . .   multiset  .
 data point shown   average  . experiments  varying values  .
 entry  .   . .,., . . . ,.  .
.   exists   . ., ., . . . , .  .
.  .  holds   collection .  .
clusters  . .   .    need .
consider  entry  . put differently, .
 sufficient  consider  entry  .  .,.
 .  obtained  removing    .
.  obtained  removing  clusters  . .
.
 impact  .  illustrated  figure .   experiment, simulated input lists   obtained  first.
generating  random mul-tree   described  section .   using   generate  collection  .
. mul-trees  restricting   random submultisets.
    obtained  randomly removing  fixed.
percentage   elements   .
. problem . . assembling  scoring.
mul-trees.
recall   input   compatible collection  .
clusters   multiset  . essentially,  aim .
systematically generate  binary mul-trees  .
 . . .  keep track     .
reticulation number   phylogenetic network  . .
 minimum.   following,  outline first  .
  done   present  ideas  help.
 speed-up  whole process.  mentioned ,.
 approach involves   subproblem  problem .
computing  score . .   mul-tree   .
figure . illustration   impact   rule .
described   text  reducing  number  entries.
accessed  . expressed   speed-up achieved.
using  rule  comparison   using .  data.
point  averaged  . datasets  . .  depicted.
 . . . .
problem   shown   np-hard using similar ideas.
  employed  .
.  basic setup . depth first search .
systematically generate  relevant binary mul-trees.
  ,  perform  depth first search  consists .
two phases.   first phase  process  non-trivial.
clusters   according   suitably chosen ordering.
described .   second phase  possibly nonbinary mul-trees found  induce   refined .
binary trees.
 start ,  sort  non-trivial clusters  .
  ordering ., ., . . . ,    cluster  .
maximal  ., ., . . . , .  respect  multiset.
inclusion. ,   first phase   depth first.
search, assume ,  stage    search process,.
   mul-tree       nontrivial clusters induced    precisely  clusters.
., ., . . . , .  need  check whether  exists.
 mul-tree  .  results  refining  interior.
vertex      new vertex     way .
 .  holds. note ,  view   chosen ordering.
   process  non-trivial clusters  , .
 need  check interior vertices     .
 children  leaves. therefore,  check  .
performed  efficiently.   , however, .
 one  tree  .       next.
cluster .  processed   separate branch  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
depth first search.      tree  .  back.
track immediately.
   search  reach  point  .
current mul-tree      non-trivial clusters.
induced    precisely  clusters  ,  continue.
refining  ,  now    matter  longer.
 clusters  induced   new vertices added.
  refining.  single step   phase  .
depth first search consists  selecting  interior vertex.
     least three children   considering.
 possible ways  turn    vertex  precisely.
two children.   done  first refining    new.
vertex .  ,  case   still   two.
children,  refining    another vertex . .
   resulting mul-tree  . vertex   precisely.
two children, namely .  either one   original.
children  .
  entire search process  maintain .
initially empty list   pairwise non-isomorphic binary.
mul-trees    . . .     score.
. .  minimum among  binary mul-trees encountered  far.  denote  score  . , whenever.
 current mul-tree  considered   depth first.
search  binary,  compute . .  . . . . .
remove  mul-trees     add   . .
. . . .  check    isomorphic   multree   ,  case   , add   .  .
. . . .  keep     discard  .
 computational experiments  found  .
second phase   depth first search   far  .
time consuming one accounting    .  .
time. therefore,   next section,  focus  ideas.
   speed-up  computation   phase.
. speeding-up  second phase  key observation  rely    following     makes.
sense  refine  vertex    new vertex    .
 chance    resulting binary mul-tree  .
 least one  vertex .   . . . note .
   immediate consequence   way  phylogenetic network  . .  defined. also note   necessary condition   existence    vertex . .
 . . . must hold.   explain  .
observation   employed,  introduce  .
notation.   mul-tree    multiset   denote.
 set  children   vertex   . ,  addition, define  set . . . . . . . . .
. preprocessing  starting  systematically refine vertices  degree larger  three,   useful  first apply  preprocessing   simplifies  task  refining  given mul-tree  .
second phase.
first note    vertex   . . . .
.   safely refine    new vertex  .
 .
.
. . thus,   assume  now.
    mul-tree   want  refine  .
either . . .  . . .  every vertex.
.  particular,  compute  score . .  suffices.
 refine   vertices   . . .,.
 ,  need  refine     binary  .
derive . . already   intermediate non-binary.
mul-tree  refines  just enough.
next note  sometimes   partition  given.
mul-tree   subtrees   score  subtrees.
independently  one another.  outline   .
 done, define .   set   interior vertices .
     root    . . . . . .
 . denote  partial order   vertex set  .
  .   vertex  lies   path    .
root   . consider  set  .  maximal elements .
.  respect   restriction  .  . .
 mul-trees ,  .  . , together   tree  .
  obtained    replacing    .
distinguished leaf .,  .  . , form subtrees  .
 refined independently. note ,   . .
  partitioned,   possible   subtrees.
,  .  . ,    partitioned.   latter .
 case   partition  recursively.
.  dependency graph   section, .
describe   speed-up  actual refining   multree    multisetm .   denote  vertex set  .
 define  collection  potential clusters associated.
  vertex  .   . . . .
 . .
.
.
 .  . ., . . . . . .,.
 ,  collection   clusters   .
formed  refining vertex     relevant .
 score   tree.
now,     subset   .  dependency.
graph . ,. . .,.   directed graph  vertex.
set     directed edge ., .    .
  .    . . . . intuitively, .
consists   vertices   already  added.
 refine certain vertices   edge ., . .  indicates.
 considering  refinement  vertex  might .
relevant  computing  score . .   .
 least one  vertex    gives,   least will.
potentially give, rise   copy  cluster .
  describe   graph . ,. . .,.
might  used  prune  depth first search  outline.
briefly  . ,.  updated  refining  vertex.
 .   . . . . . recall  .
single step consists  selecting  subset  . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
 . . . . . ., adding  new vertex   .
child       changing  . .  .
  child      child  .  addition,.
putting  . . . ,  add another new vertex.
.   child      . . . . holds  .
change  . .  .    child    .
 child  .   following   consider .
case  two new vertices,   .,   added.
 case     added  completely analogous.
  . denote  resulting mul-tree  vertex set.
 . .  ., .  edge set . put  . .  ., .
 . . . ., . . . ., .  obtained  . ,.
.
. adding vertices   .
. adding edges ., .     vertices  . .
  . . . .  adding edges ., .
 .   vertices  .   . . .
.iii. adding edges ., .    .    .
. . .  adding edges ., .    . .
  . . . .
. removing  edges ., .     longer.
  . . . .
 speed-up  scoring using  dependency.
graph . ,. . .,.,  apply  following rule.
  exists   .     outgoing edge.
., . .    vertex    relevant  computing  score. ,   get   situation .
 track-back immediately.  refer     .
outgoing edge rule  noe-rule,  short.
. computational experiments  figure . .
illustrate  impact   preprocessing   application   noe-rule   run-time  simulated.
input mul-trees.   plot,  data point   average  . input mul-trees   multiset  .
 specified size  deviation   underlying set.
  clearly visible,  soon   size   increases.
 .,  new algorithm  problem . quickly.
becomes several magnitudes faster   basic setup.
described  section .  observation  independent   value  .    pronounced .
. . .
 shed  light   individual impact  .
preprocessing   noe-rule,  also measured .
speed-up achieved  applying  together  comparison  using  preprocessing alone . figure .
 different curves   plot highlight  impact .
 deviation   input mul-tree     binary tree,  ,  number . .  single refinement.
steps needed  turn    binary tree.  number.
figure . results   experiment . . . . .
 . values  specified.  terms   achieved.
speed-up  comparison   basic setup described.
 section .  executing  preprocessing step.
described   text  conjunction   noe-rule.
figure . speed-up due  applying  noe-rule .
addition   preprocessing  different values  . .
.  fixed  . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
figure . run-times   algorithm  problem .
   preprocessing   noe-rule .
applied . . . .
 given  percentage   maximum possible number.
 refinement steps   specified size   multiset.
 . overall,  picture    clear cut.  appears.
   specific combinations  . ., . .
. .    significant additional speed-up  .
achieved  using  noe-rule.
next,  figure .  actual run-times  experiments illustrating  combined impact   preprocessing   noe-rule  depicted.   clearly.
visible,  run-time grows   size . .   .
 growth  dependent   value  . .
finally,  figure .,  depict  run-time .
 overall method outlined  section .  using.
 new algorithms  problems .  . .
input collections   mul-trees  generated .
  way    experiments described  .
end  section .   .   number .
randomly removed elements fixed  . . note.
,  using  basic version   method.
.rule .  problem . switched ,  preprocessing.
  application   noe-rule  problem .,.
even  . . . .    simulated inputs .
  processed within . hours,  limit set  .
experiments.
. discussion  conclusions.
 new algorithms  problems .  . make .
possible  apply  consensus method described  .
 collections  mul-trees    . leaves,.
 </doc>
<doc title='021.txt'>
clique cover  sparse networks.
mathieu blanchette. ethan kim. adrian vetta.
abstract.
 consider  problem  edge clique cover  sparse.
networks  study  application   identification.
 overlapping protein complexes   network  binary.
protein-protein interactions.  first give  algorithm.
whose running time  linear   size   graph,.
provided  treewidth  bounded.   provide .
algorithm  planar graphs  bounded branchwidth upon.
  build  ptas  planar graphs. empirical studies.
show   algorithms   efficient  practical .
actual simulated  biological networks,    clique.
covers obtained  real networks yield biological insights.
. introduction.
given  graph  . .,.,  .edge. clique cover.
problem asks   smallest collection   cliques .
   every edge.    covered   least.
one clique  .   edge  required   covered.
 precisely one clique  ,  problem  known .
 clique partition problem.  problems  .
large number  applications  diverse disciplines. .
 consider one prominent example  computational.
biology. protein-protein interaction .ppi. networks.
 traditionally modelled  graphs whose vertices.
represent proteins,  vertices  joined   edge.
     two corresponding proteins interact.
  . recent studies ., however, .
discovered  number  interactions involving  .
. proteins.  protein complex   set  interacting.
proteins, involving anywhere  .  . proteins, .
forming cliques .,  least,  dense subgraphs.
  network.  number  algorithms  .
proposed  detect  complexes  various clique .
dense-subgraph discovery algorithms ., .  .
protein  often belong  different complexes, cliques.
typically overlap,  thus computational biologists.
 extended  algorithms  allow  overlapping.
.mcgill centre  bioinformatics, mcgill university, canada.
email. blanchem.mcb.mcgill., ethan.mcgill.
.department  mathematics . statistics, mcgill university,.
canada. email. vetta.math.mcgill.
.note  one  require  vertex .instead   edge. .
 covered   clique cover.  vertex clique cover problem.
 equivalent   well-studied graph colouring problem.
cliques ., ., .   knowledge, however, none.
  algorithms  guaranteed  exactly solve .
problem   designed .
 well  graph theoretic aspects,  clique cover.
problem   studied extensively   standpoint  computational complexity.  particular, .
 numerous studies concerning approximability .
fixed-parameter tractability.  terms  approximation,.
clique cover  np-hard  general .,  even .
 input graph  planar .   bounded degree .
furthermore, lund  yannakakis  shown .
clique cover   approximable within  factor  . .
  . . . unless  .  ., thereby removing  hope  good approximation algorithms  .
general case.   case  clique partition problem,.
 problem  also  shown   np-complete .
various restricted classes  graphs ., ., ., .
 parameterized problem  fixed-parameter.
tractable .fpt.     solved  . . .
time,     computable function depending .
 parameter , independent   input size .
recently, gramm  . . showed   clique.
cover problem  fpt   size   cover .
chosen   parameter . similarly, mujuni .
rosamond .  shown   clique partition.
problem  fpt   output size chosen  .
parameter.  algorithms run  polynomial time.
  input size  exponential time   number.
 cliques   solution.   result,  algorithms.
 well suited  dense graphs    cliques.
 cover  entire graph,     suitable.
 sparse graphs  require  large number  small.
cliques   solution.
  paper,  fill  gap  designing efficient.
algorithms   sparse graphs.  first introduce.
 definitions  related results  section . ,.
 section .,  will design  exact algorithm  clique.
cover   input graph  bounded treewidth.
section . discusses  problem restricted  planar.
graphs,   provide  polynomial time approximation scheme. finally,  show  performance  .
algorithm  experimental studies  section . .
particular,  algorithm shows efficient  practical.
running time  computing   real  simulated biological networks. furthermore,  ptas .
. copyright . siam.
unauthorized reproduction   article  prohibited.
planar graphs shows  clear trade-off  approximation ratio   running time  tested .
random planar graphs.
. preliminaries.
  paper,  study  clique cover problem .
sparse networks.  possible,  shall discuss .
 algorithms   clique cover problem  .
modified  solve  clique partition problem. various.
measures  network sparsity   proposed  .
past,  possibly  best known  treewidth.
definition . . tree decomposition   graph.
 . .,.   pair . . . . .,  . .,  .
  node  .   associated   set  vertices.
 .  ,  .
.  vertex belongs   least one node.
.
.  .
 .
.  edge  induced   least one node. ., . .
,     .   ,  . .
.    .  ,  set  nodes . . . . .
induces  subtree   .
 width   tree decomposition ., .  defined.
 maxi. . . .,   treewidth   graph ,.
denoted .,   minimum width   tree.
decompositions  .  general,   np-complete .
determine  treewidth   graph . however, .
  fixed, graphs  treewidth    recognized,.
 width  tree decompositions   constructed, .
linear time .
  empirical studies   input ppi data.
.shown  section ., table .,  treewidth  ppi.
networks  often small compared   network sizes.
 thus assume,  applicable,   input graph.
  bounded treewidth,   optimum tree decomposition   constructed efficiently. furthermore, .
simplicity  discussions,  assume   decomposition tree  admits  nice structure  defined .
definition . .  tree decomposition ., . .
called nice   tree   rooted,    node.
 . , one   following holds.
. leaf. node    leaf   ,  . . .
. join. node   exactly two children .  . .
  . . . . .
. introduce. node   exactly one child , .
 .  . .
. forget. node   exactly one child ,   .
 . .
   hard  see   . . ,   also.
admits  nice tree decomposition  width . , .
. tree nodes. given  arbitrary decomposition tree.
 , one  repeatedly split  node    nodes.
satisfy  conditions .
another closely related graph parameter  branchwidth.
definition . .  branch decomposition ., . .
 graph   characterized   ternary tree.  ,  .
bijection .   leaves   onto  edges  .
    tree edge   . removing   .
partitions  .  .,   partition induces .
partition  edges  , called  e-separation, associated   leaves  .  .  set  vertices.
    shared   .  .  called .
middle-set  ,   width   separation  .
number  vertices   middle-set.
given  branch decomposition ., .,  width.
  branch decomposition   maximum width.
  e-separations   ,   branchwidth  ,.
denoted .,   minimum width   branch.
decompositions.   well known   branchwidth.
 closely related   treewidth  graph . . .
. . . . .  planar graphs, fomin .
thilikos gave  upperbound   branchwidth.
theorem . .   planar graph , . .
. . .
. clique cover  graphs  bounded.
treewidth.
  section,  design  dynamic programming.
algorithm  finding  minimum clique cover   graph.
   nice tree decomposition ., .  given. .
 denote  width   decomposition. first, .
 define .    set  edges   subgraph.
induced   vertices  . furthermore,   .
denote  union   vertices     descendent.
nodes. similarly,   denote  subgraph  .
induced   vertices . finally,    .  .,.
 . denote  set  edges   incident   .
.
 shall  fact design  algorithm   generalization   clique cover problem,    given.
 subset   edges   already covered, ., .
solution need  cover ,  may use  edges .
 cliques. ,  original clique cover problem  .
. tree    ternary tree  every non-leaf node  degree .
. copyright . siam.
unauthorized reproduction   article  prohibited.
special case   . . since  dynamic programming  formulated around  decomposition tree  ,.
 often speak   subgraph    certain subset.
  edges  already covered, denoted  . now.
  define  cost function.
. . minimum size  clique cover   .
  already covered.
,  final solution  precisely .   .
 root   .  dynamic programming algorithm will.
proceed   leaves      root, computing,.
  node ,  value  .  every possible.
subset   . depending   type  node,.
.  computed differently.
leaf node. suppose    leaf node. ,  .
definition  nice tree decomposition, . . .,  thus.
. . .    . ., trivially.
forget node. suppose    forget node. ,  .
one descendant  .  . .   unique vertex.
.
lemma .     forget node,    subset.
 . ., . . .
proof. note  since  .  ,  corresponding.
graphs      . furthermore, since.
    ,  . . . . therefore,  . . .
 . .    . . . .
introduce node. suppose    introduce node.
,   one descendant node     .
.   unique vertex . consider  arbitrary.
clique cover   . since  cliques  .
  partitioned   . cliques containing  .
 .  . ,  following recurrence relation holds.
  introduce node.
lemma .     introduce node,   .
subset  . .
. . min. . . . . .
   clique cover  .  .
proof.     clique cover  .  partition.
 cover  .  .   defined,  consider .
edgeset  . since  edges  covered  ,.
 needs  cover  . . . . moreover, since.
 cliques     contain ,    cover .
 . . . therefore, . . . .,  .
lemma follows. .
 compute .,  need  consider  possible.
clique covers, ,  . . . since . . ,  .
 number  ways  partition  vertices,   given.
  kth bell number . . .
join node. finally, suppose    join node. , .
 two children nodes .  .    . . .
. ,   . . . . . therefore,  clique cover.
  contains cliques  belong  .  . . .
need  ensure   double count cliques  belong.
  .  . .
lemma .   . .   set  already.
covered edges,    . .   edges  .
covered. ,.
. . min. . . . . . .
. .   . . .
proof. assuming   already covered,    .
minimum clique cover  .  cost . .
definition,  clique  belongs   .  .
must also belong  . thus,  cliques    .
partitioned   . . . ., .
. . . .  .  . .   . .
. . . .  .  . .   . .
. . . .  .  . .
thus, . . . . . now,  edgeset  .
 partitioned   . . .  .
. . . .  .  covered  .  . .
. . . .  .  covered   . . . .
 definition, . . . needs  cover  edges .
. furthermore, . needs  cover  edges .
. . .,  thus . . . . . . . .
  hand,  cliques  .  need  cover.
 edges  . together  . . .,  thus.
. . . .,   result follows. .
therefore,   compute .   given.
subset  . . observe   recurrence relation.
looks   possible bipartitions  . since  number.
 edges  .   .
.
.
.
.
,  need  check .
 .
.
. different partitions  .   bipartition.
   fixed,  takes constant time  look   values.
 .  . .
note ,   recurrence relations calculate.
 size  clique covers,   also constructive. .
little bookkeeping   node will allow   construct.
 optimal cover   root node.
. running time.   node  . ,  compute.
.  every  . . since . . ,  node.
. copyright . siam.
unauthorized reproduction   article  prohibited.
contains    vertices.  . denote  maximum.
number  edges induced   node.   need.
 consider . cases. ,   fixed  . .,.
 carry  one   four recurrence relations. leaf.
nodes  forget nodes   computed  constant.
time.  introduce node   computed  .
time,  .  kth bell number. finally,  join.
node takes .  compute. therefore,  dynamic.
programming algorithm takes . . max. . , . .
. . . time overall.  .    large.
.
.
.
.
.
 theory,   rarely  case  shown  .
experimental tests .see section ., table .
theorem .    linear time algorithm .
computing minimum clique cover  graphs  fixed.
treewidth .
. modifications  clique partition problem.
  straightforward  modify   algorithm .
solve  clique partition problem. instead  assuming.
 edges already covered   re-used  form .
cliques,  simply delete  edges  solve .
remaining edgeset.   redefine  cost function.
.    size   minimum clique partition .
 graph  . ,   recurrence holds  .
node type.   difference  ,   introduce.
node, finding  local solution  .,  look  .
clique partition rather   cover.
. planar clique cover.
  section,  study  clique cover problem.
restricted  planar graphs,  present  ptas .
planar graphs.  planar graphs  possibly .
 restricted class  interest   clique cover.
problem . largest clique  just .,  problem.
remains np-hard . furthermore,  treewidth .
unbounded  planar graphs ., ., simply applying.
 algorithm  section .  result  exponential.
running time,  since tree decompositions  .
depend  planarity   input graph,   may .
difficult  specialize  algorithm  planar graphs.
instead,  shall design  exact polynomial time.
algorithm  planar graphs  bounded branchwidth.
  shall see,  algorithm runs  . time .
   branchwidth,  since . . .
   planar,     first subexponential.
algorithm   clique cover problem  planar graphs.
,  will use  exact algorithm  construct.
 polynomial time approximation scheme. baker . .
proposed  divide-and-conquer technique  design approximation schemes  various optimization problems.
 planar graphs.  will show   technique .
 applied   planar clique cover problem, using .
exact algorithm   subroutine, resulting   . . .
approximation algorithm.
. clique cover  planar graphs .
bounded branchwidth.    counterpart,.
treewidth,   np-complete  determine   graph.
  branch decomposition  width     general,   decomposition   found  linear time.
   fixed.  thus assume   input graph.
  given together   branch decomposition ., .
 width   . now pick  arbitrary edge  .
 ,  subdivide   create  root node .  .
tree nodex  associated   subset  edges  .,.
namely  leaf nodes   subtree rooted  . .
 . denote  edges   subgraph induced .
 subset  vertices .
define  middle-set  , denoted  mid.,.
   middle-set   edge    .
parent node. since  root node    parent, set.
mid. . . ,  create  table  . indexed .
 subset   edges  follows.
 . . .minimum clique cover  edges  .
  already covered.
since mid.   cutset  ,   paste together.
solutions   subproblem  computing .
 entries  . .     subset  edges .
.mid.
 describing  recurrence relation   table,  study  middle-set  three adjacent edges.
consider  sphere-cut branch decomposition  planar graphs,  studied  dorn  . . , .
middle-set defines  closed curve .noose.   planar.
embedding   input graph  intersects  .
vertices   middle-set. letx   tree node  two.
children nodes .  .  three edges adjacent .
 define . middle-sets   denote   , , .
 parent edge, left  right child edge, respectively.
since . . . .  . . . ., .
vertices   . .   partitioned  follows.
. portal vertices  .  . .
. intersection vertices  .  . . .
. symmetric difference vertices  .  . . . .
lemma .  table  . .   calculated .
 . . . min. . . . . . . . .
. . .   partition  . .  .
proof.   arbitrary clique cover    .
already covered, consider  cliques covering  edges.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. .  . observe ,  planarity  ,  clique.
intersecting   .   contains either vertices.
 .  vertices  . therefore,   partition.
 edges  . .  .  .  .,  . .
  covered  cliques  .,  .  covered .
cliques  .   partition,  solution  .
subproblem . . together   solution .
. . . . gives  solution   . . since .
consider  possible partitions  . . .,  formula.
follows. .
 algorithm runs   bottom-up manner. observe   compute  state    node,  need.
 consider  bipartitions  . .  . since   planar,   . . mid., . . . . .,  thus.
  .  partitions. moreover,  compute.
  states  ,  consider . subsets  edges .
.mid. altogether,   dynamic programming algorithm runs  . time.
lemma .    linear time algorithm  compute  minimum clique cover  planar graphs .
bounded branchwidth.
. modifications  clique partition problem.
   treewidth-based algorithm,   algorithm   easily modified  solve  clique partition.
problem. rather  assuming   already covered,.
one  simply delete  edges  solve   remaining edges.
. baker. technique  planar graphs.
baker .  proposed  general approach  design approximation algorithms  various np-hard problems.
 planar graphs. ,  show   technique,.
together   exact algorithm  section ., results.
  . . . approximation algorithm.
baker. technique   divide-and-conquer approach,.
  input graph  decomposed  layers .
subgraphs defined   distance   chosen vertex.
applying  technique   planar clique cover.
problem,  construct  following scheme.
. arbitrarily choose  vertex     execute .
breadth-first search  , starting  .
.   . .   . ., ., . . . ,  . .   .
., ., . . . .,  gij denote  subgraph   induced.
  vertices  levels .   . . ,.
 compute  minimum clique cover cij  gij .
.   . ., ., . . . ,  . .,   .
.
 cij ,  return.
whichever  ., . . . , .    least weight.
lemma .  solution    approximation.
scheme  weight   . . . opt.
proof.  . denote  optimum solution,  given.
 congruence class  mod ,   assume  .
 approximation scheme divides  problem .
 pieces. since  solution   piece  solved.
exactly,  .
. .
.
.
.cij . .
.
.
. .,.
 . denotes  optimum solution restricted .
 graph gij .  therefore need  compare  two.
values.
.
. . .  .  compare , consider.
 number  cliques  .  contain vertices .
levels  mod .  planar graphs,  clique belongs.
   . consecutive levels. therefore,   least.
one value  , . .  . ,      . .
cliques containing  vertex  level  mod . since .
cliques  double counted   sum.
.
. . ., .
.
.
.
. . . . .
.
.
.
  follows  . . . . . . .
according  tamaki. theorem .,  graph .
 branchwidth    radius   face-incidence.
graph.  . since  face-incidence graph   subgraph gij   bounded radius,  gij   planar.
graph  bounded branchwidth. therefore,  algorithm  lemma .  compute  minimum.
clique cover   subgraph   layer.
recall   dynamic programming algorithm .
graphs  branchwidth .  runs  time .
due  theorem ., directly applying  algorithm.
 planar graphs gives  exact solution  time.
.
.
.    hand,  ptas using.
baker. technique involves decomposing  graph .
. layers,  solving  piece exactly  time.
. trying  every congruent classes  .   . .,  overall algorithm takes  . dnk  .
. . . .  obtain  solution  value.
  . . . .opt . therefore,   ptas provides  approximation  varying degree  approximation ratio,  one wants  get  solution  closer.
 . . .
.
.opt , one may  better  running .
dynamic programming algorithm directly   graph.
 obtain  exact solution.  trade-off  clearly.
shown empirically  table .
theorem .    polynomial time approximation scheme  planar clique cover.
.given  plane-embedded graph ,  face-incidence graph.
. . . , . consists  vertices .  faces  ,  two vertices.
 .  joined   edge      corresponding faces.
  share  vertex.
. copyright . siam.
unauthorized reproduction   article  prohibited.
   . tree decomp. clique cover algo. .  cliques.
. .
krogan . . . . . . .
pam . . . . . . .
 . . . . . . .
table . performance  treewidth-based exact clique cover algorithm.  show  treewidth   graph,.
maximum .  edges per tree node ., time taken  compute  optimal tree decomposition   clique cover,.
 size   solution.
. experimental studies.
  implemented  described algorithms .
tested    real biological ppi data .
simulated data.   comparison,  considered.
gramm  . algorithm .   decision problem.
version  clique cover. given  size  clique cover .
  input parameter,  algorithm works  first.
applying  set  reduction rules  reduce  problem instance,   using  search tree algorithm .
 reduced instance,  time exponential  . .
 algorithm works well  cases   solution.
size  small,   perform poorly   test.
data  contains several hundreds  cliques. .
 mainly   reduction rules   significantly decrease  size   input graphs .especially.
biological networks.  solutions   reduced instances  still contain  large number  cliques,.
resulting  inefficient running time   search tree.
algorithm.   input parameter   size  .
minimum clique cover,  motivates  development .
approaches using edge sparsity   networks.
. simulated  biological networks.  .
 algorithms  tested   simulated  actual biological networks. first, krogan  . . obtained  extensive dataset  protein interactions .
yeast. taking  largest connected component .
 dataset,  . vertices  . edges,  formed.
 model network, gkrogan. various studies  shown.
 ppi networks exhibit  properties  scale-free.
networks . many generative models  scale-free networks  also  proposed,   used  two.
 frequently used models ., .  create test graphs.
  algorithm. . preferential attachment model.
.denoted  gpam .,  . duplication model .denoted  gdm .   cases,  set  parameters .
generative models    resulting networks show.
similar characteristics    real ppi data. den.http.www.mcgill.ethan.work.cliquecover.
sity  . . . .,  degree distribution  . . .
 . . .
 investigate  behavior   algorithms .
denser graphs,  generated  set  partial k-trees.
recall   k-tree   maximal graph  treewidth.
    edge   inserted without increasing.
 treewidth,   graph   partial k-tree   .
 subgraph   k-tree.  partial k-trees  given.
treewidth   generated  first generating  ktree,  randomly removing edges  obtain desired.
edge density. since  generation process  k-trees.
 similar     preferential attachment model,.
 allows   create graphs  higher density .
gpam  preserving  treewidth bound.
. performance   treewidth  branchwidth based algorithms. table . reports results obtained  real  simulated biological networks. .
krogan. ppi network  simulated networks exhibit.
relatively low treewidths   size. figure . gives.
  comprehensive view   running times .
empirical testing.  expected,  running time increases linearly    graphs  fixed treewidths.
.figure .,  exponentially  treewidth  .
 fixed graph sizes .figure . running times .
partial k-trees .figures .  . follow  .
trends, although   somewhat higher due  .
higher edge density.
  branchwidth-based exact algorithm .
designed  planar graphs,   easy  modify .
algorithm  handle non-planar graphs  bounded.
branchwidth .   expense  higher time complexity due  non-planarity. figure . shows , .
practice,  running time   treewidth-based algorithm grows slower     branchwidth-based.
algorithm, allowing   handle graphs  larger.
treewidths.
. performance  ptas  planar graphs.
 test  ptas  planar graphs,  generated .
. copyright . siam.
unauthorized reproduction   article  prohibited.
      . . . . . .
.,.
.
.,.
.,.
.,.
.,.
.,.
.,.
.,.
.  vertices.
tim.
 .
 .
.
.
 .
.
.
.
.
.
.
                  . . . . .
.,.
.
.,.
.,.
.,.
.,.
.,.
.,.
.,.
treewidth.
tim.
 .
 .
.
.
 .
.
.
.
.
.
.
.
                     . . . . .
.,.
.
.,.
.,.
.,.
.,.
.,.
.,.
.,.
.  vertices.
tim.
 .
 .
.
.
 .
 . .
 . .
 . .
 . .
 . .
.
                  . . . . .
.,.
.
.,.
.,.
.,.
.,.
.,.
.,.
.,.
treewidth.
tim.
 .
 .
.
.
 .
 . .
 . .
 . .
 . .
.
figure . performance   treewidth-based algorithm  simulated networks. . scale-free networks .pam.
 fixed treewidth. . scale-free networks .pam.  fixed graph size. . partial k-trees  fixed treewidth.
. partial k-trees  fixed graph size.
. copyright . siam.
unauthorized reproduction   article  prohibited.
                  . . . . .
.
   .
.
.
.
.
.
.
.
treewidth.
log.
. .
 .
.
 .
 .
 .
.
  .
.
    .
. .
 .
.
 . .
.
.
 . .
.
.    .
. .
 .
.
tw-based.
bw-based.
.
                  . . . . .
   .
   .
   .
   .
   .
   .
   .
   .
.
.
.
.
.
.
treewidth.
log.
. .
 .
.
 .
 .
 .
.
 .
 .
.
    .
. .
 .
.
 . .
.
.
 . .
.
.    .
. .
 .
.
bw-based.
tw-based.
.
figure . performance comparison  treewidth-based algorithm . branchwidth-based algorithm  scale-free.
networks. y-axes  shown  log scale  exemplify  difference  exponents   running time. . scale-free.
networks  . vertices. . scale-free networks  . vertices. data points    treewidth values.
  chart  taken    network.
set  random planar graphs using  simple algorithm.
 denise  vasconcellos . ,  ran .
 exact branchwidth-based algorithm   ptas.
 varying values  .  explore  trade-off .
running time  quality   solution.  shown .
table .,  promised approximation ratios  almost.
exactly realized  substantial speed-ups  obtained.
 relatively large values  ., compared   exact.
branch-decomposition based algorithm.  running.
time increases exponentially  .,   exact.
algorithm starts  become faster   ptas .
. becomes sufficiently small.
. .  cliques time .
. . .
. . .
. . .
. . .
opt . .
table . performance  ptas  planar graph .
 . ., . .,  . . opt  obtained using.
 branch-decomposition based algorithm.
. analysis   clique cover   biological network.  executed   yeast proteinprotein interaction network  krogan  . ., .
treewidth-based algorithm finds  clique cover  includes . cliques  size .  .   ppi data.
may  admit  unique clique cover   network,.
 manually verified   discovered cliques correspond  known complexes,    rna polymerase ,  rsc complex,  mediator complex, .
 . proteasome.  addition, three highly overlapping complexes, swr. . chromatin remodelling complex., nua. . histone acetyltransferase complex., .
ino. .another chromatin remodelling complex. .
correctly identified, despite  fact  swr. .
nua. share three subunits .arp., god.,  yaf.
 swr.  ino. share four .arp., god., rvb.,.
rvb.  suggests   algorithm  capable .
identifying biologically relevant protein complexes, even.
  share  significant number  subunits.
. conclusions  future work.
  paper,  study  clique cover problem .
sparse networks  measured  treewidth  branchwidth,   application  protein-complex discovery.
 protein-protein interaction networks.  give exact.
. copyright . siam.
unauthorized reproduction   article  </doc>
<doc title='022.txt'>
 experimental  analytical study  order constraints  single machine.
scheduling  quadratic cost.
wiebke . . tobias jacobs .
abstract.
 consider  problem  scheduling jobs   single.
machine. given  quadratic cost function,  aim .
compute  schedule minimizing  weighted total cost,.
  cost   job  defined   cost function.
value   job. completion time. throughout  past.
decades, great effort   made  develop fast exact.
algorithms   case  quadratic costs.  efficiency.
  methods heavily depends   utilization .
structural properties  optimal schedules   order.
constraints, ., sufficient conditions  pairs  jobs .
appear   certain order.  considerable number  different.
kinds   constraints   proposed.   work.
 enhance  map  known order constraints  proving.
 extended version   constraint    conjectured.
 mondal  sen    decade ago.
besides proving  conjecture,  main contribution.
  extensive experimental study   influence .
different kinds order constraints   performance .
exact algorithms  systematically evaluated.  addition.
  best-first graph search algorithm,  test  quadratic.
integer programming formulation  admits  add order.
constraints  additional linear constraints.  also evaluate.
 optimality gap  well known smith. rule  different.
monomial cost functions.  experiments  based .
sets  problem instances    generated using.
 new method  allows   adjust  certain degree .
difficulty   instances.
. introduction.
 investigate algorithms  scheduling jobs  .
single machine   nonlinear cost scenario. .
input consists   jobs,    nonnegative.
weight  processing time.  refer   jobs .
integers ., . . . , ,  denote  processing time .
.hoehn.math.tu-berlin. technische universita. berlin,.
germany. supported   deutsche forschungsgemeinschaft.
.dfg.  part   priority program .algorithm engineering. .
.tobias.jacobs.neclab. nec laboratories europe, heidelberg, germany. work supported   fellowship within .
postdoc-programme   german academic exchange service.
.daad.
weight   job  . ., . . . , .     , respectively.
 objective   schedule  jobs nonpreemptively.
  single machine    weighted sum .
quadratic completion times.
.
. wjc.
.
  minimized,.
    completion time  job . following.
 three-field notation .,  problem  denoted .
. . . .wjc. .
 important alternative interpretation  .
problem .,  general,  problem variant  minimizing.
.
wjf.   nonlinear function .  .
scenario  linear cost  nonuniform processor speed.
assume   processor speed   time   given.
  nonnegative function  . . ,   processing.
times . workloads.    jobs  given  respect.
  unit speed processor.  total workload processed.
 time   . .
. .
.
. conversely,   total.
workload  job    jobs processed    .,.
  cost     schedule  . therefore,.
 problem  equivalent  . . . .wjg. .
getting back   original setting, nonlinear cost.
functions  commonly used   tradeoff .
worst case minimization   flowtime minimization.
problem . . . .wjcj .  latter  solved  optimality.
  well-known smith. rule  schedules  jobs.
 nonincreasing order  .
.
.
-ratios . verifying.
optimality   method   easy. still,  .
next paragraphs,  use  discussion  exemplify .
terminology  local  global order constraints, .
play  central role   work.
whenever   optimal schedule  . . . .wjcj.
jobs     processed consecutively,  . .
.   sufficient condition    processed.
 .  follows directly   exchange argument.  fact  job  must  processed   whenever  jobs  adjacent  expressed.
  notation  . .  say   jobs   .
 locally comparable  either  .    . .
holds.  local order constraint   implication  .
form  .  . ,     proposition  .
 .   example,  local order constraint reads.
 . . . .  . .
 contrast,  global order constraint   implication   form  .  . .  relation  .  . copyright . siam.
unauthorized reproduction   article  prohibited.
presses  job   processed     optimal.
schedule, even.    difference  local order.
constraints.    jobs scheduled  .
 .  jobs     called globally comparable.
  .    . .
 case  . . . .wjcj ,   local order constraint  actually  global one.  job pair ,   either.
locally comparable,  . . .   processing order   impact  objective function value.
  processed consecutively.  implies  optimality  smith. rule.
 considering  quadratic cost function instead,    obvious local  global order constraints  immediately lead   optimal schedule.
. .  particular,   condition . .
.   even sufficient  local comparability. due.
 nonlinearity,  benefit  interchanging adjacent.
jobs      positive  negative, depending .
 position   job pair   schedule.
problem . . . .wjc.   studied   great.
extent   focus  exact solution methods. see.
. ., ., ., ., ., ., ., ., .    works.
utilize branch-and-bound approaches  pruning rules.
based  order constraints.   work  extend .
set  known constraints  evaluate  influence .
 performance  various algorithms   extensive.
experimental study.
related work. half  century ago, schild .
fredman . proposed  complete enumeration scheme.
 solve  problem  quadratic cost functions, taking.
 account  local order constraint  reduce .
solution space. nearly two decades later, townsend .
  first  solve problem . . . .wjc.  branchand-bound.  pruning,  uses  lower bound .
 optimal cost related   local order constraint .see.
section .  initial article triggered  long series.
 papers proposing many improvements   branchand-bound algorithm.
bagga  kalra . add   node elimination.
rule,    sufficient condition  sets  jobs appearing   first  positions   optimal schedule.
global order constraints   context  first used.
 gupta  sen .,  proved  sufficient condition  .  . wjpj . wipi. order constraints .
additionally depend   time interval within .
 job pair  processed  used  .  . finally,.
mondal  sen . conjectured  global order constraint  .  . . . . .  .   demonstrated   experimental setup   constraint.
 significantly  reduce  resource requirements.  overview   order constraints known .
far   found  figure .
  original branch-and-bound method .
townsend, nodes represent prefixes  schedules. sen.
 . . propose  reduce  number  generated.
nodes  using  graph searching procedure. ,.
nodes alternatively represent unordered sets  jobs, .
 schedule   represented   path   graph.
kaindl  . observe  .     efficient .
build  schedule   end   beginning .
vice versa.   adopt  ideas,   detailed.
description     found  section .
 algorithms mentioned   previous paragraphs  practically efficient,   exponential.
worst-case runtime.  fact,   today    known.
 . . . .wjc.  np-hard. recently,   .
much progress concerning approximation algorithms .
. . . .wjf.  general cost function  ,  even.
 . . . . . ,   job    individual.
cost function  . bansal  pruhs .  given  geometric interpretation   latter problem  yields .
.log log  .-approximation   presence  release.
dates  preemption.   special case  uniform release dates,  method achieves  constant approximation factor  .  factor   improved.
 . . . via  primal-dual approach  cheung .
shmoys .
 . . . .wjf.  arbitrary concave  ,.
stiller  wiese . show  smith. rule guarantees  approximation factor  .
.
. . .  .
tight    part   problem input. moreover,.
 construct  efficient polynomial time approximation scheme   problem variant  release dates.
also taking  account release dates, epstein  .
provide  approximation algorithm.   problem .
generalizing  results  scheduling unreliable machines .  method generates  schedule  .
approximation guarantee .   cost function. .
 companion paper .  derive  simple method .
calculate  tight approximation factor  smith. rule.
  particular convex  concave cost function. .
resulting factor   quadratic case considered  .
paper  .   companion paper  also show .
 problem  np-hard   class  cost functions .
corresponds  periodically alternating processor speed.
 contribution.  focus   paper  .
exact methods  problem . . . .wjc. .  prove.
 extended version   global order conjecture .
mondal  sen .   remained open since .
 resulting improvement   map  known order.
constraints  illustrated  figure .
besides  theoretical result,  main contribution   extensive experimental study,  algorithmic approaches    proposed throughout .
.www.mpi-inf.mpg.nmegow.papers.universal.pdf.
. copyright . siam.
unauthorized reproduction   article  prohibited.
weight.
time.
processing.
.
.
 . .
 .   .
 .   .
 .
 . .
 . .
 . .
 .
 .
 .   .
 . .
 .
 .
 .
.
.
. .
 .
.
.
. .
.
. .
 .
wipi.
.
weight.
time.
processing.
.
 . .
.
 . .
 . .
 . .
 .
.
.
. .
.
. .
 .
.
.
. .
 .
.
.
.
.
. .
 . .
.
.
. .
figure .  figures show  known order constraints.
  problem . . . .wjc.  comparability maps.
 respect   job . figure . shows  results.
known  previous works, whereas figure . integrates  new insights   paper.   comparability.
map,  job  represented   point  .  .
first component   processing time   second .
weight.
past three decades  systematically evaluated.  special focus    influence  order constraints  .
performance   algorithms.  tested different variants   graph search procedure stated , .
also  quadratic integer program formulation  admits  add order constraints   form  simple linear constraints.  addition,  evaluated  practical.
solution quality  smith. rule  different monomial.
cost functions.  turns    simple heuristic .
almost optimal   test instances.
  best   knowledge,  previous experimental work   based  instances  .
generated  choosing   weight   processing time uniformly  independently  random.
 figure ., one  intuitively expect  .
instances  easier  tackle  instances   positive correlation   processing time  .
weight   job.   generated  test set using .
new method   correlation   set   parameter.  experiments reveal   difficulty .
problem instances indeed increases   correlation.
paper organization.   following section .
describe  global order constraints evaluated  .
experimental study,  prove  extended version .
 global order constraint conjectured  mondal .
sen.  algorithmic approaches  data sets investigated   experiments  presented  section .
 . thereafter,  section .,  discuss  results.
  computational study. section . concludes .
work.
. global order constraints.
  section,  introduce  five types  global.
order constraints whose benefits  evaluated  .
experiments. two    consequences  .
extended version   conjecture  mondal .
sen .,   prove   second part  .
section.
. constraint types.  following conditions .
 global, ., sufficient conditions   . .
basic constraint.  global constraint  . . .
 .  .    given  sen  . . .
note   still holds  one   two relations.
  sufficient condition   equality instead .
 inequality.  fact,  constraint holds also .
 problem . . . .wjf.  nondecreasing cost.
function  .
.-gap constraint.  a-gap constraint   sufficient.
condition   form . .  . .  show  .
next subsection   problem observes  global.
.-gap constraint.
weight constraint.  global weight constraint .
 conjectured  mondal  sen.  states .
 .  holds   .   . . . ,  .
jobs      identical.  prove  together.
  global .-gap constraint   next section.
decomposition.  decomposition technique .
 proposed  szwarc  . .   based .
local comparability. recall   .  means .
  optimal schedule   jobs    .
adjacent,  must precede .   known   .
pair  adjacent jobs ,     point  time tij.
   must  processed     first.
  jobs starts  time tij ,  vice versa .
  processed  tij .  critical point  time.
  easily computed   characteristics  .
two jobs.
    total processing time   jobs .
 problem instance.  schedule takes place within.
 time interval .,  . therefore  .  holds .
tij .  .  .  ,   .  holds whenever tij . . .
 first step,  decomposition method determines .
. copyright . siam.
unauthorized reproduction   article  prohibited.
 job pairs ,   one   two relations hold.  .
tries  decompose  instance  two subinstances.
 deriving global order constraints   local ones.
assume  simplicity   jobs  indexed .
 . . . . . . .  decomposition method.
tries  identify  index     .   .
 .  . .    index  found,   clear .
  optimal schedule  jobs ., . . . ,   scheduled.
  jobs  . ., . . . , .   words,  global.
order constraint  .  holds    .  . . .
 also know  ., . . . ,   processed inside .
time interval .,  .   . . . . . . . . ,  .
jobs  . ., . . . ,   scheduled   interval . .,  .
now  decomposition procedure  recursively applied.
  two job subsets  respective time intervals.
note    restricted time intervals  lead .
new local order relations.
combined constraint.  constraint  simply .
combination   four constraints .  one  .
constraints implies  ordering relation,   .
 combined constraint.
. proof  weight  .-gap constraint. .
continue  proving  global weight  .-gap.
constraint,  former  conjectured  .
theorem . problem . . . .wjc. observes .
global weight constraint   global .-gap constraint.
  pair  jobs , ,    .   one  .
following sufficient conditions hold.
.  . , wipi .
.
.
,  ,    identical,.
. wipi . .
.
.
.
proof.  constraints  proven simultaneously .
induction   number  jobs   scheduled.
  job pair satisfying  respective constraint.
 specifically,  show  increasing values   .
   optimal schedule    pair  jobs , .
satisfying .  .  job   processed   .
      jobs  .  base.
case  . .   local variants   constraints.
 proofs  given  lemma .  .  .
 general case  monomial cost functions.
  induction hypothesis,  assume  .
theorem holds ,   fixed ,   less.
  jobs scheduled  two jobs    satisfying property .  . based   assumptions,.
 first show  induction step  .  lemma .
 lemma   used   induction step  . .
lemma .  proof   two lemmas will complete also  proof. .
  proofs   following lemmas  will use .
fact  problem . . . .wjc.  invariant  scaling,.
.,  multiplying  weights   constant  .
 processing times  ,  cost   schedule .
 scaled instance  obtained   cost   .
schedule   original instance  multiplication .
. hence, also optimal schedules coincide.
lemma . problem . . . .wjckj ,  . , observes.
 local weight constraint.
proof. whenever  .  holds  jobs   ,  .
still holds   processing time     made.
shorter. thus,   assume without loss  generality.
 . . . .    scaling argument, .
 also assume   .  . .  . .  .  . .
comparing  cost  scheduling   point  time .
firstly      vice versa,  .  holds  .
   following inequality  satisfied.
 . . . . . . . . . . . . . . .
 define  function  .  . . .
.   subtracted term   constant   . .
strictly convex  . ,   strictly concave  .
.
. . now.
  inequality reads  . . .,  holds.
true due   strict concavity  . .
lemma . problem . . . .wjckj ,  . , observes.
 local k-gap constraint.
proof. .sketch.  need  show  given two jobs , .
 . .  .  holds   . . analogously.
  previous lemma, consider  defining condition.
  . . resolving   ,  get  necessary .
sufficient condition.
 . .    . ., .
 .  . .  . .
 . . .
.  . . . . . .
   . .,  function    shown  .
concave,   .   . .,   satisfy .
.
. . .
 properties imply   point  .  .  lies.
  curves . .
lemma . assume    fixed  theorem .
holds   pair  jobs ,   satisfy .  .
   less    jobs  scheduled.
 constraint . holds also   case  .
  jobs scheduled    .
proof. assume  contradiction     optimal schedule  job pair ,  satisfies .,   processed  ,     jobs  . .
make three simplifying assumptions. firstly,  assume.
  .  . .   without loss  generality,   optimality   schedule  invariant  weight.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 cost scaling. secondly,   assume   .
  last job, since  removing  jobs scheduled    obtain  optimal schedule   remaining jobs     show  contradiction.
thirdly,  assume  . .  . .  first inequality holds  otherwise  assumption  . .
satisfied   jobs   identical  imply.
  .  . .   .  . .,   global basic.
constraint .see subsection . immediately leads  .
contradiction. hence,    .  . .  reason.
  .    assumed without loss  generality .
 lowering  weight   preserves  optimality .
 schedule  consideration.  fact,   .
 better schedule   instance   decreased,.
 straightforward calculation shows   schedule.
 also  less costly   original instance. finally,  relabel  jobs  refer  job   ., ., .
job   ., .   .  . ,   jobs .
  assumed   ., . . . , .  make  notation.
even shorter  also write . instead  ., . . . , .
 now define  function . measuring  cost increase  decrease   sub-schedule .  interchanged   job ., .  identical processing.
time  weight  . job ., .  used   abstraction   jobs ., .  ., .  function . depends   jobs .,  value  ,   starting.
time   ., .  . .depending   one  processed first. however,  suppress  dependence .
everything    writing.
. .
.
.
.
.
.
.
.
.
.
. .
.
.
.
.
 . .
.
.  . . .
.
.
.
.
. .
.
.
.
.
.
whenever .  negative .positive.,   strictly cheaper.
 schedule .  . ., . .  zero.
means   possibilities  equal cost. .
second derivative  .    .
.
. . .
   point   require  induction.
hypothesis. property .   characteristics  job.
., . imply  . . .  . . ., . . . , . therefore,.
 second derivative  .  strictly positive,  hence,.
.  strictly convex     two roots. one .
 roots    . .,     . . . .
 . . .   . ., ., . . .,  . .
strictly increasing   . . note  possibly . . .
 . might  completely nonnegative.
 optimal schedule  consideration contains ., ., ., ., .   contiguous sub-schedule.
 . . .,  one obtains  cheaper schedule .
interchanging ., .  .,  contradiction  optimality.  . . .,  . . .   case.
consider  alternative schedule obtained   following operations. . interchange ., .  ., .
interchange ., .  ., ., . interchange . .
., .  second operation decreases  cost, due .
 local version   weight constraint .lemma .
 first operation   decrease  cost due .
. . .,   increase    compensated.
   third operation  . . .  .
  obtain  cheaper schedule,  contradicts .
optimality   original one. .
lemma . assume    fixed , theorem . holds   pair  jobs ,   satisfy .
 .    less    jobs .
scheduled.  constraint . holds also   case.
    jobs scheduled    .
proof. assume  contradiction     optimal schedule  job pair ,  satisfies .,   processed  ,     jobs  . like.
  proof  lemma .,  assume . .
 .  . .,   rename   jobs    .
 ., . . . ,   use .,.,   abbreviation   sequence,  course also assuming ,  . .  job  satisfies  . .   also assume   . . .
otherwise  job pair ,   satisfy property .,.
  impossible due  lemma . furthermore,.
 must hold   . .,  otherwise  .
  .    .  ,   basic constraint.
.see subsection .  immediately prove suboptimality. summarizing,  suffices  analyze  situation.
 .  . . .  . .
  following notation  ignore  jobs scheduled     jobs , ., . slightly abusing.
notation,  refer   schedule  also   cost .
., .,.,, ., analogously   permutations  .
job subset.
claim. ., , ., ., . . ., , ., ., .
  claim  true,   suboptimality .
., ., .   shown  calculating.
., ., . . ., , . ., , . . ., ., .
. ., ., . ,.
  second inequality  due   local version.
  weight constraint .lemma .
 prove  claim,     point  time .
job  completes   optimal schedule ., ., . . .
 .   total processing time   jobs.
 .  regard  cost caused    jobs .
 function    completion time   last job .
 left hand side   claimed inequality accounts   .positive  negative. cost gain . cost.
. copyright . siam.
unauthorized reproduction   article  prohibited.
decrease.  transforming ., , .  ., ., . .
 transformation  jobs . become processed earlier,  cost decreasing   .gain.,  job  becomes  expensive, requiring  pay  additional.
amount  . .loss.   right hand side   inequality, ., , .  transformed  ., ., ., corresponding  analogous variables   . recalling.
  denote  cost function   jobs .   ,.
 variables compute .
 .  . .  . . . ,.
. . .
. . . . . ,.
 .  . .  . . . , .
. . .
. . . . . .
 conclude  proof  require  estimate  .
 . ,   equivalent .
 . .  . . . .  . . . .  . . . .
 loss terms satisfy . .  . .   going .
show    .  . ,  implies  claim.
 follows.
. . ., , . ., ., .
.  . . .  . . . . .  . .
. ., , . ., ., . .
 first inequality  due   optimality  schedule.
., ., .,  second one follows  . .  . . .
  proposition   .  . ,   third.
inequality follows   . .
 remains  show  proposition  .  . ,.
  equivalent  proving.
 . .  . . . .  . . . .  . . . .
  need  know        nonnegative quadratic function   strictly increasing .
. . .,.    reasoning   difference .
function values,   reasoning will hold  .
function curve     shifted vertically.  .
also shift  function horizontally   shift  points.
 evaluation  , . ,   . . along  .  .
sake  simpler calculations,   transformations .
 kind,    obtain  . . .  . . . . .
    written   . .  .  . . . . .
 . . furthermore,     positive root .
therefore  . .
utilizing  . .   . . . .,   write.
 . .  . . . .  .  . .
. . . . . . . . . ,.
 right hand side     reformulated .
. . . .  . . . . . .
 quantity  strictly smaller .
. . wia. . . . ,.
  equal  . . .  . . . .
. exact algorithms.
  section    details   exact.
algorithms   implemented  tested. global.
order constraints  treated   black box .
. graph search.  consider  exact algorithm.
combining  insights   two major approaches.
discussed  previous articles.   one hand side,.
  standard branch-and-bound methods whose.
intelligence consists  utilizing order constraints, .
latest work   mondal  sen .  .
 hand, sen  . .  kaindl  . . propose.
 best-first graph search .bfgs., exploring  graph.
 forward .bfgsf.  backward .bfgsb. manner,.
respectively. see . ., .   general description  .
 popular best-first search algorithm .  bfgs.
approaches  ., . utilize  lower bound shown.
 townsend .   branch-and-bound algorithm.
however, regarding  use  order constraints .
pruning  search space,   exploit  rather.
weak constraint  bagga  kalra .  uses.
 local version   weight constraint   limited.
decomposition   problem instance.   best .
 knowledge, global order constraints   yet.
 integrated  bfgs methods   problem.
. . . .wjc. .
sen  . . showed   experiments ,.
comparing .forward. best-first graph search bfgsf,.
best-first tree search  depth-first search, bfgsf .
 far  fastest   randomly generated instances.
 experiments  kaindl  . . demonstrated .
bfgsb  even faster. opting   fastest variants, .
will consider bfgsf  bfgsb    speed.
  integrating  constraints. however note .
 larger instances depth-first search might become .
method  choice due   lower memory consumption.
graph-based search  .  consider.
bfgsf  bfgsb based   best-first search algorithm . .  extend  methods proposed.
 ., .  integrating global order constraints .
prune  search space.  describing  algorithm,.
 focus  bfgsb since   slightly less intuitive .
faster  bfgsf.   end   section,  remark.
  modifications   necessary  bfgsf.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  graph  considered   context, nodes.
represent subsets  jobs . slightly abusing notation,.
 refer   nodes   corresponding job sets.
  denote  set   jobs   instance. .
 node  .     directed arc  node.
. .  . .    . , . .,  arc corresponds .
 job ,   cost ., .  set   cost incurred.
 job   scheduling  inbetween .   . . .
formally.
., . . ., . . .
.
.
.
.
.
now,  path    .   naturally corresponds.
  schedule  . . . .wjc. ,   arcs  .
path represent  permutation ., ., . . . , .  .
jobs.   perform backward search,  corresponding schedule  ., . ., . . . , .   words,.
 partial path     node  represents .
partial schedule   jobs  .  processed .
 jobs  . due  cost  corresponding paths .
schedules   ,    one-to-one relation.
 minimum cost paths    .  optimal.
schedules  . . . .wjc. .
 remainder   algorithm  basically .
run .   graph. two versions   admissible.
lower bound heuristic  guiding  search  described.
.   sake  memory efficiency  graph .
built dynamically, generating new nodes   approach.
   search. furthermore.   .
point   extend  algorithms  ., .
 node   infeasible     pair  jobs.
 .  .,  .    . .   search infeasible.
nodes  ignored.
  forward variant bfgsf  need  modify.
   follows.  arcs  going    .
neighbors  . .,  . ,   cost ., .  .
 arc  given   cost incurred  appending .
  end   schedule   jobs  .  root.
node  given  . consequently, paths  .  .
correspond  schedules  . . . .wjc. ,   .
permutation    need   inverted.
 continue   discussion   used lower.
bounds,  refer  .   details   .
procedure .
lower bounds.  order  test  impact  .
different order constraints without external influence.
 sophisticated lower bounds,  consider  rather.
basic lower bound besides townsend. lower bound .
  context,  lower bound   function  .
subsets  jobs .   backward variant bfgsb.
 corresponds  providing  bound   cost.
  schedule   jobs  , starting  time .
inversely,  bfgsf  bound needs   computed.
 respect  .  time .  .   fact, .
  formulated   function   start time   .
schedule    jobs  . .    scheduled. .
basic lower bound . simply  given   total cost.
  jobs   .  starting   time .
townsend. lower bound .  based   local.
weight constraint.  first computes  schedule .
sorting  jobs  nonincreasing ratio . . assume.
 simplicity   order  ., . . . , .  optimal.
schedule   obtained   schedule   series.
 local interchange operations   order  two.
adjacent jobs ,    .   changed  , . .
upper bound   cost reduction    operation.
 . . .wiwj . townsend computes  upper bound.
  job pair , ,  whenever   positive .
 subtracted   cost  schedule ., . . . , . .
gives  lower bound   optimal cost.  relation.
  local weight constraint  due   fact .
 amount subtracted  job pair ,   zero whenever.
 weight constraint   job pair  satisfied. also.
observe  townsend. lower bound  independent .
 time     schedule  consideration.
starts.
 referring   combination   graph search.
algorithm   specific lower bound,  add  lower.
bound. name  superscript   algorithm name,.
. ., bfgsbf  bfgs.
.
 .
implementation note. since global order constraints  evaluated extremely often   run .
 algorithm,  transfer  evaluation   preprocessing step  computing   .  comparability.
matrix.  ,  time  evaluating constraints becomes negligible later ,  moreover,   independent   constraint used.  checking  feasibility.
  node . reached   .feasible. node   .
main computation, one    test  constraint.
matrix   job pairs ,    . .,  . . .
,  .  .,  .   forward search.  number .
 pairs  smaller  .
. quadratic integer programming.  .
several possibilities  express . . . .wjc.  terms.
  mathematical program.  reason  .
 chosen  quadratic integer programming .qip.
formulation     admits  directly add.
order constraints   form  linear constraints .
 program.  used cplex .   solution.
  pair  distinct jobs  .   introduce.
 binary variable xij   defined   .   .
scheduled  .  order  ensure   feasible.
solution represents  total order,  add constraints.
enforcing transitivity  preventing  triple  jobs.
 occur  cyclic order. furthermore,  add .
. copyright . siam.
unauthorized reproduction   article  prohibited.
variable    job  representing  completion.
time,   constraint  serves  lower bound.
  depending   jobs scheduled  . .
order constraints   easily integrated  fixing .
respective variables xij .  objective function results.
.
.
. wjy.
.
 ,   denotes  weight  job .
 quadratic integer program results .
min.
.
.
wjy.
.
.
. . . . xij . xjk . . xik. . . . . , ,  . .
 .  . .
.
xijpi .  .
.
.
. xji. .  . .  . .
xij . .  . .
xij . .  . .
xij . ., .,  . . . .  .  . .
. smith. rule.   companion paper .  give.
 generic tight analysis   worst-case approximation.
factor achieved  smith. rule .  arbitrary convex.
 concave cost functions  various characteristics.
  problem instance. smith. rule orders  jobs.
  decreasing ratio . .  order  evaluate.
also  practical approximation quality  smith.
rule  nonlinear cost settings,  implemented  .
compared  cost   solution   optimal.
solution cost computed  bfgs.
. data set.
 experiments  based  random instances .
  generated using  combination  uniform.
 normal distribution.  random instance generator  configured   three parameters ., pmax, .
parameter    number  jobs   instance, .
parameter pmax specifies  maximum job length, .
. . . represents,   certain degree,  computational difficulty   instance.  length   .
job   chosen   uniform random integer  .
 pmax. note  assuming  minimum processing time   .  without loss  generality. .
   case  monomial cost functions  , .
problem . . . .wjf.  invariant  weight  cost.
scaling.  weight    calculated   .
 .  . . .,.,   ., . means   exponent  chosen according  normal distribution .
mean .  standard deviation .
 plotting  job    point . , . . .,.
figure . gives  impression   instances generated  respect  different values  . look like. .
larger  .-value    jobs  spread around.
. . . . . .
. . .
figure . three instances generated  parameters.
. . ., .  .  job   depicted  point.
. , . . .  respect   processing time  .
 weight  .
 angle bisector. going back   global order constraints depicted  figure ., one gets  intuition.
 . may   important characteristic   difficulty   instance.   jobs lie close   angle.
bisector, ,   fixed job,     jobs lie.
  area   known global order constraints .
 applicable.  contrast,   jobs  evenly spread.
  plane,  constraints will fix  relative order  many  job pairs,   ,  allow .
heavily prune  search space.  previous computational experiments . ., ., ., ., processing times.
 weights   generated independently  random  respect  uniform distribution.  results.
 computationally rather simple instances even  .
presence  many jobs.
 run  experiments  five data sets. .
set   used  study  behavior  bfgs  qip.
 respect  increasing .  remaining four set.
 generated  investigate  impact  .  use.
 sets . , . , .  .   analyze bfgs .
basic  townsend lower bound, qip  smith. rule,.
respectively.  parameters  used  generate .
sets  summarized  table .  parameter ranges.
  chosen depending   memory efficiency .
 algorithms,    benefits   different order.
constraints become visible  still  experiments .
 performed   standard .   comparative study.
  algorithms    main purpose,  believe.
 using  individual data set     leads.
   meaningful results.
. experimental results.
regarding  overall performance   different algorithmic approaches  partly observed   effect  kaindl  . .   backward variants .
bfgs generate less nodes  forward variants, see     detailed discussion.  clearly, using.
townsend. lower bound, one outperforms  variants.
utilizing   basic bound.   following discussion,  consider bfgstb   default variant .
. copyright . siam.
unauthorized reproduction   article  prohibited.
set  . pmax . inst. per fixed   . total . inst.
. . ., ., ., . . . , . . . .
. . ., ., ., . . . , . . . .
. . ., ., ., . . . , . . . .
. . ., ., ., . . . , . . . .
 .,.,. . . ,. . . . .
table . parameters  generating  test sets.
bfgs,  also investigate bfgsbb  bfgs.
.
 differing     lower bound   search direction,.
respectively.  qip approach   able  handle.
  instance size  bfgs. however,   .
necessarily mean  integer programming approaches.
 less efficient  general.  purpose   specific.
formulation   usability  order constraints rather.
 efficiency.
 measure  efficiency   combinations .
algorithms  order constraints  terms   number  generated nodes,   measure  independent.
  concrete machine    experiments .
run. recall   global constraint matrix  computed   preprocessing step,   corresponding.
overhead  terms  runtime  negligible.
 main focus   experimental study   .
impact   different constraints  section . .
 behavior   methods described  section . .
 turned ,  correlation parameter .  significant.
  context.  corresponding results  shown.
 figure .  reads  matrix whose columns correspond   different constraint   rows  .
considered algorithms. moreover,  provide results .
 additional computational study investigating  impact   number  jobs . similar    study.
 .,   presented   matrix  plots. see figure .  solution quality smith. rule achieved  .
experiments  visualized  figure .  numerical.
values corresponding   figures ., .  .  given.
  tables ., .  ., respectively.
main observations.   plots  figure .,.
.,  .  make  following observations.
highly correlated instances  generally difficult. .
number  generated nodes always seems  decrease.
 .,    observed   plots  figure .
 first row   figure shows   number .
comparable job pairs typically increases  ., .
partly explains  influence   parameter. however,  performance  algorithms using townsend.
lower bound   performance  qip improves.
 . even   constraints  utilized.
 number  comparable job pairs influences  algorithms.    clear correlation   number .
comparable job pairs   number  nodes generated.
  algorithms.  effect  especially strong, .
considering bfgs without  advanced lower bound.
figure . reads almost   mirrored image  figure .  correlation  less pronounced  qip.
due  additional elaborate techniques utilized within.
 qip solver.
 benefit   .-gap constraint heavily depends .
 parameter .  .-gap constraint performs rather.
bad  general,   particular bad  small . .
  explained  comparing figure .  ., .
one  observe  especially  small .,  .
 high probability   every job almost  .
jobs lie within  .cone.  covered   .-gap.
constraint.
 global weight constraint leads  good  reliable performance.  already observed  mondal.
 sen .   reason  conjecturing.
 global weight constraint.comparing  basic constraint   weight constraint, one clearly sees .
benefit  strengthening  basic constraint  .
weight constraint. see columns . . .  figure .  effectiveness   explained   fact   weight.
constraint allows  compare jobs  similar ratio .
weight  processing time. see figure .  also.
  reason   weight constraint   far .
 efficient constraint  small values  . especially  point clouds   graph search algorithms.
using  constraint   compact,  means.
  performance  reliable.
 effectiveness   decomposition constraint .
 high variance.   fifth column  figure .
one  see  two types  clusterings  present.
  plots   decomposition constraint. one.
observation    number  comparable jobs .
typically either small  large,  also  performance.
  algorithms  either rather good  rather bad. .
explanation   effect   recursive nature  .
constraint. whenever  problem   sucessfully.
decomposed  two subproblems,  seems   .
high probability   subproblems   .
decomposed.  particular, many   low correlation.
instances   almost completely decomposed.
  type  clustering  along certain horizontal lines.  points   lines correspond  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
instances    decomposed  . .
  instance splits   set   jobs   processed first  another set  size .   processed.
thereafter,  immediately results   . . . . comparable pairs  jobs, corresponding   horizontal line.
 exactly  height.
combining  constraints yields  best results. .
combined constrained  course profits   advantages    constraints,  hence,   best. .
small .,  good performance comes   weight.
constraint,   large .  additionally benefits .
 decomposition.
 weight constraint turns back  advantage  backward search. comparing  number  generated nodes.
 backward  forward search  table . .  .,.
one  observe   particular   harder instances  small values  .   settings .
bfgstb generates  hundred thousands nodes less.
  bfgstf .   also  observed  kaindl.
 . .
however,  soon  one utilizes  weight constraint,  effect reverses  forward search  slightly.
better   settings  . finding  theoretical explanation   observation remains  open question.
 effects   constraints  also observed .
 number  jobs varies.  order  investigate.
 asymptotic behavior   algorithms,  series .
tests   run  instances  fixed . . . .
varying number  jobs. see figure . also   turns.
   weight constraint leads  good  stable.
results,    improved   decomposition.
  instances.
 solution quality  smith. rule  almost optimal.  study  smith. rule  motivated  .
theoretical analysis   approximation guarantee .
problem . . . .wjf. .   companion paper ., .
show  tight approximation guarantee  fixed convex.
cost functions. additionally,  give   realistic.
analysis  parametrized   minimum  maximum processing time   job   total processing time.   study,  investigate  optimality.
gap  smith. rule   cost functions ., ., .
 .   theoretical worst case analysis  know.
 smith. rule   tight approximation guarantee.
 ., ., .  .   functions, respectively.  regard   expected total processing.
time   generated instances,  parametrized analysis reduces  factors  ., ., .  .
however,  results  figure . show  even .
 small expected upper bounds   overestimate.
  outcome   actual cost.  surprisingly, even.
though  optimality gap   small   considered monomials, one still sees  approximation ratio.
 less good  higher degree cost functions.
. conclusion.
 experimental study  demonstrated  global.
order constraints   great influence   performance  exact algorithms  problem . . . .wjc. .
   observed   algorithms  consideration.   also turned   problem instances.
 highly correlated weight  processing time .
  difficult ones.  observation   made.
  combinations  algorithms  constraints. .
 challenge  now  construct efficient algorithms.
also  highly correlated instances. interestingly,  .
also  perfectly correlated instances  smith. rule.
reaches  worst case approximation ratio,   analysis  . shows.
  two major directions  future research,.
 design  efficient linear integer programming .
formulation  quadratic cost functions,  .
general, efficient solution methods  higher degree cost.
functions. concerning  former,    number.
 possible formulations   general, will benefit.
  state-of-the-art  solvers  much better.
developed   quadratic counterparts. however,.
   aware    formulation  order.
constraints   integrated  easily    qip.
formulation.
compared  quadratic cost,  case  higher.
degree cost functions   far less well studied.
townsend. lower bound   directly applicable ,.
 qip formulation   generalized,  also.
 set  known order constraints  much smaller. although experiments  many instances make  believe   global weight constraint holds   convex cost function,    managed  prove .
local weight constraint   generality.
</doc>
<doc title='023.txt'>
user-constrained multi-modal route planning.
julian dibbelt. thomas pajor. dorothea wagner.
abstract.
  multi-modal route planning problem  .
given multiple transportation networks . ., pedestrian, road, public transit.  ask   best integrated.
journey  two points.  main challenge  .
 seemingly optimal journey may  changes .
networks    reflect  user. modal preferences.  fact, quickly computing reasonable multimodal routes remains  challenging problem. previous.
approaches either suffer  poor query performance.
  available choices  modal preferences .
query time  limited.   work  focus  computing exact multi-modal journeys    restricted.
 specifying arbitrary modal sequences  query time.
 example,  user  say whether  wants  .
use public transit,  also prefers  use  taxi  walking.
  beginning  end   journey.     .
restrictions  .  carefully adapting node contraction,  common ingredient  many speedup techniques.
 road networks,   able  compute point-to-point.
queries   continental network combined  cars, railroads  flights several orders  magnitude faster .
dijkstra. algorithm. thereby,  require little space.
overhead  obtain fast preprocessing times.
. introduction.
research  route-planning algorithms  transportation networks  undergone  rapid development .
 last years. see .   overview. usually  network  modeled   directed graph .  dijkstra.
algorithm   used  compute  best route .
two nodes    almost linear time .,    slow.
 practical applications  real-world transportation.
networks.  consist  several million nodes .
edges,   expect almost instant results. thus, .
 years  multitude  speedup techniques  dijkstra. algorithm  developed,  following  similar.
paradigm.   preprocessing phase auxiliary data .
computed    used  accelerate dijkstra.
algorithm   query phase.  fastest techniques.
.partially supported  dfg grant  .
.karlsruhe institute  technology, dibbelt.kit.edu.
.karlsruhe institute  technology, pajor.kit.edu.
.karlsruhe inst.  technology, dorothea.wagner.kit.edu.
today  answer  single query within    memory accesses . however,    techniques .
developed  one type  transportation network .
mind.  fact,  fastest techniques developed  road.
networks heavily rely  structural properties  .
  performance degrades significantly  .
networks ., .
  real-world  different modes  travel .
linked extensively,  realistic transportation scenarios.
imply frequent modal changes. even  , .
 emergence  electric vehicles   inherent.
range restrictions,  choice  taking  car .
public transit will become  important.  solve.
 scenarios   interested   integrated system.
  handle multiple transportation networks .
 single algorithm. thereby   crucial  respect .
user. modal preferences.  every mode  transport.
might  feasible     point along  journey.
 general,  user  restrictions   sequence .
transport modes.  example,  users might .
willing  take  taxi  two train rides   makes.
 journey quicker. others prefer  use public transit.
  stretch.  realistic multi-modal route-planning.
system must handle  constraints   user input.
  query.
related work.   overview  unimodal.
speedup techniques,  direct  reader  ., . .
techniques  composed   following ingredients.
bidirectional search, goal-directed search ., ., .,.
., hierarchical techniques ., ., ., ., ., .
separator-based techniques ., ., . combinations.
  studied ., . regarding multi-modal.
route planning less work exists.  elegant approach.
 restricting modal transfers   label constrained.
shortest paths problem .lcspp. . edges  labeled,.
  sequence  edge labels must  element  .
formal language .passed  query input.   feasible.
path.  version  dijkstra. algorithm   used,.
  language  regular ., .  experimental.
study   approach, including basic goal-directed.
techniques,  conducted  .  .   concluded.
 augmenting preprocessing techniques  lcspp.
  challenging task.  first efficient multi-modal.
speedup technique, called access-node routing .anr.,.
  proposed  .  skips  road network.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 queries  precomputing distances  every.
road node    relevant access points   public.
transportation network.    fastest query times.
  previous multi-modal techniques   .
 order  milliseconds. however,  preprocessing.
phase predetermines  modal constraints   .
used  queries. also,   compute short-range.
queries  requires  separate algorithm  handle.
 correctly. another approach adapts alt .
precomputing different node potentials depending .
 mode  transport, called sdalt .   fast.
preprocessing,   preprocessing space  query.
times  high,   also  handle arbitrary.
modal restrictions  query input.
 contribution.   work  present.
ucch,  first multi-modal speedup technique .
handles arbitrary mode-sequence constraints  input.
  query. feature unavailable  previous techniques. unlike access-node routing,  also answers.
local queries correctly  requires significantly less preprocessing effort.  revisit one technique, namely node.
contraction,   proven successful  road networks.
  form  contraction hierarchies, introduced .
geisberger  . .  ensuring  shortcuts never.
span multiple modes  transport,  extend contraction hierarchies   sound manner. moreover,  show.
 careful engineering  helps  scenario. .
experimental study shows , unlike previous techniques,   handle  intercontinental instance composed  cars, railways  flights   . million nodes, . million edges,  . thousand stations.
  . mib  data,  achieve query times .
 fast enough  interactive scenarios.
 work  organized  follows. section . sets.
necessary notation, summarizes graph models  use,.
precisely defines  problem   solving,  also recaps contraction hierarchies. section . introduces .
new technique. finally, section . presents experiments.
 evaluate  algorithm,  section . concludes .
work  mentions interesting open problems.
. preliminaries.
throughout  work  . .,.   directed graph.
    set  nodes   .  .   set .
edges.   edge ., . . ,  call   tail  .
 head   edge.  reverse graph.
.
 . .,.
.
 .
   obtained    flipping  edges, . .,.
., . .  iff ., . . . . note   use  terms.
graph  network interchangeably.
 distinct  different modes  transport,.
 graphs  labeled  node labels lbl .  . . .
edge labels lbl .  . . often .  called  alphabet.
 contains  available modes  transport  , .
example, road, rail, flight.
 edges   graphs  weighted  periodic.
time-dependent travel time functions  . . . .
 . depicts  set  time points .think   .
 seconds   day.    constant  ., .
call  time-independent. respecting periodicity  .
meaningful way,  say   function    fifo.
property    ., . . .  . . .  holds .
. . . . . . .   words, waiting.
never pays . moreover,  link operation  two.
functions ., .  defined  . . . .,.
  merge operation min., .  defined  .
element-wise minimum  .  . note   depict.
 travel time function .   edge  . , .
sometimes write len., .,  just len.    clear.
  context  len., .  constant.
 time-dependent graphs   two types .
queries relevant   work.  time-query   input.
 .    departure time . .  computes  shortest.
path tree  every node  .   departing   .
time . .  contrast,  profile-query computes  shortest.
path graph      .  , consisting  shortest.
paths   departure times . . .
whenever appropriate,  use  notion  formal languages.  finite sequence  . . . . . . .
symbols . . .  called  word.   necessarily finite set  words   called formal language . .
 nondeterministic finite automaton .nfa.   tuple.
 . .,., ., ,  . characterized   set   states,.
 transition relation . . . .,  sets  . .
 initial states   .   final states.  language.
  called regular iff  exists  finite automaton .
   accepts .
. models. following .,  multi-modal graphs.
 composed  different models   mode .
transportation.  briefly introduce  model .
explain    combined.
  road network, nodes model intersections .
edges depict street segments.  either label edges.
 car  roads  foot  pedestrians.  road.
networks  weighted   average travel time  .
street segment.  pedestrians  assume  walking.
speed  . kph. note   road networks .
time-independent. regarding  railway network, .
use  realistic time-dependent model .  consists.
 station nodes connected  route nodes. trains.
 modeled  route nodes via time-dependent.
edges.  station nodes  interconnected  timeindependent foot paths. see .  details. .
label nodes  edges  rail. note   also.
use  model  bus networks. finally,  model.
. copyright . siam.
unauthorized reproduction   article  prohibited.
flight networks,  use  time-dependent phase .
model .   small size  models airport.
procedures realistically. nodes  edges  labeled.
 flight. note   travel time functions  .
networks   special form  piecewise linear functions.
   efficiently evaluated ., . also  edges.
  networks   fifo property.
merging  networks.  obtain  integrated.
multi-modal network  . .,.,  merge  node.
 edge sets   individual network. detailed.
data  transfers  modes  transport  .
available  . thus,  heuristically add link edges.
labeled link.  precisely,  link  station node.
  railway network   geographically closest node.
  road network.  also link  airport node.
  flight network   closest nodes   road.
 rail networks. thereby   link nodes .
    distance . apart,  parameter chosen.
  instance.  time  traverse  link edges .
computed   geographical length   walking.
speed  . kph.
. path constraints   sequences .
transport modes. since  . approach  using.
dijkstra. algorithm   combined network  .
 incorporate modal constraints,  consider  label constrained shortest path problem .lcspp. .
 edge  .    label lbl. assigned  . .
goal   compute  shortest s-t-path    word.
. . formed  concatenating  edge labels along .
 element   language ,  query input.
modeling sequence constraints  done  specifying.
.   case, regular languages   following.
form suffice.  alphabet . consists   available.
transport modes.   corresponding nfa , states.
depict one   transport modes.  model traveling.
within one transport mode,  require ., ., . . .
  transport modes . . .   represents.
moreover,  allow transfers  different modes .
transport, states , . . ,  . .  connected  link.
labels, . ., ., link, . . . finally, states  marked.
 initial.final   modes  transport   used .
 beginning.end   journey. example automata.
 shown  figure .
 refer   variant  lcspp  lcspp-ms.
.  modal sequences.  general, lcspp  solvable.
 polynomial time,    context-free.   case, .
generalization  dijsktra. algorithm works .
. contraction hierarchies .  algorithm  based  contraction hierarchies . preprocessing works  heuristically ordering  nodes  .
graph   importance value . linear combination .
link link.
foot rail foot.
. foot-and-rail.
foot.
car.
foot.
car.
rail railflight.
. hierarchical.
figure . two example automata.   bottom figure,.
light edges  labeled  link.
edge expansion, number  contracted neighbors, among.
others. ,  nodes  contracted  order  ascending importance.  contract  node  .  ,  .
removed  ,  shortcuts  added  .
neighbors  preserve distances   remaining.
nodes.  index      removed  denoted  rank.  determine   shortcut .,. .
added,  local search    run .without looking .
.,    settled.  len.,. . len., .len., .,.
 shortcut .,.   added,   corresponding.
shorter path  called  witness.
  query   bidirectional dijkstra search operating  , augmented   shortcuts computed.
 preprocessing.  searches .forward  backward.  .upward.   hierarchy.  forward search.
 visits edges ., .  rank. . rank., .
 backward search  visits edges  rank. .
rank. nodes   searches meet represent candidate shortest paths  combined length .  algorithm minimizes .,   search  stop  soon.
  minimum key   priority queue exceeds .
 acceleration techniques,   stalling-ondemand .,   applied.
partial hierarchy.   preprocessing  aborted.
prematurely, . .,   nodes  contracted,  obtain  partial hierarchy .pch.  rank. . iff  .
never contracted,    query algorithm  .
contraction hierarchies  applicable  yields correct.
results.  call  subgraph   uncontracted nodes.
 core,   remaining .contracted. subgraph .
component. note    core   component.
 contain shortcuts  present   original graph.
. copyright . siam.
unauthorized reproduction   article  prohibited.
performance.  preprocessing  query performance   depend   number  shortcuts.
added.  works well   network   pronounced hierarchy, . ., far journeys eventually converge   .freeway subnetwork.     small fraction  size.
compared   total graph . note   computing  complete hierarchy produces  many shortcuts,.
one  always abort early  compute  partial hierarchy.  possible stopping criterion   maximum.
node degree encountered   contraction process.
.  approach.
 now introduce  basic approach  show .
   used  compute shortest path  restrictions  sequences  transport modes.  first argue  applying    combined multi-modal.
graph  without careful consideration either yields incorrect results  lcspp-ms  predetermines  automaton   preprocessing.   introduce.
ucch.  practical adaption  contraction hierarchies.
 lcspp-ms  enables arbitrary modal sequence.
constraints  query input.  improvements .
help accelerating  preprocessing  queries .
presented  section .
. contraction hierarchies  multi-modal.
networks.   . .,.   multi-modal network.
recall     combination  time-independent.
 time-dependent networks . example,  road .
rail., hence, contains edges   constants .
travel time functions associated  . applying    already requires  engineering effort.
shortcuts may represent paths containing edges  different type.  order  compute  shortcuts. travel time.
functions,  edges    linked, resulting  inhomogeneous functions  slow   preprocessing  query performance.  significantly,  .
path  . ., . . . , .  composed   single shortcut.
edge .,  labels need   concatenated   super.
label lbl. . lbl. . . . lbl.  particular,  .
 subsequent edges ,     lbl. . lbl.,.
 shortcut induces  modal transfer. running  query.
  particular mode change  prohibited potentially yields incorrect results.  shortcut must .
 used   label constrained path . .  one.
without  transfer. may   discarded .
preprocessing   witness search .see section .
note   partial time-dependent nature    complicates things.  shortcut . . ., . needs.
 represent  travel-time profile    ,  ,.
 underlying path  depends   time  day. .
 consequence,  super label  .  time-dependent.
 well.
  automaton   known  preprocessing,.
  modify  preprocessing  yield correct query.
results  respect toa.  contracting node  . .
 thereby considering  add  shortcut . . .,.,.
 look   super label lbl. . .lbl., . . . , lblk. .
determine  .    inserted,  run multiple.
witness searches  follows.   state  .  .
 represents lbl.,  run  multi-modal profile-search.
  .ignoring .  run     initial state.
   states . .   final state,  . .
reachable      applying lbl.   .
  profile-searches dist. . len. holds, .
shortcut .   required.  every relevant transition.
sequence   automaton,    shorter path .
 graph. note  shortcuts . . .,. may .
required even   edge     already existed.
 contraction.  results  parallel edges .
different subsequences   constraint automaton.
 approach   call state-dependent.
 .sdch.   disadvantages, however. first,.
witness search  slow  less effective    unimodal scenario, resulting  many  shortcuts. .
hurts preprocessing  query performance. adding .
   complicated data structures required  inhomogeneous travel time functions  arbitrary label.
sequences, sdch combines challenges   flexible  .  timetable  .   result  expect  significant slowdown  unimodal   road.
networks.   notably, sdch predetermines .
automaton   preprocessing.
. ucch. contraction  user-constrained.
route planning.  now introduce userconstrained contraction hierarchies .ucch. unlike.
sdch,   handle arbitrary sequence constraint.
automata  query    easier witness.
search.  first turn toward preprocessing  .
  detail   query algorithm.
preprocessing.  main reason behind  disadvantages discussed  section .   computation  shortcuts  span  boundaries  different.
modal networks. instead,  .   alphabet  labels   multi-modal graph .  now process .
subnetwork independently.  compute.  particular order. partial contraction hierarchy restricted.
  subgraph glbl . .vlbl, elbl. . every lbl . .
, glbl  exactly  original graph   particular transportation mode . merging.  keep .
contraction order   exception  transfer nodes.
nodes   incident   least one edge labeled.
link  .  fix  rank    nodes  .
rank. . ., . .,   never contracted. note.
   nodes   incident edges labeled .
. copyright . siam.
unauthorized reproduction   article  prohibited.
lbl  .   result, shortcuts  span edges within.
one modal network. hence,  neither obtain inhomogeneous travel time functions  .mixed. super labels.
 set  label   shortcut edge .  lbl., .
   arbitrary edge along  path, . represents.
 determine   shortcut . . .,.  required.
. contracting  node .,  restrict  witness.
search   modal subnetwork glbl  . restricting.
 search space  witness searches   yield.
incorrect query results.   many shortcuts might.
 inserted,   required shortcuts  omitted. .
fact,    common technique  accelerate .
preprocessing . note  broadening  witness.
search beyond network boundaries  prohibitive  .
case.  may find  shorter u-v-path using parts  .
modal networks. however,   path   necessarily.
 witness  one    modes  forbidden .
 query. thus,  must  take   account .
determine  .   dropped.
 preprocessing results   partial hierarchy.
  modal network  .  transfer nodes .
 contracted, thus,   interpreted  staying.
  top   hierarchy. recall   call .
subgraph induced   nodes   rank. . .
core.    added shortcuts,  shortest path.
 every pair  core nodes  also fully contained.
  core.   result,  achieve independence .
 automaton   preprocessing.
 practical variant. contraction  independent.
 every modal network  .   use  combination  partial, full   contraction.  practical variant  contracts time-independent modal networks,  ,  road networks. contracting .
time-dependent networks  much less effective. recall     contract station nodes   .
incident link edges. applying contraction   .
non-station nodes, however, yields  many shortcuts.
.see figure ., . .  also hides information encoded   timetable model .  railway lines.,.
 complicating query algorithms .
query.  query algorithm combines  concept.
  multi-modal dijkstra algorithm  unimodal .
 ,  .   source  target nodes   .
finite automaton wrt. lcspp-ms.  query algorithm.
works  follows. first,  initialize distance values .
 pairs  ., . .  .  infinity.  now run .
bidirectional dijkstra search    .  search.
runs independently  maintains priority queues.
.
.
.
.
  tuples ., .   .    . .
 explain  algorithm   forward search. .
backward search works analogously.  queue.
.
 .
ordered  distance  initialized  ., .  .
initial states    . backward queue  initialized.
. input graph.
. .
.
. graph  contraction.
figure . contracting  route nodes   realistic.
time-dependent rail model .  bottom row .
nodes  station nodes,   top row  route.
nodes contracted   order depicted   labels.
grey edges represent added shortcuts. note  .
shortcuts  required   incorporate different.
transfer times . boarding  exiting vehicles .
different stations.
wrt. final states. whenever  extract  tuple ., .
fromq,  scan  edges  . ., . ing.   edge,.
 look   states .      reached  .
 lbl.  every  pair ., .  check whether.
 distance  improved,  update  queue .
necessary.  use  preprocessed data,  consider .
graph , augmented   shortcuts computed .
preprocessing.  run  aforementioned algorithm,.
  scanning edges   node ,  forward.
search  looks  edges ., .  rank. .
rank. similarly,  backward search  looks .
edges ., .  rank. . rank. note  .
 means  automatically search inside  core.
whenever  reach  top   hierarchy. thereby.
 never reinitialize  data structures  entering.
 core like   typically  case  core-based.
algorithms, . ., core-alt .  stopping criterion.
carries   basic .  search stops  soon .
 minimum key   priority queue exceeds  best.
tentative distance value .  also use stall-on-demand,.
however,    component.
intuitively,  search   interpreted  follows.
 simultaneously search upward   hierarchies.
  modal networks   either marked  ini. copyright . siam.
unauthorized reproduction   article  prohibited.
tial   final   automaton .  soon  .
hit  top   hierarchy,  search operates  .
common core.   always find correct shortest.
paths  core nodes   modal network, .
algorithm supports arbitrary automata .wrt. lcsppms.  query input. note   algorithm implicitly.
computes local queries  use  one   networks.  makes  use   separate algorithm .
local queries,   ., unnecessary.
handling time-dependency.    networks    time-dependent. weights  timedependent edges ., .  evaluated   departure.
time . . however, running  reverse search   timedependent network  non-trivial, since  arrival time.
  target node   known  advance. several.
approaches,   using  lower-bound graph .
 reverse search, exist ., .,   complicate .
query algorithm. recall    practical variant .
  contract    time-dependent networks,.
hence,  time-dependent edges  contained  .
component.  makes backward search   component easy  .  discuss search   core  .
next section.
. improvements.  now present several improvements   algorithm,    also apply  . recall  whenever  contract  modal.
network,  never contract transfer nodes, even  .
  low importance   context   network.
  result,  number  added shortcuts may increase.
significantly. thus,  stop  contraction process .
soon   maximum node degree exceeds  value . .
varying .,  trade   number  core nodes .
 number  core edges. higher values  . produce .
smaller core    shortcut edges.  evaluate.
 good value  . experimentally.
due   higher average node degree compared .
unimodal ,  search algorithm   look  .
edges. thus,  improve performance  iterating .
incident edges   node   reordering  locally.
 .  first arrange  outgoing edges, followed .
 bidirected edges,  finally,  incoming edges. .
 means,  forward respective backward search.
 needs  look   relevant subsets  edges  .
  optimization  applied   stalling routine.
preliminary experiments revealed  edge reordering.
improves query performance   . .
 improve  cache hit rate   query algorithm,  also reorder nodes   adjacent nodes.
 stored consecutively  high probability.  use .
dfs-like algorithm  determine  ordering .     time  spent   core,  also.
move core nodes   front.  improves query performance    factor  .
recall   search stops  soon   minimum.
key   priority queue exceeds  best tentative.
distance value .   conservative,  necessary.
  . ucch.   correct. however, ucch.
spends  large fraction   search inside  core. .
 easily expand road  transfer edges  forward.
 backward,     conservative stopping.
criterion, many core nodes  settled twice.  reduce.
 amount,    scan edges  core nodes ,.
    settled   searches   .
improve .  path    provably  optimal.
 increases performance    . . another.
alternative   applying bidirectional search  .
core  .  forward search continues regularly,.
  backward search   scan edges incident.
 core nodes.  approach turns   effective.
  performance increase   factor  .
finally, automata  used  model sequence constraints, however,  definition  state may .
change  traversing link edges.  particular, .
searching inside  component,   never  state.
transition .recall   link edges  inside  core.
thus,  use  automaton    core.  start.
  regular unimodal ch-query. whenever  .
  insert  core node    priority  .
first time   branch   shortest path tree,  create labels ., .   initial.final states  .regarding.
forward.backward search.   amount  settled component nodes  average  small compared .
 total search space,    observe  performance.
gain. however,  large instances  complicated.
query automata  save several gigabytes  ram  query  keeping  one distance value  .
component node. recall  component nodes constitute  major fraction   graph.
combining  improvements yields  speedup  .
 factor . .see appendix   detailed figures.
. experiments.
 conducted  experiments  one core   intel.
xeon . processor running suse linux .  .
clocked  . ghz,  . gib  ram  . mib .
. cache.  program  compiled  gcc .,.
using optimization level .  implementation .
written  . using  stl  boost  .
points.   priority queue  use  .-ary heap.
 assemble  total  six multi-modal networks.
 two  imported  .  size figures .
reported  table .  ny-road-rail,  combine.
new york. foot network   public transit network.
operated  mta .  link bus  subway.
stops  road intersections     .
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . comparing size figures   input instances.  bottom two instances  taken  .
public transportation road.
network stations connections nodes edges density.
ny-road-rail . . . . . . . . . . . . .
de-road-rail . . . . . . . . . . . . .
europe-road-rail . . . . . . . . . . . . . . .
wo-road-rail-flight . . . . . . . . . . . . . . .
de-road-rail.long. . . . . . . . . . . . . .
wo-road-flight . . . . . . . . . . . . . .
.  apart.  de-road-rail network combines.
 pedestrian  railway networks  germany. .
railway network  extracted   timetable  .
winter period .  includes short  long.
distance trains,   link stations using  radius.
 . .  europe-road-rail network combines.
 road .  car.  railway networks  western.
europe.  railway network  extracted  .
timetable   winter period .  stations.
 linked within . .  wo-road-rail-flight.
network   combination   road networks .
north america  western europe   railway.
network  western europe   flight network .
star alliance  one world.  flight networks.
 extracted   winter timetable . .
radius  use . .  de-road-rail.long. .
wo-road-flight stem  .  data  .
western european  north american road networks.
.thus germany  new york.  kindly provided .
  ptv  .  scientific use.  timetable.
data  new york  publicly available  general.
transit feeds .,   data   german .
european railway networks  kindly provided .
hacon .  instances  varying fractional size.
  public transit parts.  call  fraction .
linked nodes   subgraph density .see last column .
table .  densest network  ny-road-rail, .
also   highest number  connections.  .
 hand, de-road-rail.long.  wo-road-flight.
 rather sparse. however,  include   compare.
 algorithm  access node routing .anr.
 use  following automata  query input. .
foot-and-rail automaton allows either walking, .
walking, taking  railway network  walking .
similarly,  car-and-rail automaton uses  road.
network instead  walking,   car-and-flight.
automaton uses  flight network instead   railway network.  hierarchical automaton  .
 complicated automaton.  hierarchically combines road, railways  flights .  order. .
modal sequences  possible, except  going   .
hierarchy   stepping .  example,  one.
takes  train   flight,   impossible  take another flight. finally,  everything automaton allows.
arbitrary modal sequences   order. see figure . .
transition graphs  foot-and-rail  hierarchical.
 evaluate  preprocessing  query performance.  contraction order  always computed according   aggressive variant  .  report.
 time   amount  computed auxiliary data.
queries  generated  source, target nodes  departure times uniformly picked  random.  dijkstra.
 run . . queries,   ucch  run  superset  . . . queries.  report  average number.
. . nodes extracted   priority queue .settled.
nodes., . priority queue update operations .relaxed.
edges., . touched edges, .  average query time,.
 .  speedup  dijkstra. note   .
report  time  compute  length   shortest.
path. unpacking  shortcuts   done efficiently .
less   millisecond .
evaluating maximum degree limit.  experiment evaluates preprocessing performance .
varying maximum degree .  abort contraction .
 node  degree greater  . table . shows preprocessing  query figures  de-road-rail.  use .
automaton    use public transit edges. .
higher values  .  nodes  contracted, resulting.
 higher preprocessing time   shortcuts . report    fraction   input. size.   .
time, less nodes .  higher degree. remain  .
core. setting . .  infeasible.  amount  shortcuts explodes,  preprocessing   finish within.
reasonable time. interestingly,  query time decreases.
. smaller core size.   . . .   increases.
. though  settle less nodes,  increase .
shortcuts results   touched edges  query,.
 , edges  algorithm   iterate  settling.
 node.  conclude   de-road-rail  tradeoff  number  core nodes  added shortcut.
edges  optimal  . . ., hence,  use  value .
subsequent experiments. accordingly,  determine .
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . comparing preprocessing performance  ucch  de-road-rail  varying maximum degree limit.
 queries  use  foot automaton.  also report numbers  unconstrained unimodal .
preprocessing query.
max core- avg core- shortcut- time settled relaxed touched time.
degree nodes degree edges .min. nodes edges edges .
ucch.
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
pch . . . . . . . . . . . . . .
pch . . . . . . . . . . . . . .
 . . . . . . . . . . . .
   instances. note  .  little effect .
 total number  shortcuts,  preprocessing time.
increases  factor .  query times vary   . .
comparison  unimodal .  table . .
also compare ucch    run   unimodal.
road network. computing  full hierarchy results .
 maximum degree  .,  query times  .
 factor . faster. since ucch   compute .
full hierarchy  design,  evaluate two partial .
hierarchies.  first stops   core reaches  size.
 . .equivalent   optimal core size  ucch.
 observe  query performance almost comparable .
ucch .slightly faster  . .  second partial.
hierarchy stops   core size  . .  .
equal   number  transfer nodes   network.
. .,  smallest possible core size   instance.
 ucch. ,    factor  . faster .
ucch. recall  ucch must  contract transfer.
nodes.  road networks   usually unimportant.
long-range queries   pass many railway stations.
 bus stops  general,  explains  ucch.
hierarchy  less pronounced. however,  multi-modal.
queries transfer nodes  indeed  important, .
 constitute  interchange points  different.
networks.  enable arbitrary automata  query,.
 overestimate  importance   contracting.
  ,   reflected   .relatively small.
difference  performance compared  .
preprocessing. table . shows preprocessing figures  ucch    instances. besides  maximum degree,  evaluate  core  terms  total .
fractional number  core nodes,  average degree .
 amount  added shortcuts. added shortcuts  reported  percentage   road edges   total mib.
 observe   preprocessing effort correlates .
 graph size.   small ny-road-rail instance .
takes less   minute  produces . mib  data. .
 largest instance, wo-road-rail-flight,  need.
. hours  produce . mib  data. note    size   core depends   size  .
public transportation network,  obtain  much higher.
ratio  core nodes  ny-road-rail . . .   ,.
 example,  wo-road-rail-flight . . . .
comparing  preprocessing effort  ucch .
scaled figures  anr,  observe  ucch  twice.
 fast  produces significantly less amount  data.
 de-road-rail.long.   factor  .,  .
wo-road-flight, anr requires . gib  space. ,.
ucch  uses . mib,  factor  . concluding,.
ucch outperforms anr  terms  preprocessing.
space  time.
query performance.   experiment  evaluate  query performance  ucch  compare  .
dijkstra  anr . applicable. figures  presented  table .  observe   achieve speedups.
 several orders  magnitude  dijkstra, depending   instance. generally, ucch. speedup .
dijkstra correlates   ratio  core nodes  preprocessing .thus, indirectly   density  transfer.
nodes.  sparser  networks  interconnected,.
 higher  speedups  achieve.   densest.
network, ny-road-rail,    speedup  ., .
 wo-road-flight  achieve query times  less .
 millisecond. speedup   . . note  .
  time  spent inside  core .particularly,  .
public transit network.,     accelerate. appendix  contains  detailed query time distribution.
analysis. comparing ucch  anr,  observe .
query times     order  magnitude, ucch.
 slightly faster. note   achieve  running.
times  significantly less preprocessing effort.
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . preprocessing figures  ucch  access-node routing   road subnetwork. figures   latter.
 taken  .  scale  preprocessing time  respect  running time figures compared  dijkstra.
ucch access-node.
max core nodes avg core- shortcuts shortcuts time space time.
network degree total ratio degree percent .mib. .min. .mib. .min.
ny-road-rail . . . . . . . . . . . . . .
de-road-rail . . . . . . . . . . . . .
europe-road-rail . . . . . . . . . . . . .
wo-road-rail-flight . . . . . . . . . . . . . .
de-road-rail.long. . . . . . . . . . . . . . .
wo-road-flight . . . . . . . . . . . . . .
table . query performance  ucch compared  plain multi-modal dijkstra  access-node routing. figures.
  latter  taken  .  scale  running time  respect  dijkstra.
dijkstra access-node ucch.
settled time settled time speed- settled time speednetwork automaton nodes . nodes .  nodes . .
ny-road-rail foot-and-rail . . . . . . . . . .
de-road-rail foot-and-rail . . . . . . . . . . . .
europe-road-rail car-and-rail . . . . . . . . . . . .
wo-road-rail-flight hierarchical . . . . . . . . . . . .
de-road-rail.long. foot-and-rail . . . . . . . . . . . . .
wo-road-flight car-and-flight . . . . . . . . . . . . . . .
. conclusion.
  work  introduced ucch.  first, fast multimodal speedup technique  handles arbitrary modal.
sequence constraints  query time. problem considered challenging . besides  determining .
modal constraints  preprocessing,  advantages.
 small space overhead, fast preprocessing time .
 ability  implicitly handle local queries without.
 need   separate algorithm.  preprocessing.
 handle huge networks  intercontinental size .
many  stations  airports    previous multi-modal techniques.  future work  .
interested  augmenting  approach   general.
scenarios   profile  multi-criteria queries. .
also like   accelerate search   uncontracted.
core.especially   rail networks. moreover,  .
interested  improve  contraction order.  particular,  like  use ideas  .  enable contraction.
  transfer nodes  order  achieve better results,.
especially   densely interlinked networks.
acknowledgments.  thank daniel delling .
interesting discussions  multi-modal route planning,.
 geisberger  .  providing    code.
</doc>
<doc title='024.txt'>
round-based public transit routing.
daniel delling. thomas pajor. renato . werneck.
abstract.
 study  problem  computing  pareto-optimal.
journeys   dynamic public transit network  two.
criteria. arrival time  number  transfers. existing algorithms consider    graph problem, .
solve  using variants  dijkstra. algorithm. unfortunately,  leads  either high query times  suboptimal solutions.  take  different approach.  introduce raptor,  novel round-based public transit.
router. unlike previous algorithms,    dijkstrabased, looks   route .   bus line.  .
network    per round,    made even.
faster  simple pruning rules  parallelization using multiple cores.     rely  preprocessing, raptor works  fully dynamic scenarios.
moreover,    easily extended  handle flexible.
departure times  arbitrary additional criteria, .
 fare zones.  run  london. complex public.
transportation network, raptor computes  paretooptimal journeys  two random locations  order  magnitude faster  previous approaches, .
easily enables interactive applications.
. introduction.
 study  problem  computing best journeys .
public transit networks.  common approach  solve.
 problem   model  network   graph .
 run  shortest path algorithm   .  first.
glance,   tempting. one  just use dijkstra.
algorithm ., possibly augmented   variety .
speedup techniques  attempt  accelerate queries.
using auxiliary data computed   preprocessing stage.
.see delling  . .   overview. unfortunately,.
  several downsides   approach. although.
known speedup techniques  achieve speedups  .
 several million  road networks .,  fall short.
 applied  public transportation networks .,.
   much different structure.  importantly, unlike  road networks, travel times  usu.microsoft research silicon valley. dadellin.mircosoft.com.
.karlsruhe institute  technology. pajor.kit.edu.  work.
 done   author   microsoft research silicon.
valley.
.microsoft research silicon valley. renatow.microsoft.com.
ally  enough  compute best journeys  public.
transit.  criteria,   number  transfers .
costs,   just  important.   often handled  reporting  pareto-optimal journeys .
two points using augmented versions  dijkstra. algorithm .  increases running times significantly.
 makes acceleration techniques even  complicated ., ., ., ., ., rendering  efficient computation  multi-criteria journeys  elusive goal . moreover,  dynamic nature  public transit systems, .
frequent delays  cancellations, makes preprocessingbased techniques impractical.
 feature shared   previous approaches .
  operate   graph.  complicates exploiting properties specific  transit networks,   .
fact  vehicles operate  predefined lines. one exception   concept  transfer patterns .  .
answer queries extremely fast,   preprocessing effort .thousands  cpu hours.   high  optimality.
must  dropped  order  make  practical.   unclear     used   dynamic scenario.
 work introduces raptor,  novel roundbased public transit optimized router.  two.
given stops,  computes  pareto-optimal journeys.
minimizing  arrival time   number  transfers made. . unlike previous approaches,.
raptor   dijkstra-based. instead,  operates .
rounds, one per transfer,  computes arrival times .
traversing every route .   bus line.   .
per round.  algorithm boils    dynamic program  simple data structures  excellent memory.
locality. unlike dijkstra-based algorithms,  .
notoriously hard  parallelize ., .,  raptor.
  distribute independent routes among multiple.
cpu cores.  also introduce two extensions  raptor.  first, mcraptor, generalizes raptor .
handle  criteria, beyond arrival time  transfers.
  example  use fare zones,  common pricing.
model.  second extension  rraptor.  computes.
bicriteria range queries, outputting full pareto-sets .
journeys   departures within  time range.   algorithms   rely  preprocessing, .
 fully dynamic, easily handling delays, cancellations,.
 route changes. finally,  experiments show .
  full network  london,   . thousand.
. copyright . siam.
unauthorized reproduction   article  prohibited.
stops  . million daily departure events, raptor.
computes  pareto-optimal bicriteria journeys .
two random locations   . .fast enough .
practical use.
 paper  organized  follows. section . .
formal problem definitions  discusses existing solutions   relevant   work. section . introduces.
raptor,  main contribution,  section . shows.
  extend   handle  criteria .mcraptor.
 range queries .rraptor. section . reports experimental results. finally, section .  concluding.
remarks.
. preliminaries.
 algorithms work   timetable .,,  ,,.
 . . .   period  operation .think   .
 seconds   day.,    set  stops,   set  trips,.
  set  routes,    set  transfers . foot-paths.
 stop   corresponds   distinct location  .
network  one  board  get   vehicle .bus,.
tram, train, etc. typical examples  bus stops .
train platforms.  trip  .  represents  sequence.
 stops  specific vehicle .train, bus, subway, . . . . visits.
along  line.   stop   sequence,  may.
drop   pick  passengers. moreover,  stop.
   trip   associated arrival  departure times.
.arr., ., .dep., . . .,  .arr., . . .dep., . .
first  last stops   trip   undefined arrival.
 departure time, respectively.  trips   .
partitioned  routes.  route   consists  .
trips  share   sequence  stops. typically,.
  many  trips  routes. finally, footpaths   model walking connections . transfers.
 stops.  transfer consists  two stops.
.  .   associated constant walking time.
., . note    transitive.  .  . .
indirectly connected  foot-paths, ., .  contained.
   well.
 output produced   journey-planning algorithm   timetable   set  journeys  .  journey.
 defined   sequence  trips  foot-paths  .
order  travel.  addition,  trip   sequence .
associated  two stops, corresponding   pick-up.
 drop-off points. note   journey containing .
trips  exactly . transfers. journeys  associated.
 several optimization criteria.  say  journey .
dominates  journey ., denoted  . . .,  .  .
worse   criterion  .  set  pairwise nondominating journeys   pareto-set.   algorithms.
 use labels .often associated  stops.  intermediate journeys.  definition  domination translates.
 labels naturally.
 simplest problem  consider   earliest.
arrival problem. given  source stop ,  target stop.
,   departure time . ,  asks   journey .
departs   earlier  . ,  arrives    early.
 possible.  multi-criteria problem   generalization    one optimization criterion .always.
including earliest arrival time.  precisely,  asks.
  full pareto-set  journeys,   journey leaving   earlier  . .  example, one journey .
arrive  . .  . transfers,  another one .
. .  . transfers. finally,  range problem.
asks  alternate journeys  varying departure time.
 precisely,  every departure time . . . .
. . .,  ask   journey  leaves   later.
 .  arrives    early  possible.   .
special case   multi-criteria problem using arrival.
 departure time  criteria  domination . . .
iff .dep. . .dep.  .arr. . .arr.
. existing graph-based approaches. previous work  journey planning focused  graph-based.
models,  particular  time-expanded   timedependent approaches .  time-expanded approach models  event   timetable . ., departure  arrival   trip   stop.   separate vertex.
 results  large graphs yielding poor query performance.  contrast,  time-dependent model groups.
trips along edges  time-dependent functions.  general,  size   resulting graph  linear   number  stops  routes,   orders  magnitude.
smaller   number  events.  therefore focus.
   efficient time-dependent model.
 time-dependent route model . creates  stopvertex   stop  . .  addition,  route-vertex .
 created   stop   every route  . ,  .
 serving . edges  added within  stop .
 stop-vertex  every route-vertex . vice versa.
 allow transfers.  constant weights represent .
transfer time . .  trips serving .  model.
trips, time-dependent edges  added  routevertices.  precisely,   trip  .  serves two.
subsequent stops ., . along  route  . ,  edge.
 .  .  required.  edge  time-dependent,.
  function reflects  travel time  .arr., . .
.dep., .  departure time .dep., . edge costs .
 modeled  special piecewise linear functions, .
  efficiently evaluated ., .  incorporate.
foot-paths,   ., . .   time-independent.
edge  added   corresponding stop-vertices,.
weighted  ., .  time-dependent station model.
  condensed version   one vertex per stop,.
combined  time-dependent edges. although  leads.
 smaller graphs,  complicates  query algorithms.
 order  incorporate transfers correctly ., .
. copyright . siam.
unauthorized reproduction   article  prohibited.
algorithms.  solve  earliest arrival problem.
  source stop   time .   time-dependent.
model,   use  augmented variant  dijkstra.
algorithm .  scans vertices  increasing arrival.
time,  evaluates  edge  . ., .  time dist.,.
   arrival time  .  algorithm stops .
soon   target stop-vertex  scanned.  refer .
 algorithm  time-dijkstra .
 multi-criteria problem   time-dependent.
route model   solved   multi-label-correcting algorithm .mlc. .  handles arbitrary criteria .
 modeled  edge costs  generalizes dijkstra.
algorithm  follows. labels now contain multiple values, one   optimization criterion.  vertex .
maintains  bag  representing  pareto-set  nondominated labels.  algorithm maintains  priority queue  unprocessed labels, ordered lexicographically.  step extracts  minimum label  .
 queue  processes  corresponding vertex .
 every edge ., .,  new label   created.  .
  dominated   label  ,   inserted .
 .possibly eliminating  labels  .  priority queue  updated accordingly. several improvements.
 mlc exist . . hopping-reduction avoids propagating  label back   vertex  originated .
. label-forwarding   use  priority queue .
new labels    increase  cost.  . targetpruning eliminates labels    dominated  .
label   target vertex. bag.    use goaldirection  mlc. although helpful  long-distance.
rail networks .,    help  dense urban networks . even   improvements, mlc  much.
 costly  plain time-dijsktra.   must .
scan   vertex multiple times,   also  .
handle  complicated data structures,   bags.
   additional criterion .besides arrival.
time.  number  transfers, one  use  simpler.
layered dijkstra . algorithm .  works .
values   second criterion  discrete.  .
example,     bound   number  transfers.
 preprocessing,  graph  copied   layers,.
 transfer edges rewired  point   layer directly.
. running time-dijkstra   source vertex.
  bottom layer results    .   .
journey  exactly  transfers  vertices  layer.
. instead  copying  graph,   use  array .
 labels   vertex  read.write  . entry .
.layer. . moreover,  implement domination,  label.
 vertex   layer    pruned,   exists .
label  earlier arrival time     layer smaller.
 . similarly,  label   pruned   target.
vertex   label  smaller arrival time   layer.
. .   drop  requirement   bound .
 input  dynamically extending  labels whenever.
necessary.
 known efficient solution   range problem   self-pruning connection-setting algorithm.
.spcs. .  first assembles  departing trips  .
,  initializes  priority queue    trips,.
using  arrival times  keys.  search algorithm.
  similar  ,  additional pruning.  .
label   extracted   queue  vertex ,   .
pruned    already  scanned   label . .
 .dep.
. . .dep. holds. target pruning  .
incorporated  keeping track   maximum departure time   journey  reached  target. .
journey   later departure time .anywhere  .
graph.    pruned.  multi-core version  .
algorithm partitions  departing trips   among .
available cores,   run spcs independently. .
 end,  resulting journeys  merged,  dominated ones discarded.
.  approach. raptor.
 now introduce  basic version  raptor, .
algorithm.  solves  bicriteria problem minimizing.
arrival time  number  transfers.like   mlc.
however,  method   based  dijkstra. algorithm.  fact,    even need  priority queue.
 start   basic version   algorithm, .
propose  optimizations.   .    source.
stop,  . . .  departure time. recall  .
goal   compute  every   nondominated journey.
  target stop   minimum arrival time .
   trips.
 algorithm works  rounds. round  computes.
 fastest way  getting  every stop   .
 . . transfers . .,  taking    trips. note.
  stops may   reachable  . .
explain  algorithm,  bound  number  rounds.
 . . show   bound   dropped.
later.  precisely,  algorithm associates .
 stop   multilabel ., ., . . . , ., .
. represents  earliest known arrival time   .
   trips.  values   labels  initialized .
.   set . . . .  maintain  following.
invariant.   beginning  round  .  . ., .
first  entries  . . .  .  correct,.
. ., entry . represents  earliest arrival time  .
using    trips.  remaining entries  set .
.  goal  round    compute .   . .
   three stages.
 first stage  round  sets . . . .
 stops .  sets  upper bound   earliest.
arrival time       trips.
 second stage  processes  route  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
figure . scanning routes   query    . route .  first scanned  round ., routes .  . .
round .,  finally, route .  round . scanning  route begins   earliest marked stop .bold. hollow.
stops  never visited.
timetable exactly . consider  route ,  .
 . . ., ., . . . , . .   sequence  trips.
 follow route ,  earliest  latest. .
processing route ,  consider journeys   last.
. trip taken   route .  ., .   earliest.
trip  route   one  catch  stop , . ., .
earliest trip    .dep., . . . .note.
  trip may  exist,   case ., . .
undefined.  process  route,  visit  stops.
 order   find  stop    ., . .
defined.      .hop .  route. .
 corresponding trip    current trip  . .
keep traversing  route.   subsequent stop  ,.
  update . using  trip.  reconstruct .
journey,  set  parent pointer   stop   .
 boarded. moreover,  may need  update .
current trip  .   stop  along   may .
possible  catch  earlier trip .  quicker path.
    found   previous round. thus, .
  check  . . .arr., .  update  .
recomputing ., .
finally,  third stage  round  considers footpaths.   foot-path ., . .   sets . .
min., . . ., . note  since  .
transitive,  always find  fastest walking path, .
one exists.  algorithm   stopped  round.
,   label .  improved. also note   .
dynamically extend  multilabels beyond  items.
 worst-case running time   algorithm .
 bounded  follows.  every round,  scan .
route  .    .  .   number.
 stops along ,   look .
.
. . stops .
total. caching ., .,  look  every trip   .
route   , since ., .   decrease .
scanning  route. thus,  total running time .
 algorithm  linear per round.  total,  takes.
. . . time, wherek   number.
 rounds. constant access   stops along routes.
  arrival  departure times  specific trips.
  achieved    arrays .see appendix  .
details.  contrast,  similar analysis   routebased model reveals  mlc    slower  .
least  logarithmic factor, due   priority queues.
. improvements.  set   basic version.
  algorithm,  now propose  optimizations.
iterating   routes  every round seems wasteful. indeed,    need  traverse routes    reached   previous round, since   .
way  .hop .     trips.  precisely,  round ,  suffices  traverse  routes  contain  least one stop reached  exactly  . . trips.
 see , consider  route whose last improvement.
happened  round . .  . .  route  visited.
  round . . . . ,   stop along .
route improved.    point  traversing  .
  least one   stops improves .due  .
 route.  implement  improved version .
 algorithm,  mark  round  . .  stops.
    improved  arrival time . .
 beginning  round ,  loop   marked.
stops  find  routes  contain .  routes.
  resulting set   considered  scanning .
round . moreover, since  marked stops  exactly.
   potentially .hop .  trip  round ,.
    traverse  route beginning   earliest.
marked stop  contains.  enable ,  adding.
routes  ,  also remember  earliest marked stop.
  route. see also figure .
another useful technique  local pruning.  .
stop ,  keep  value .
. representing  earliest.
known arrival time  . since    interested .
pareto-optimal paths,   mark  stop  route.
traversal  round    arrival time   trips.
 earlier  . note  local pruning allows.
  drop  first stage .copying  labels  .
previous round., since . automatically keeps track.
  earliest possible time  get  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
note ,  described, raptor   exploit.
 fact     interested  journeys  .
target stop .  fact,  computes journeys  .
stops   network. since  seems wasteful,  use.
target pruning.  round ,    need .
mark stops whose arrival times  greater  .
. best known arrival time  .  description.
 pseudocode including marking  pruning  .
found  algorithm .
. transfer preferences  strict domination. mlc   extended   scenario  one.
 interested  pareto-optimal solutions  respect.
 strict domination. one journey  dominates another    strictly better   least one criterion .
 leads  bigger pareto-sets.  motivation .
 extension stems  outputting journeys  use.
transfers  preferred locations. ,  best journey.
 determined   postprocessing step,  looking  .
possible combinations  transfer locations.
raptor  handle transfer preferences, without.
extending  pareto-set,  follows.  scanning .
route   round   using trip ,  keep track.
  stop .among      boarded.
 maximizes  transfer preference value. ,.
whenever  write  label .,  set  parent.
pointer immediately   stop   maximum.
preference encountered  far.  strict dominance .
still necessary,    incorporated   algorithm.
 well. whenever  write  label ., instead .
keeping  single parent pointer  add pointers  every.
stop .   current trip    boarded, . .,.
  stops .  . . .dep., . held. .
avoid dynamic allocation  every stop,   write.
tuples  parent pointer  arrival time   separate.
log  memory. since parent pointers may change,.
 reconstruct  final parent pointers  linearly.
sweeping   log   postprocessing step.
. parallelization.  algorithm   extended.
 work  parallel.    work  spent processing.
individual routes,   scanned   particular order.  several cpu cores  available,   handle.
 different subset   routes .  round.  round , however, multiple threads may attempt.
 write simultaneously    memory location.
. race conditions   avoided  standard.
synchronization primitives .  locks.,   .
 costly. instead,  propose two lock-free parallelization approaches   algorithm.
  hardware architecture ensures atomic writes.
  values  .,   just .blindly. write .
.  corresponding memory position will always.
algorithm . raptor.
input. source  target stops ,  .
departure time . .
. initialization   algorithm.
. foreach  .
. .
. .
. . .
. mark .
. foreach  . ., ., . . . .
. accumulate routes serving marked.
stops  previous round.
. clear .
. foreach marked stop  .
. foreach route  serving  .
.  ., . .    stop . .
. substitute ., .  ., .    .
comes  .  .
. else.
. add ., .  .
. unmark .
. traverse  route.
. foreach route ., . .  .
. . . .  current trip.
. foreach stop    beginning   .
.   label  improved .
 round. includes local.
 target pruning.
.   . . .
arr., . . min., . .
. . .arr., .
. . .arr., .
. mark .
.   catch  earlier trip.
 .
.  . . .dep., . .
. . ., .
. look  foot-paths.
. foreach marked stop  .
. foreach foot-path ., . .  .
. .
. min., . . ., .
. mark .
. stopping criterion.
.   stops  marked .
. stop.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  valid upper bound   arrival time  , even .
 thread   successfully write  better value. .
restore consistency   route scanning stage, .
thread maintains  log   update attempts  .
value .  logs   used  correct  labels.
  master thread sequentially.   technique.
 also  used  keep . consistent.  call .
approach update log parallelization.
 atomic writes   guaranteed,   still.
avoid locks   conflict graph approach. .
use  fact   two routes    stop.
 common   safely scanned  parallel. .
 preprocessing step,  build  undirected conflict.
graph ,  vertices correspond  routes  .
 edges   two routes  share  least one.
stop.   greedily color  routes    two.
adjacent routes share   color. routes  .
 color  always  processed independently.
 implement  approach efficiently,  order .
routes according   colors . ties broken arbitrarily.  obtain  sequence  . ., ., . . . , .
  compute  every route   dependent route.
pre. .  , defined   highest-indexed conflicting.
route  appears     order . . . .
route scanning stage  now modified  follows. .
 thread finishes scanning  route,  grabs  next .
index order. available unprocessed route   waits.
.  busy loop.   routes   pre.  .
fully processed.   happens,   safely process.
. conflicting routes    .   already .
processed,     .  will wait    finished. threads  use shared memory  communicate.
 others    routes   processed, ensuring  two threads ever write    location.
unmarked routes   skipped  set  processed.
 dynamic scenarios, route dependencies must  updated whenever  route changes,   takes negligible time.
. extensions.
  section  show  raptor   extended.
 handle additional criteria,   fare zones.  call.
 resulting algorithm mcraptor.   special.
case  bicriteria range queries,  present  tailored.
extension called rraptor.
.  criteria. mcraptor. recall .
plain raptor stores exactly one value . per stop.
 round.  extend  algorithm   criteria,.
 keep multiple nondominating labels   stop .
 round , similarly  mlc . section .  store.
 labels  bags, denoted  .
 algorithm   modified  follows. .
relaxing  route ,  first create  empty route bag.
.  label    route bag   associated.
active trip .  traversing  stops   .
order,  process  stop   three steps.  first.
step updates  arrival times  every label  . .
according   associated trips .  . note.
  two labels    associated trip, one.
might  eliminated.   second step,  merge .
 .  copying  labels    ., .
discarding dominated labels  .  final step.
merges .    assigns trips   newly.
added labels. moreover,  foot-paths stage  .
algorithm  also modified.  looking   footpath ., .,  create  temporary copy  . .
add ., .   arrival time  every label.  .
merge  bag  .
  also adapt local  target pruning. similarly  .  raptor,  keep  every stop  .
best bag . .informally.represents  nondominated set  labels   previous rounds. thus,.
whenever     add  label    bag .,.
 check    dominated  .  . .recall.
    target stop.  either   case,   .
added  . otherwise,  also update .
. .
adding   .,  necessary.
like raptor, mcraptor scans routes  .
particular order,  thus,   parallelized  .
 way. however, since updates  .  .
atomic,  must use  conflict graph approach.
 example. fare zones.  now consider .
practical scenario. fare zones. transit agencies often.
assign  stop   one . multiple. fare zones .
 set .  price   journey   determined.
  fare zones  touches. however, handling.
exact prices   algorithm often  complicated.
thus,   interested  computing  pareto-optimal.
journeys including  set  touched fare zones .
 criterion. precise fare information   .
determined   .quick. post-processing step.
 handle  scenario  follows.  label  .
tuple  . ., .,  . .    set .
touched fare zones  far. ,  label . dominates.
. iff . . .  . . . note .
.   cost imposed  stops rather  travel. .
initialize  source bag .   label ., .
moreover,  time     merge  label .
  bag .,  first update . . . . .
 implement . efficiently,  use integers  bit sets.
.one bit per fare zone. domination  tested  bitwiseand,  set-union  equivalent  bitwise-or.
. range queries. rraptor.   special.
case  range queries, raptor   extended .
. copyright . siam.
unauthorized reproduction   article  prohibited.
rraptor similarly  spcs .
 . . .   input time range. first, .
accumulate   set .  departure times  trips .
  source stop   depart within . now, .
run standard raptor  every departure time . . .
independently.  results   label .  every.
stop , departure time . ,  round . however,  .
journeys  .  useful  get  .  precisely,.
 journey . dominates  journey . iff .dep. .
.dep.  .arr. . .arr.
 integrate  domination rule,  order . .
latest  earliest,   run raptor  every . .
.  order. however,  keep  labels . .
rounds instead  reinitializing .  see   .
correct, note   value  . corresponds  .
intermediate journey departing    earlier .
journeys computed   current run .recall  . .
ordered. thus,  .  smaller,  also know  .
reach  earlier. hence,   safely prune  current.
journey. however,   use local pruning, since.
 best arrival times .   carry   earlier.
departures. instead,   beginning  round   set.
. . .   stops  . improves.
.
raptor. parallelization techniques also work .
rraptor. however,  .  larger   number   cpu cores,   use   approach .
 spcs .  partition .  subsets  equal size.
., . . . ,. ,  core  runs rraptor  .
independently.  results  merged   end, .
dominated journeys  discarded.
. experiments.
  section  present  experimental study .
evaluate  algorithms.  main input uses realistic.
data  transport  london .  includes tube.
.subway., buses, tram,  dockland light rail .dlr.
 extracted  tuesday   periodic summer.
schedule  .,   publicly available . .
network  . . stops, . . routes served  . .
trips,   total  . . . distinct departures . trip.
departing   stop. moreover,   . . footpaths   network.  tube  dlr station  also.
assigned  one  . fare zones.  london  tube ticket.
automatically includes  bus ride. thus,  assign.
bus stops   special fare zone   every tube.dlr.
station  also  member .  compare  algorithms.
 existing graph-based techniques,  use  route.
model graph . section .  resulting graph .
. . vertices  . . edges.
 experiments  done   dual .-core intel.
xeon . machine clocked  . ghz,  . gib.
 ddr. ram.  implemented  algorithms .
. . openmp  parallelization.,  compiled.
  microsoft visual . . . bit.  full.
optimization.  evaluate performance,  ran . .
queries  source.target stops  departure time.
selected uniformly  random. results   realistic.
distributions  similar.
raptor.   first set  experiments .
evaluate raptor . section .  compare  .
  mlc . section .,  solve  .
problem.  algorithms  fully optimized. raptor.
makes use  marking, local,  target pruning. .
 pruning enabled.  mlc uses pruning, labelforwarding,  hop-avoidance.  comparison,  also.
report  performance  time-dijkstra ., .
solves  .simpler. earliest arrival problem.  results.
 presented  table .  report  average number.
 visits  label comparisons per stop,  size .
 pareto-sets .number  journeys. output,  .
running time  milliseconds. moreover,  raptor.
 report  average numbers  rounds,  well  .
average number  times  route  relaxed.
 observe ,  average, raptor performs.
. rounds    stop . .,  labels .
 improved.  scans  route . times. .
considering  number  label comparisons per stop,.
 see  raptor, mlc,     .
  factor  . apart. however, raptor strongly.
table . evaluation   base variant  raptor   london instance, compared  time-dijkstra .,.
layered dijkstra .,  multi-label-correcting .mlc. . indicates whether  algorithm  . minimizing.
 number  transfers besides arrival time   .
. relax. . visits . comp. time.
algorithm  . rnd. . route . stop . stop . . .
raptor . . . . . . .
 . . . . . . .
 . . . . . . . .
mlc . . . . . . . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . comparison  several extensions  raptor   london instance .see section .  also include.
 multi-label-correcting .mlc.  self-pruning connection-setting .spcs. algorithms. besides arrival time,.
 criteria  may consider  range ., number  transfers .,  fee zones .
. relax. . visits . comp. time.
algorithm    . rnd. . route . stop . stop . . .
rraptor . . . . . . . . .
mcraptor . . . . . . . . .
mcraptor . . . . . . . . .
mlc . . . . . . . . . .
spcs . . . . . . . . . .
benefits   simpler data structures, better locality,.
 lack   priority queue.   average query.
time  . ,   . times faster  mlc,  .
times faster  . even ,   minimizes.
arrival time .regardless   number  transfers., .
outperformed  raptor.  outputs half  number.
 journeys  twice  amount  time. although.
   accelerated using models yielding smaller.
graphs ., ., .,  models  make multicriteria queries  complicated .
extensions  raptor.  evaluate mcraptor  rraptor . section .  rraptor, .
fix  time range  . hours,  consider two variants.
 mcraptor.  first emulates  two-hour range.
query  using departure time   additional criterion.  second uses fare zones,  discussed  section .  compare  algorithms  mlc .using arrival time, transfers,  fare zones.  spcs .using.
 range  . hours  well. note  spcs   range.
query minimizing  arrival time .regardless  transfers.  results  presented  table . note .
columns  .range.,  .transfers.,   .fare zones.
indicate  criteria  method takes  account.
recall  rraptor repeatedly runs raptor.
.without reinitializing labels.  performance reflects.
.  runs . times  many rounds,  takes . .
 average. using mcraptor  emulate  .
range queries reduces  number  rounds .relative .
rraptor.,  running times triple. ,  profit.
  simpler data structures. mcraptor handles.
bags  labels instead  running  rounds,  .
costly. compared  pure raptor, taking london.
fare zones  account results  . times  reported journeys. using mcraptor,  achieve  running time  . ,  factor  . faster  mlc.
  less   factor  .  raptor . table . unlike raptor, mcraptor also uses costly.
bags.
figure . shows  number  scanned routes per.
round  raptor, rraptor,  mcraptor. .
normalize rraptor. plot   number  calls .
raptor within  query.  algorithms reach .
entire network within  . rounds,   routes.
 scanned. beyond , fewer routes  useful, .
 algorithms begin running dry. mcraptor takes.
longer  converge,  rraptor generally scans less.
routes .per departure time.  raptor, since  .
prune across different departure times.
.
.
.
.
.
round.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . . . . . .
mcraptor.
raptor.
rraptor.
figure . number  relaxed routes per round.
parallelization. table . shows  parallel performance   algorithms. since writes  . .
atomic  raptor,  use update logs. mcraptor  parallelized using conflict graphs. among .
dijkstra-based algorithms,  spcs   parallelized efficiently.  ran  algorithm  one, three,.
six,  . cores, pinning thread   core .
comparing  parallel implementations .table .
  sequential ones .tables .  .,  observe .
slow-down  less  .   algorithms.  .
expected   introduce additional work  .
parallel implementations .see section .  six cores,.
raptor achieves  speedup   . recall .
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . parallel performance  raptor, mcraptor, rraptor,  spcs   multi-core setup.
. core . cores . cores . cores.
. comp. time . comp. time . comp. time . comp. time.
algorithm    . stop . . stop . . stop . . stop .
raptor . . . . . . . . . . .
rraptor . . . . . . . . . . .
mcraptor . . . . . . . . . . .
mcraptor . . . . . . . . . . .
spcs . . . . . . . . . . . .
  parallelize scanning routes,  limits .
speedup due  amdahl. law . makes  . .  .
total sequential running time.  mcraptor.
spends  time   route .due   costly.
manipulation  bags.,   better speedups .
run  parallel . factor  .  either fare zones .
range query emulation. finally, rraptor achieves.
 speedup  .  six cores,   consistent.
 spcs. using . cores hardly pays   .
algorithm. compared  six cores,  additional.
speedup  limited. increased memory contention  .
factor   case.
additional inputs.  now consider three .
test cases. los angeles ., new york ., .
chicago .  generated  instances  general.
transit feeds .gtfs.   publicly available .
 use  extract  august ., . . wednesday.
 timetables consist  . . . . stops,.
. . . routes followed  . . . .
trips,  . . . . . . departure events.
 building  route model graphs,  resulting instances  . . . . vertices .
. . . . edges. unfortunately, footpath data   available   networks, .
 generated synthetic foot-paths   known heuristic ., resulting  . . . . inserted footpaths. since  fare zone data  available  .
networks,    run  multi-criteria algorithms.
 include fare zones. note     .
biggest publicly available gtfs networks   time .
writing,    smaller   london instance.
table . shows  results   relevant algorithms.
 results  consistent   previous experiments. raptor outperforms    mlc.
 every instance.   compute  pareto-optimal.
journeys  two random stops within .  .
los angeles, .   new york,  .  .
chicago. parallelizing raptor shows almost  effect. speedups    factor  .  . cores .
 instances. running rraptor results  query times.
 around .    instances. parallelizing rraptor pays     raptor, though speedups.
 still limited.  best speedup  .  . cores .
achieved  new york. finally,  observe  rraptor  outperforms spcs   factor  .
table . comparison  base raptor, rraptor, , mlc,  spcs   instances.  trailing . .
 algorithm description refers   parallel execution  . cores.
los angeles new york chicago.
. comp. time . comp. time . comp. time.
algorithm   . stop . . stop . . stop .
raptor . . . . . . . .
raptor-. . . . . . . . .
rraptor . . . . . . . .
rraptor-. . . . . . . . .
 . . . . . . . . .
mlc . . . . . . . . .
spcs . . . . . . . . .
spcs-. . . . . . . . . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
. conclusion.
  introduced raptor,  novel algorithm .
fast multi-criteria journey planning  public transit networks. unlike previous algorithms,  neither operates.
  graph  requires  priority queue. instead,  exploits  inherent structure   networks  operating  rounds  processing  route   network.
   per round. experiments   transit.
network  london reveal  raptor   .
 order  magnitude faster  previous approaches.
moreover, raptor   easily parallelized, .
accelerates queries even . finally, since raptor   rely  preprocessing,    directly.
used  dynamic scenarios. regarding future work, .
 interested  using raptor  handle public transport networks  continental size.   networks,.
however,   likely   apply  preprocessing.
acknowledgments.   like  thank dominic green, hatay tuna, kutay tuna,  simon.
williams  inspirational discussions  processing .
london transit data.
</doc>
<doc title='025.txt'>
transit nodes . lower bounds  refined construction.
jochen eisner. stefan funke.
abstract.
 reconsider  concept  transit nodes  introduced.
 bast  . .    first time construct.
instance based lower bounds   size  transit node.
sets  interpreting   formulation   problem.
  dual.   side product  achieve considerably.
smaller access node sets  directly influences .
query time  non-local queries.
. introduction.
dijkstra. algorithm  still  baseline   comes.
 computing  shortest path distance   graph .
non-negative edge weights.   given source node.
   target node   computes  shortest path.
 time . log  . .  seems best possible .
 comparison model,   preprocessing   graph.
 allowed.  preprocessing  experienced query.
times   drastically improved.  one hand .
 techniques  allow   pruning   dijkstra.
search   . .  potential function . .  .
  precomputed  modify edge costs., arcflags ., .
.edges  tagged    relevant   shortest.
path   target region., reach . .edges.nodes.
 classified according   importance  whether.
  appear   middle   long shortest path.,.
 many .  latest   techniques allow.
 query times   order  milliseconds  contrast.
 plain dijkstra  takes   order  seconds.
  moderate size road network like    europe.
  . million nodes  . million edges. .
completely different approach  introduced  bast.
 .  . , one considers  set    .long.
shortest paths .  point  leave  term .long.
imprecise  purpose,  think  .longer  .
  graph .,.   .    represented.
  sequence  set   nodes.  sake   simpler.
exposition  focus   case   undirected graph,.
mentioning important differences   directed case.
along  way.
preprocessing.   preprocessing step  want .
compute  set  transit nodes  .    . . .
.universita. stuttgart, institut . formale methoden.
der informatik, . stuttgart, germany . jochen.eisner,.
stefan.funke.fmi.uni-stuttgart.
   .  . .    set  good , .
 properties    desired.
  start   following observation .
seems natural  thinking     .
   travelling .far. . . say .
 . .  will leave  local neighborhood  one   arterial routes.
 reality,  handful   routes suffice. , looking.
  paths   starting   specific vertex , .
 first  kilometers .leaving  local neighborhood.
  share one  . say . common prefixes.  .
 make sure   .long. paths leaving   .
hit     local neighborhood  ,   define .
 set  access nodes anv    first node  .
    prefixes,  typically  expect .anv.
   small constant.   preprocessing stage .
apart  determining  .  compute  store.
.   pair ., . .  .   distance .
  .
.    .   distances    . anv.
query.   given distance query     .
 sufficiently far apart . also called non-local ., .
 determine  exact distance  evaluating . .
ans,. . ant  expression ., ., ., .
 taking  minimum.  terms   expression.
 known   preprocessing stage   .
essentially .ans. . .ant. expressions  evaluate. .
     .far apart. .  local .,  resort.
   strategy   contraction  highway.
hierarchies ., .,  will   fast due  source.
 target  nearby.
 course,  whole scheme relies   hope .
one  construct  small enough set  .essential .
size .
. .   storing  . . . . . distance.
table   require humongous additional space. .
still cover  shortest paths.  query time  .far.
away. queries depends   actual sizes   access.
node sets.
 .  algorithm  presented  showed .
  possible  construct  rather small set  .
 storing  . . . . .-sized distance table requires.
essentially . . space.    time   cover.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  large fraction   shortest paths,   access.
node sets  also rather small.  concretely, .
 road network  california consisting  . million.
nodes  . million undirected edges,  .  transit.
node set   constructed  . . . . covering.
  .   shortest paths   network .
 average size   anv  around .,   typical.
query required around . lookups   precomputed.
data structure. transit node sets    order .
magnitude  reported   refined construction .
sanders  schultes .
   point,    clear, though, whether.
  covering rate  possible  . . say .
transit nodes,  maybe even just . transit nodes. .
.  . goldberg  . propose  notion  highway.
dimension  obtain theoretical explanations  .
great success  transit nodes   acceleration.
schemes.    concerned  upper bounds,.
though,   work  concerned  lower bounds.
 contribution   paper  derive instance.
based lower bounds   size   transit node sets.
   constructed  several notions  .far.
  achieved  modelling  problem  computing.
 transit node set    hitting set problem  .
 set   .integer. linear programming formulation.
 well   relaxation  dual.   dual fitting.
argument   show   simple greedy algorithm.
 practice achieves  small approximation ratios.
implying     possible  compute transit node.
sets considerably smaller  .  .  .  .
nice side effect,  algorithm produces access node sets.
  considerably smaller . .   average.
resulting  query times   one magnitude faster.
  results reported  . still,    consider.
 technique    practical importance, though, due.
  humongous preprocessing time  space, .
rather   computational proof  insight  .
transit node construction schemes developed  far .
close  optimal   considered network instances.
  small sub result  also show  simple filter .
deciding locality  shortest path queries based  .
triangle inequality .  might   actual use .
practical implementations   transit node scheme.
. transit nodes via   hitting set.
formulation.
.  .integer. linear programming background  classic hitting set problem  defined .
follows. given  universe    family   subsets.
. also reported similar numbers   larger  road.
network.
  ,  goal   choose  smallest subset  . .
  . .  .  .  . .  formulation  .
following primal integer linear program .ilp.  rather.
straightforward.
min.
.
.
.
.
.
.
 . ., . . .
 . ., ., . . .
    variable    element .
 indicating  presence   .    constraint.
   .   demands   least one .
 elements      .   linear programming.
. relaxation  integrality constraint    .
replaced   . .   concrete setting,  .
 .  , .  universe consists   vertices  .
road network     point consists   .long.
paths  .  . remark. later  will argue   .
 consist   .long. paths  prefixes thereof, partly.
  want  make use   .local neighborhood.
observation.
 dual    formulation   fractional.
packing problem.     . . family .
 subsets   universe   aim  selecting .
many fractionally disjoint sets    possible. .
  formulated   following dual .
max.
.
.
.
.
.
.
 . ., . . .
 . ., . . .
  indicates   .fractional. degree set.
 .   chosen. replacing  . .   integrality.
constraint  . ., .  obtain  integral set packing.
problem   goal  simply  choose  many.
disjoint sets  possible.
clearly,  objective function value   optimal.
fractional solution   primal    lower bound.
  optimal integral solution   primal ilp.
analogously,  objective function value   optimal.
fractional solution   dual    upper bound .
 optimal integral solution   dual ilp.  strong.
duality,  objective function values   optimal.
fractional solutions   primal  dual   .
.
  use   formalism   concrete problem  computing transit nodes.  approach  .
  one proposed   following computes  feasible integral solution   primal problem formulation.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.typically  optimal, though.   assume .
 solution  objective function value zprim.  .
exhibit  possibly fractional  feasible solution  .
dual problem  objective function value zdual .
zprim.zdual . .   . . .,  know  zprim .
   .-factor   optimal integral solution.
  primal problem, since  optimal integral solution   primal problem  . terms   objective.
function value. sandwiched   feasible primal.
integral solution   dual feasible solution.
  hitting set problem  essentially  .
  set cover problem,  seems  unlikely .
 polynomial-time algorithm  compute  integral.
solution   general  always  .log . factor away.
  optimal integral solution .   important.
 note, though,   concrete problem instances .
might  well possible  derive dual feasible solutions.
    small constant factor away  .
primal solution  hence proving close-to-optimality.
  primal integral solution.
  remainder   paper  will develop .
greedy algorithm   primal problem formulation.
  strategy  obtaining  feasible dual solution.
   problem instances  transit node computation  always   small constant factor away.
  primal greedy solution  terms   objective.
function value hence proving  close-to-optimality .
 respective solution   algorithm.
. transit node computation . obtaining.
feasible solutions   primal   dual.
 previous section   made clear  .
problem  computing transit nodes fits   .
framework  hitting set  set packing. , .
 notion  .long.   first compute  set.
  .long. shortest paths  consider   .
family  subsets   .  course  seems hardly.
feasible  networks  several million nodes since.
 family  subsets  contain   order .
. . . . . . . many sets,    might .
pretty large, . ,  specific characteristics .
 hitting set problem comes   rescue.  .
consider  .long. path ,  clearly  prefixes.
  path   also .long.  contained  .
. since   also shortest paths.    .
  hit   hitting set, ,    actually.
restrict    set  minimal .long. shortest paths,.
.,  .long. shortest paths    prefix  also.
.long.   observation reduces  size   .
 individual  .     gets treatable .
practice.
  want  make use   observation .
travelling far  local neighborhoods,  furthermore.
want  enforce   minimal long path  emanating    hit locally, . .close.  .   achieve.
   truncating     even shorter prefix,    end,  sets    hit   hitting.
set algorithm  prefixes  minimal shortest .long.
paths.  constraint might look artificial   already  implicitly  imposed  . since .
 local access nodes aka relevant transit nodes .
forced   nearby  construction.   problem .
consider   rest   paper  following.
  notion  .long.  .nearby.,.
compute  set  transit nodes  .  .
hits  .long. paths .nearby.  starting point.
 framework   duality will allow   come .
 guarantees   quality  solutions  .
problem.
. primal algorithm  primal algorithm follows  simple greedy strategy    iteration.
adds one node   hitting set .  one covering .
 far .unhit. sets  .  formally,   .
 hitting set   i-th iteration,  . . .  .
. . .,   choose   . iteration .
 .  .   maximizes . .  .  . . . .
 iterate   . .  simple algorithm computes  feasible integral solution   primal problem.
 achieves  approximation guarantee  .log . .
since    generic way .  construct  dual feasible solution      .log . factor away.
  following  will sketch  simple dual algorithm.
  practice yields dual solutions   .
close   primal solution   greedy algorithm .
terms   objective function.
. dual algorithm  dual algorithm follows.
 similarly simple greedy strategy.  algorithm.
proceeds  iterations, picking   iteration  set.
  smallest weight     overlap .
previously picked sets.   context  weight  .
set   defined   number  sets    .
 non-empty overlap  .  formally   .
 set  .pairwise disjoint. sets picked   i-th.
iteration  . . .  .  . . . . . . . ., .
 pick   . iteration  set    minimum.
weight.
  point   set   basic framework .
computing transit node sets   guaranteed  posteriori approximation quality.   remainder  .
paper  will fill   .important. details,  particular. discuss several notions  .long. including .
relation  existing transit node computation schemes.
 evaluate  algorithms  terms  approximation.
. copyright . siam.
unauthorized reproduction   article  prohibited.
guarantee .  transit node sets., query times .size.
access node sets.  efficacy .queries    answered.
. notions  .long. . algorithmic details.
.
outer.
inner.
figure . transit node construction  bast  . .
  different ways  define   .long.
path    two nodes     .far. apart.
 following  natural choices.
.  shortest path      .long.  .
euclidean distance along  path     .
   constant .
.  shortest path      .long.   graph.
distance . travel time. along  path  .
      constant .
.  shortest path      .long.   dijkstra.
rank   wrt     dijkstra rank.  .
wrt     reversed graph    .
constant .
  .  .  . .   distance function .
determines   .long. shortest path .  choice.
  determines   family   constructed .
preprocessing   decide  query time whether  ab-query   answered using  transit node scheme.
. comparison  existing transit node constructions   original paper  transit node routing  bast   .,  following transit node construction  used, see figure .
.  grid  . . say .  put   network.
. dijkstra rank   node  wrt    node   .
   dijkstra computation starting  ,   pulled  k-th node.
  priority queue.
.   boundary node   grid cell ,  dijkstra.
 started   nodes   outer boundary .
 figure .  settled.
.   node   . ,  set  access nodes .
determined   crossing points   shortest.
paths  outer boundary nodes   boundary.
nodes  .
 shortest path      .long.   .
 least . grid-cells     vertically .
horizontally.    simplified version   first.
notion  .long. via euclidean distance.
 .,  second incarnation  transit node routing  presented. ,  authors use  transit node.
set  .core .  certain level   highway hierarchy . highway hierarchies   sort  formal classification   road network based  dijkstra.
ranks. essentially,  approach uses  third notion.
 .long.
 second notion  .long.    used .
frequently, probably   inherits  main disadvantages    two notions. namely, checking.
 locality appears similarly difficult    third.
notion   adaptivity  varying network densities.
 similarly bad    first notion.  issues .
discussed   detail   following.
. query   query,  need  decide, whether.
vertices     far apart   distance notion ,.
  aim  computing  lower bound  .,. .
checking  lower bound   parameter .
    euclidean metric,  straightforward.
strategy   use  beeline   lower bound.
.,. . .
 taking  account  maximum speed  .
road network,   also turn  lower bound .
 lower bound  case    graph distance metric.
unfortunately    provide good bounds .
.,.  .   loosely coupled  small.
transit node sets   access nodes   node .
relatively distant, compared   overall shortest path.
length.  following yields  better bound . .
also applicable   euclidean case.  crucial.
observation   using  triangle inequality .
following statement holds   pair  access nodes.
. , .
.
. . . , .,., .
.
.,. . max.
,.
. , .
.
.
. , .
., .
.
note   directed graphs    necessarily sym. copyright . siam.
unauthorized reproduction   article  prohibited.
metric,    use . , .  .,.
.
.
 deriving  lower bound  .,.,  use.
., .  .
.
 , .  computation  .
distance     . experiments show.
  lower bound   close   true value .
.,.
 case  ., .   dijkstra rank  .
wrt , things get  complicated,   distance.
function   satisfy  triangle inequality  .
 solve   deriving individual constants  .
 node   specifies   paths outgoing .
  longer   .measured according euclidean .
graph distance.  hit   transit node.   .
computed   local dijkstra computation  .
set generation .similar   method  . note .
 need  compute   .  outgoing paths .
 source nodes.  well  . . incoming paths.
  target nodes.   reversed graph   .
directed edges.   employ   mechanism .
deriving  lower bounds   .euclidean  graph.
distance      compare  value .
max., .
one might wonder,   use  third notion .
.long. .dijkstra rank.  . one important advantage.
 dijkstra rank based methods   adaptivity .
varying network densities .  also  observed.
 comparing highway hierarchies . . edge.
reach, ., .  particular, using  dijkstra rank.
allows  keep  number  targets    source.
node     far away constant throughout .
network.  first two notions  .long. typically result.
  .non-far. targets  urban areas  less  .
countryside.
. preprocessing   notion  .long. .
fixed,  actual preprocessing step  set   primal.
 dual lps ., .  quite generic.   node.
  run dijkstra  .   priority queue  .
.,. . .  result   shortest path tree, rooted.
 , consisting   nodes  distance smaller .
 according   chosen notion  .long.  .
node  still present   priority queue  trace back.
 shortest path  , generating  set    prefix.
  path     consisting   nodes closer.
  . .     . . .  make use .
 travelling far  local neighborhoods observation.
 expect  resulting sets      many.
.  ending    sets per node . several.
tricks like restricting  sets  nodes  degree larger .
.since  degree . transit node   replaced  .
next larger degree node.   employed  make .
approach  efficient. see figure .   depiction .
 situation.
vih.
.
.
.
. .
.
.
.
.
.
figure .  set  created   distinct shortest path.
 crosses   .   create . sets.
. computation  access nodes  .
 computed  set   transit nodes,  remains.
 compute    .   access nodes ani . .
.intuitively    first transit nodes   .
routes leaving  local neighborhood.    smaller.
hitting set problem hsi . .
.
 , .
.
 .
.
 .  .,  .
need  hit  sets hji ,    allowed  choose.
elements   . even   sub problems hsi .
 quite large,   able  solve  optimally .
 efficient way, employing  special structure  .
sets hji .   sets  constructed  .
shortest path tree rooted     sub sampled .
throwing away  nodes    chosen   .
 ,   sort  elements  increasing distance .
  starting   closest mark     .
solution set ani   greedy manner.   easy  see.
  yields  optimal solution  hsi   .
traversing  shortest path tree  increasing distance.
 approach  similar   one described  .
 number  access nodes compared  considerably.
decreased compared   approach .  . .
directly influences  query times   will see later.
.
. implementation  evaluation.
  implemented  primal  dual greedy.
algorithms  .  computed transit node sets.
 lower bounds  different road networks.  .
following presentation  will focus   road network.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 california .,   also evaluated  . .
 available   dimacs. challenge website.  .
. nodes  . edges.  used two.
versions   graph, one bears  euclidean distances.
 edge costs,   bears travel times.  .
tests  also used   network  . nodes.
 . edges.  . code  evaluated.
.unless stated otherwise.   . core machine  .
amd opteron . cpus  .ghz  .  ram.
timings   terms  cpu time,  . minutes  two.
cores  accounted  . minutes.
 main challenge   implementation  .
handling   sets.  contrast    transit.
node construction schemes,     explicitly.
built  stored  derivation   lower bounds. .
give   idea,   road network  california,.
  parameter setting  results   .
rate  non-local queries,    generate . million.
sets   . million nodes  total.   .
road network,  similar setting required . million.
sets  . billion nodes  total, pushing  server.
 .  ram   limits. even   small.
networks  . formulation becomes  large, .
employing standard linear programming techniques .
infeasible. neither glpk.   solve.  able  find.
feasible solutions    case  instances consisting.
  . . . sets.   set  constraints  .
result   road network   . nodes. primaldual techniques  also tried  reasonable fast .
consistently non-competitive  respect quality  .
outcome.
. instance-based approximation guarantees.
 main result   paper   computational proof.
   road networks encountered  practice,.
 transit node construction schemes   .
developed  far  essentially optimal    small.
constant factor.   end,   used different.
notions  .long.   experimental evaluation. .
computed  set  transit nodes .primal  size., .
feasible dual solution .dual  size.,  ratio .
 average number  access nodes.
 example,  third row   dijkstra rank .
travel metric block  table . means   consider .
graph   travel times  edge costs,  shortest.
path       .long.   dijkstra rank.
  wrt   . .  vice versa.  .long. paths.
emanating   vertex  must  hit  transit.
nodes  dijkstra rank . . wrt  .  primal.
greedy algorithm computed  transit node set  size.
.http.www.dis.uniroma.challenge.
.gnu linear programming kit.
.http.lpsolve.sourceforge.net.
.,  dual feasible solution  hence lower bound.
 .,  ,      factor  .  .
optimum size   notion  .long.  average.
number  access nodes   node  .  .
rows    interpreted    manner.  .
notion  .long.,  proven approximation ratio .
always  .
. comparison  previous constructions.
   relate   results,  example .
.   end  first   determine,  .
concrete notion  .long. means  terms   fraction.
 paths   indeed .long. according   notion.
 table .  see  example    scheme just.
explained,  .   queries,  distance lower.
bound equation . proves    employ .
transit node scheme.  fact,  result   transit.
node scheme  correct  .   queries .
   prove . similar effects  also reported.
 .
 results   comparable   results .
. according  table .  ., . transit nodes.
 necessary   . grid  california .
equals  success rate  . .   essentially determined   grid dimensions.   travel time.
metric   edges. . transit nodes  necessary   euclidean metric.  terms   construction scheme,   travel time metric  .
similar results   .non-dijkstrarank-based. traveltime constructions   value  .units.
 . units. unfortunately   match exactly  success rate  .    estimate .
   value  around .   get upper .
lower bounds  around .  .  terms .
efficiency,  dijkstrarank-based construction  .
travel time metric  far superior.  fewer transit.
nodes .  obtain  considerably higher success.
rate . similar results   observed  .
euclidean metric.
looking    road network  tables .  ., .
see  example    euclidean metric  .
provably hit .   paths using . transit.
nodes .   factor .   lower bound. .
., table .,  first layer   transit node scheme.
 euclidean distance contains . transit nodes .
provably decides .   queries.  average number  access nodes  . compared  . .   case.
measuring  preprocessing time  difficult   implementation  tuned   large instances  highly.
dependent   amount  .  order  provide .
estimate  measured  usertime  .
path length case    graph   set generation step took .min  resulted  . . . sets.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  primal  size dual  size apx avg. tsnodes.
dijkstra rank  . . . . . .
euclidean metric . . . . . .
. . . . . .
dijkstra rank  . . . . . .
traveltime metric . . . . . .
. . . . . .
traveltime . . . . . .
. . . . . .
. . . . . .
euclidean path . . . . . .
length . . . . . .
. . . . . .
table .  primal  dual objective function values, approximation ratios, avg. number  access nodes .
different notions  .long. .   upper.lower distance bounds   respective search spaces. .  .
chosen traveltime metric unit, .  meters.
  primal  size dual  size apx avg. tsnodes.
dijkstra rank  . . . . . .
euclidean metric . . . . . .
table .   table .  .
cpu model query time  .
amd phenom ., .ghz .
amd opteron ., .ghz .
intel ., .ghz .
figure . average query times   shortest path.
distance computation  different processors. .
timings  averaged  . random .long. queries.
consisting  . . . elements overall.  greedy.
computation   primal solution took .,  dual.
one . finally  computation    pair shortest.
path distances took .  set computation step.
scales linearly   number  nodes   graph .
  choice   upper  lower bound parameter.
   dominating part   precomputation. .
greedy primal.dual computation    instances .
mainly . bound   generated sets    retrieved  disk.  main primal.dual computation.
running time    order  several minutes compared.
  .  requires   one hour.
. query timing  described  section .,  ,.
 distance calculation   point  reduced  .
lookups  precomputed values.    specific .
need  compute minimum value  ., . . ., . .
., .    . ans    . ant. .
results  .ans. . .ant. lookups  ., .  ., . .
 respective access node arrays  also   .
amount  lookups   all-pairs shortest path table.
  access nodes   respective value  ., .
hence  number  access nodes   key factor .
determines  query time.
 .,  .admittedly   sophisticated. strategy .
determining access nodes resulted  . . access nodes.
per node   average   travel time .euclidean.
metric graph.  last column  table . shows .
avg. number  access nodes.  obtain around .
. access nodes   average   travel time.
.euclidean. metric.  results  roughly . .
lookups instead  . . ,  course,  also.
reflected   actual query times.
 time needed   lookups  dominated  .
access   all-pairs shortest path array   access.
pattern   values ., . will  often result .
cache misses.  contrast  distance values  ., .
 ., .  hold  one contiguous small array  .
  respectively.     surprising   real.
worlds query timings  </doc>
<doc title='026.txt'>
robust mobile route planning  limited connectivity.
daniel delling. moritz kobitzsch. dennis luxen. renato . werneck.
abstract.
 study  problem  route planning  mobile.
devices.   two current approaches  .
problem. one option      routing data.
  device,    compute routes .
.  makes  hard  incorporate traffic updates,.
leading  suboptimal routes.  alternative approach.
outsources  route computation   server, .
 sends   route   device.  downside.
   user  lost  deviating   proposed.
route   area  limited connectivity.   work,.
 present  approach  combines  best  .
worlds.  server performs  route computation.
, instead  sending   route   user, .
sends  corridor   robust  deviations. .
define  corridors properly  show   size.
  theoretically bounded  road networks. .
evaluate  quality experimentally  terms  size.
 robustness   continental road network. finally,.
 introduce several algorithms  compute corridors.
efficiently.  experimental analysis shows  .
corridors  small   robust  deviations,.
   computed quickly   standard server.
. introduction.
map services  motivated extensive research  .
fast computation  driving directions  road networks.
finding  quickest route  two points  .
modeled   shortest path problem  weighted graphs.
 standard solution   problem  dijkstra.
algorithm . although  runs  essentially linear.
time ., even   server  still takes   seconds.
 continental road networks . tens  millions.
 intersections.,    fast enough  .
applications. several acceleration techniques find routes.
much faster   two-phase approach.  .ine.
preprocessing phase augments  graph  .
auxiliary data,    used  accelerate online.
.partially supported   bmwi project .meregiomobil.
 dfg grant  .
.microsoft research silicon valley. dadellin.microsoft.com.
.karlsruhe institute  technology. kobitzsch.kit.edu.
.karlsruhe institute  technology. luxen.kit.edu.
.microsoft research silicon valley. renatow.microsoft.com.
queries. . recent overview   techniques  given.
 delling  . .  fastest known technique.
needs    memory accesses  determine .
distance  two random points .,   fraction.
  microsecond.
   techniques   implemented.
 server-like machines   scenario  .
computer serves queries   map service. mobile.
devices   smartphones  tablets  increasingly.
popular, however,  computing driving directions.
 one   key features.   two basic.
approaches  achieve .   online approach,.
 device holds  map data  rendering , .
 server keeps  auxiliary data  routing. .
route   computed   server  sent  .
device.  setting enables routes  incorporate .
 recent available data,   real-time traffic.
updates. moreover,  mobile device must  almost.
 computation.  route  just  list   traversed.
 main drawback   approach     .
robust .   user makes  wrong turn  deviates.
  proposed route,  server must  accessed.
.   happens   area   connectivity.
.   route  preloaded   wifi-only device.,.
 user  lost.   remedied   .ine.
approach,   mobile device keeps   data.
internally  computes routes  . although .
techniques  fast enough   scenario ., .
computation effort   device  higher   .
online approach.  main disadvantage, however, .
 data   outdated  real-time updates .
 integrated easily since  auxiliary routing data .
  updated.
 work introduces  hybrid approach.  .
 online version,  still compute  routes  .
server, potentially using   recent traffic data.
instead  submitting   route    user,.
however,  submit  corridor   robust .
deviations.  straightforward solution   problem.
  send   user  entire shortest path tree .
 destination.   obvious downsides, however.
even modern algorithms . take  long  compute.
 whole tree,   amount  data sent .
  large. instead,  want  find  subtree .
 shortest path tree   small   robust .
. copyright . siam.
unauthorized reproduction   article  prohibited.
possible. sending just  route .  send less.
  entire tree .robust   deviations.  .
extreme cases.  want something   .
offers  good trade-off.  exist  variety  problems.
  related   setup, like  computation .
detours ., k-shortest paths ., ., alternatives ., .,.
 replacement paths ., . however, none  .
approaches solves  problem.
 contributions   follows. first,  propose.
different approaches  determine corridors,  carefully evaluate  quality. second,  show  .
sizes   corridors   nontrivially bounded .
road networks. third,  show   corridors .
 efficiently computed. finally,  perform  thorough.
experimental evaluation   method, showing  .
outperforms straightforward solutions     order  magnitude.  takes    milliseconds  find.
corridors    small  extremely robust.
 paper  organized  follows. section . reviews.
techniques  work  based upon. section . defines .
notion  corridors  proves   size  limited.
 road networks. section . shows   compute .
corridors. section . presents  empirical evaluation .
 proposed corridor  terms  size, robustness, .
computational effort. section . concludes  work.
. preliminaries.
 interpret  road network   directed graph  .
.,, .  length function . .  . . .  order .
incorporate turn costs,  use  so-called edge-based.
representation   road network .  vertex.
represents  road segment,  two vertices   .
 connected   arc ., .    possible  turn.
 one      single intersection. .
length  ., . represents  travel time   start.
 road segment    start  road segment . .
denote  pst  shortest . path  ,  .pst. .
size .number  vertices.,   .pst.  length, .,.
.,.pst ., .  also refer  .pst.   distance.
   , denoted  ., .  denote   .
 inverse shortest path tree  .
 literature often considers  point-to-point.
shortest path problem,  asks   path pst.
  source    target .  extension .
 corridor problem.   ask   superset  .
shortest path   robust  deviations  .
note   problem  rather fuzzy   highly.
depends   definition  robustness.  fact, one.
contribution   work    define  evaluate.
 robustness  corridors.
dijkstra.  standard approach  computing.
shortest path trees  road networks  nonnegative.
arc lengths  dijkstra. algorithm .  maintains,.
 every vertex ,  upper bound .   length.
  shortest path   source ,  well  .
predecessor .parent. .     path. .
variables  initialized  . . ., . .  .
 vertices,  . . null   .  algorithm.
also maintains  priority queue  unscanned vertices.
  step,  removes  vertex    queue .
minimum . value  scans .   arc ., . .
  ., . . .,  sets . . ., .
 . . .  algorithm terminates   queue.
becomes empty.     interested   shortest.
path    , one  terminate  algorithm .
soon       scanned.  road networks,.
dijkstra. algorithm runs  essentially linear time .
contraction hierarchies.  mentioned ,.
many speedup techniques   developed  .
point-to-point shortest path problem . one .
  prominent  geisberger  . contraction.
hierarchies . . like   techniques, .
  .ine. preprocessing phase  augments .
graph  auxiliary data,    used  accelerate.
.online. queries.
 preprocessing phase orders  vertices .
contracts    order. contracting  vertex .
temporarily deletes    graph  adds arcs.
  neighbors  preserve  distances among.
.   done  follows.   ordered pair.
., .  neighbors     ., . . .,.  .
 shortest . path   current graph,  add.
 shortcut ., .  ., . . ., . . .,. .
call ., .  prefix  ., .  .,.  suffix. .
output   preprocessing phase   set . .
shortcut arcs, together   position   vertex.
   order .denoted  rank.  algorithm .
correct   contraction order,  query times .
 size  . may vary.  practice,  vertex  .
given  priority computed   online heuristic .
measures  importance .   work,  use .
linear combination   edge quotient .   level.
.  edge quotient    given   number .
arcs added divided   number  arcs deleted  .
  contracted next.  level    computed.
 contraction. initially, . . .   vertices .
 contracting ,  set . . max., .
  uncontracted neighbors   .
 query phase   runs  bidirectional version.
 dijkstra. algorithm   graph . . .,.,.
  looking  upward arcs, .,  leading.
 neighbors  higher rank.  precisely, .
. . ., . .  . . . rank. . rank. .
. . ., . .  . . . rank. . rank. .
forward search works  . . .,.,   reverse.
search  . . .,.  vertex  maintains.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.possibly infinite. upper bounds .  .  .
distances   .found   forward search.  .
 .found   reverse search.  algorithm keeps.
track   vertex  minimizing . . . . ., .
stops   minimum value  either priority queue.
  least  large  .
 shortest path  computed  .,   may.
contain shortcuts.    interested   corresponding path  ,  need  unpack . note  .
shortcut ., .  built   prefix ., .   suffix.
.,.  contracting  vertex . storing  middle vertex   ., . allows   recursively unpack.
 shortcut   corresponding sequence  arcs  .
phast. delling  . . developed  algorithm.
 uses  contraction hierarchy  accelerate .
computation  full shortest path trees.  first sight,.
 seems one    much better  dijkstra.
algorithm,  runs  linear time    twice.
 slow   plain bfs .  dijkstra  bfs,.
however,   poor locality. since  grow .
ball  increasing radius around  source,  vertices.
  queues  usually spread  different regions.
  graph.  memory, leading  many cache.
misses. changing  graph layout  memory  help,.
  single layout works well   possible sources .
 road networks, phast .  avoid .
problems. unlike dijkstra,  works  two phases.
preprocessing      . given  source ,.
 query first computes  full shortest path tree .
follows. initially, set . . .  . . .  .
  .  .  run  upward search   .
. forward  search., updating .   vertices.
 scanned. finally,  scanning phase   query.
processes  vertices  .  reverse rank order. .
process ,  check   incoming arc ., . . .
whether . . ., . improves .   , .
update  value.   updates, . will represent.
 exact distance    .   need actual parent.
pointers   original graph,   run  additional.
sweep   . arcs   original graph. setting.
. .   . . ., . . . holds.
 main advantage  phast  dijkstra .
   .cheap. upward  search depends .
 source .  . costly. scanning phase visits vertices  arcs    order   source.
permuting vertices appropriately  preprocessing.
ensures  scanning phase accesses  lists  vertices.
 arcs sequentially, minimizing cache misses. .
alone makes phast  . times faster  dijkstra.
 large road networks. another advantage  phast.
 dijkstra. algorithm     easily  parallelized. implemented   nvidia gtx . gpu,.
 speedup increases    . compared   single.
core   modern cpu.
phast   extended   one-to-many scenario,.
 one must compute shortest paths   query.
vertex    .fixed. set   vertices.  resulting.
algorithm, called rphast ., introduces  target.
selection phase  preprocessing  query, .
extracts fromg.  smallest subgraph   necessary.
 compute distances    .  .
. corridors.
 already mentioned  section .,  straightforward.
solution   corridor problem   send  entire.
shortest path tree  .   user. besides  obvious.
drawback  transmitting  large amount  data, even.
 phast  computaiton   fast enough .
enable real-time queries. instead,   interested  .
relevant subtree   .    small  possible .
also robust  deviations.  idea   follows.
 choose  set   seed vertices   . pst . .
,  . corridor ., .  given   union .
pst   . shortest paths   . . note .
  definition, ., .   subtree   .  now.
discuss two ways  choosing  seed set.
 obvious choice     include  vertices .
 .close.   shortest path.  precisely,  set.
. . . .  .  . pst . . . pst . ., . . . intuitively, . contains  vertices   within distance.
.   shortest path.  call  resulting corridor  . -perimeter corridor . -pc.   robust.
 deviations    .   optimal route.
moreover,  call  problem  finding  corridors.
 . -perimeter corridor problem. although  definition looks promising,  experiments .see section .
indicate     better.  main drawback .
  add  many vertices  urban areas  .
enough important roads.
  reason,  propose .    use.
 notion  turn corridor . ,  contains .
vertices adjacent  pst.  formally  . . .  .  .
pst . . . pst . ., . . .  makes  corridor.
robust  exactly one deviation   shortest.
path.  call  vertex  .   deviation vertex. .
 easily extend  approach  recursively construct.
 k-turn . corridor  ., .   robust .
 wrong turns. therefore,  determine  k-th order.
deviation vertices  . . .  .  .  ., . .
 ., . . ., . . ., .,  vertices adjacent .
 ., .,   ., . . pst.   ., . .
seeded   .
.
.  call  corresponding.
problem  finding  corridors  k-turn corridor.
problem. note   shortest paths  unique, turn.
corridors  unique  well. figure . visualizes .
differences    .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
figure . schematics  perimeter .left.  turn .right. corridors.
theoretical analysis. given  definition  turn.
corridors,  now show   size  limited .
graphs  low highway dimension ., .  concept  highway dimension   introduced  explain  good performance  hierarchical point-topoint speedup techniques  road networks . .
believed   small highway dimension. since  .
 theoretical model,  makes  simplifying assumptions    graph  undirected.
  use highway dimension  show , .
reasonable assumptions,  .-turn corridor   .
. . . vertices,     highway dimension.
  graph.  explain highway dimension  .
detail,  need  concept   shortest path cover.
.spc.  ., .-spc    set  vertices  two.
properties. first,  hits  shortest paths  length.
   . second,  set  sparse.  .
vertex  .  ,  ball . .containing  vertices .
 ., . . . contains    vertices  .
 highway dimension   graph   minimum .
   ., .-spc exists   .
following abraham  . .,  also consider .
graph   undirected.  simplicity,  assume .
maximum degree    constant, shortest paths .
unique,  edge weights  bounded   constant,.
., . . .  last assumption implies .
.pst. . .pst.,    enforced  splitting.
long edges  multiple ones. finally,  assume .
.pst. . .
.
.,   reasonable  road networks .
section .
theorem . .turn corridor size.    .
undirected weighted graph  constant maximum degree, highway dimension ,  length function . . .
. ,  . .  . . . . moreover, .pst. .
.   ,  .  . , . ., . . . . .
holds.
proof.   . . .
.
.  .pst. . . holds .
 shortest paths.  consider two cases.
case . .pst. . .  partition pst  .
parts,   length   .   subpath.
 , consider  vertex    balls  size . .
. around . see figure .   illustration. since.
 length   edge  bounded   constant,.
 deviation vertex   contained  . due.
  subpath optimality,  shortest path .
   target starts   shortest path  length.
.   fully contained  . moreover,.
 tui.
.
.
.
.
phit.
.
figure . illustration   proof  theorem . left.  split pst  . parts  consider  balls .
size .  . around  vertex    subpath .
. right.  deviation vertex   contained   ball .
size .  shortest path     starts   shortest path  length .   covered  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
  graph  highway dimension , .
shortest paths  length .   ball  covered.
    vertices. since  exist . deviation vertices   ,  sum   lengths  .
shortest paths   deviation vertices   .
covering vertices  bounded  .  .
   vertices,  length   shortest path.
   bounded  . since   . subpaths,  total size   corridor  bounded .
. . . . . . . edges.
case . .pst. . . pst  . deviation vertices ,  .pvt. . . holds    .
 directly gives   bound  .   size.
  ., .
note   bounds   conservative. .
  use  fact   shortest paths   covering vertices   target share many edges. indeed,.
experiments suggest  corridors  much smaller.
 size depends linearly   size   shortest.
path.
. computation  corridors.
  section,  discuss    solve  k-turn.
corridor problem efficiently.  first show  existing.
techniques   applied   turn   tailored.
solution.  techniques follow   pattern. .
perform  . . rounds,   round extending .
corridor .denoted  .  one turn. therefore, .
 round ,  first determine  deviation vertices.
 . . .  .  .  . ., . .  . .  .
  add    .   . shortest path.
 .  round .,  set  . .   general.
approach,  .  ., .  round . recall .
 ., . . pst.
. straightforward approaches.   natural approach  compute  ., .   first construct.
 .  dijkstra. algorithm. ,  maintain two.
stacks .  .,  .  initialized  .  .
round,  process  vertices  .  removing.
 top vertex   .,  add     scan  .
outgoing edges ., . .    . .     parent.
    .,  add   ., otherwise  .  round.
ends  setting . . .  . . . note   .
end  round , . contains   deviation vertices.
 ,   .  ., .  call  approach.
corridor dijkstra .cdijkstra.
 main drawback  cdijkstra   prohibitive.
running time  build  shortest path tree.  .
 partly remedied  replacing dijkstra  phast.
 call  resulting algorithm cphast. still, even.
 multiple cores phast  compute trees fast.
enough  continental road networks using  edgebased representation.  gpu version  phast ,.
    issues. first,   servers nowadays.
 equipped  gpus. second,  remaining computations     performed   gpu .
well, since  gpu.cpu communication  expensive.
 fact, even copying just  corridor   gpu.
 already  costly.
instead  computing full shortest path trees, .
 use  point-to-point speedup technique  .
 . techniques   used  well.  .
round,  first compute  deviation vertices   .
 traversing . ,  run    .   .
query  add  unpacked shortest path  . .
call  approach corridor  .cch.
 major drawback   approach   .
  lot  unnecessary computations. particular,.
 performs  upward search   multiple times. .
 remedy   adapting  bucket-based approach.
 knopp  . .   scenario.  run  upward.
search      store  search space .
keeping  distance     vertex  scan. ,.
 compute  new shortest path   deviation vertex.
,   need  run  upward search  . .
 scan  vertex    also  scanned  ,.
 check whether ., . . ., . . ., . holds .
update ., . accordingly.  course,  still  .
unpack  shortcuts  appear  shortest paths. .
corridor bucket  .cbch. approach saves roughly.
.   work  cch.
.  approach. analyzing cbch, one may notice   algorithm still   lot  unnecessary.
computations.  example,  upward searches .
neighboring deviation vertices  probably overlap .
lot   unpack shortcuts multiple times. indeed,.
 section . will show,   mentioned approaches.
fall short  terms  performance.  now present .
tailored corridor computation algorithm .tcc., .
avoids unnecessary computations  much  possible.
 uses  contraction hierarchy  borrows  ideas.
 phast  rphast.
like cbch, tcc runs  upward search  .
 .  initialization, storing  search space.
tcc still works  rounds,   now consists.
 three phases. first,  upward phase, borrowed.
 rphast ., determines  vertices . .
 reachable    . ,  sweep phase.
computes  distances   vertices  .  .
end   sweep phase,   computed  shortest.
paths   vertex      . finally, .
unpacking phase  extracts   packed paths.
 adds   . since    computed.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 shortest paths   deviation vertices  ,  .
 ., .  round .   following,  detail.
 phase  turn.
 keep  global marker, called final,  identifies.
vertices  correct distance value  .  initialization,    ensure correct distance values .
 vertices   contracted path     highest.
ranked vertex. hence,  mark    final.
 upward phase identifies  vertices .  .
reachable    . recall     set .
deviation vertices   current corridor . therefore,.
 first traverse  current corridor   identify .
deviation vertices.   first round,  . . ,.
 set . .   maintain  queue  initialized .
. whenever  remove  vertex   ,  first.
check whether   marked  final.   ,  discard.
. otherwise,  scan  upward edges ., . . . .
add   . .     .
  sweep phase  process .   top-down.
manner,   phast.    . .,  scan .
., . . .  check whether ., . . . . . .
,  update .  . due   correctness .
phast,  process computes  shortest paths .
 deviation vertices    .
 unpacking phase now expands   packed.
shortest paths.  start  adding  vertices  .
  queue . whenever  extract  vertex  .
,  check whether  . .   ,  discard .
otherwise,  add   , mark   final,  identify.
 parent .  recursively unpack  shortcut ., .,.
setting  distance values  parent pointers  .
middle vertices accordingly. moreover,  mark .
middle vertices  final  add   . note .
   need  unpack  suffix   shortcut .
 middle vertex   already contained   .
 .  implies  pwt  already fully contained .
.  need, however, continue  unpack  prefix.
 puw   need   part  . note ,.
  unpacking routine,  shortcut contributing.
   unpacked exactly .
optimizations.   apply  optimization.
techniques  accelerate tcc. first,   reorder.
vertices   level   contraction hierarchy .
improve locality.  also exploit  fact  .
number  levels  small  road networks  keeping.
 bucket per level.  determining  vertices.
.  need  process.   reachable  .
deviation vertices,  add  reachable vertex  .
bucket associated   level. ,   process.
 levels  decreasing order, scanning  level  .
linear fashion.  accelerates  algorithm since .
increases locality.
. experiments.
 implemented  algorithms  section .  .
 compiled   gcc ., using  optimization flags .  -mtune.native.  use.
 binary heap  priority queue.  experiments.
 conducted   intel core-i. . . cores, .
clocked  . ghz.  hyper-threading activated.
. threads per core.  .   ddr. ram.
running suse linux .  input,  use  road.
network  western europe, made publicly available .
ptv  .   . dimacs implementation challenge .  published graph  node-based, however,   intersection modeled   vertex .
 road segment   directed arc.  model  .
 realistic.    incorporate turn costs, .
makes routing artificially easier ., .  therefore expand  network  use  edge-based representation.
.see section .,  leads   graph   .
million vertices  . million directed arcs. since .
   access  publicly available turn costs, .
follow  approach  delling  . .  set u-turn.
costs  . seconds.  remaining turns  free.
 ch-based algorithms  tested share  .
preprocessed data.  implemented   preprocessing following  implementation  kieritz  . .,.
using . . . . .  priority term . section .
  parameters, computing  contraction hierarchy takes . minutes  one core  results  .
. million upward .downward. arcs.
. quality.  first evaluate  quality   corridors  various parameters.  test two properties.
size  robustness  deviations.   first.
one  easy  measure,  need  come    measure  robustness.  ,  consider two driver profiles  model drivers deviating   route .
time  time.  first    deviation driver .,.
 leaves  optimal route  every intersection .
probability .  second profile   ., .-nervous.
deviation driver ndd., . ,  driver also deviates   optimal route  probability .  .
wrong turn, however,  probability  making another.
wrong turn increases  . .  .  driver gets.
nervous.   driver gets back  track,  deviation probability goes back  .
  driver profiles,  evaluate  often .
user following  patterns reaches  target without.
leaving  corridors  computed.  call  .
success rate   drive. table . reports  size  .
average success rates  . drives  two profiles,.
.  ndd., .  average  numbers.
 . . corridors,  corresponding   random.
query.
. copyright . siam.
unauthorized reproduction   article  prohibited.
table . quality  different corridors. column size gives  average number  vertices   corridor, .
success rate reports  percentage  successful drives  .-deviation  ., .-nervous deviation drivers.
turn corridor perimeter corridor.
size success rate . . size success rate .
 . . . ndd., . . . . . ndd., .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
 observe  turn corridors dominate perimeter.
corridors.    turn corridors smaller,  .
also  better success rates. one reason   turn.
corridors  favored   driver profiles,  .
also adapt better  different scales.  fact,  .
profiles  consider almost  drives  successful .
  low  .   point,  corridor   .
times bigger   route . also note  one.
 use succinct data structures .  obtain .
extremely compact representation   corridors. since.
 corridor   tree, one needs    bits per.
vertex.  concretely,   . .   need .
send less  .    user.
 also note  perimeter corridors stay small.
  deviations  . seconds .combined  low.
success rates though. increasing  deviation  .
seconds increases  size   corridors   factor .
. compared  . seconds, making  even bigger.
 .-turn corridors.  reason      use.
deviation probability .
figure . success rate  different  turn corridors .
varying  deviation driver profiles.
u-turn costs  . seconds.   increasing .
deviation beyond  point   corridors handle uturns.  explains  low success rate  perimeter.
corridors,   partially. even  . seconds .
success rate  still well    much smaller turn.
corridors.
 also evaluate  impact   deviation probability  .  . profile.   success rate  .
turn corridors, figure . shows  results.  expected,.
 higher ,   robust  corridors . .
 . .,  achieve  success rate  nearly .  .
 . .  means   corridor  robust .
drivers   average deviate   route  every.
tenth chance.   increase   ., still less  half.
 drives leave  corridor.  also observe  .
 . .,  success rate drops  .   . .
hence,  experiments reveals  increasing  .
.  yield advantages.  particular,  wifi-only.
devices  may pay   send bigger corridors  .
user.
 stress   success rates  achieved.
without updating  corridor   deviation. .
course,    increase  success rate .
allowing updates   corridor  soon   user.
enters  area  connectivity .  experiments.
show      send  . vertices .
average.  update  corridor   . .   deviation.
  . times less  resending  whole corridor.
  . .,    send . . vertices   single.
deviation, still   small fraction   full corridor.
  twice  size   shortest path.
local queries.   now,   evaluated.
 quality  corridors  random queries,  .
mostly long-range. since  queries   crosscontinental  practical applications,  now evaluate.
corridors depending   dijkstra rank   query.
. dijkstra rank   vertex   respect   .
     i-th vertex taken   priority queue.
 running dijkstra. algorithm  . figure .
. copyright . siam.
unauthorized reproduction   article  prohibited.
dijkstra rank.
figure . corridor size .left.  success rate   . .right. depending   dijkstra rank   query.
shows  results  dijkstra ranks  . .
.  expected,  corridor sizes increases  .
dijkstra rank.  road networks,   assume .
  vertex  dijkstra rank ,  shortest path .
   contains . vertices.   reflected .
 . . moreover,  observe   size blowup.
. ., .pst.  almost independent   rank.
  query.    slightly bigger  short-range.
queries.  reason     short-range queries.
often   touch  highways   number .
deviation vertices  higher  urban areas  .
highways.
 also observe   success rate  .
highly depends   rank   query.  lower.
 rank,  higher  success rates. since .
real-world queries  short-  mid-range,  expect.
 corridors  perform even better  reported .
table .
. performance.  evaluating  quality .
corridors,  now check  fast   compute .
  algorithms  presented  section . .
input   europe,   evaluate  .sequential.
table . sequential running times  different algorithms  computing turn corridors.  running times.
 given  milliseconds.
 cch cbch cphast tcc.
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
running times  . queries     chosen.
 random.   scenario, running cdijkstra takes.
roughly . seconds per query, independent  . table .
reports  results    algorithms  consider.
note    build parallel versions  cch,.
cbch, cphast,  tcc   scale  well.
  number  cores used.
 observe  cphast   . times faster.
 cdijkstra.   expected, since    work.
 spent  constructing  shortest path tree, .
confirms  speedup reported  delling  . . .
 still  fast enough, however,    enable.
real-time queries even   parallel implementation.
 cch  cbch outperform cphast   .
.,    slower   . .   easy  see.
.  number   searches run  cch  cbch.
increases   number  deviation vertices, .
grows  .  contrast, cphast computes  .costly.
shortest path tree  ,   add deviation.
vertices almost  free.
comparing cch  cbch  tcc,  observe.
   . .  three algorithms   similar.
performance.   . ., however, tcc outperforms.
  algorithm.  importantly, query times.
remain  .    . .,   still fast enough.
 interactive applications. .  comparable  typical.
network latencies.   . ., tcc    .
order  magnitude faster    algorithm. .
noted  section ., increasing     limited.
use. summarizing, tcc   best choice  compute.
corridors.
local queries.    quality experiments, .
now turn  local queries. figure . reports  running.
times  cch, cbch,  tcc  varying  .
.  .  dijkstra ranks  .  . .
figure . performance  tcc, cch,  cbch  computing k-tcs    .  .  varying.
dijkstra ranks.
. copyright . siam.
unauthorized reproduction   article  prohibited.
observe  tcc outperforms cch  cbch .
almost  scales.    . .  low dijkstra ranks.
 cch  cbch slightly faster  tcc. moreover,.
cbch outperforms tcc slightly   . .  high.
dijkstra ranks  well. however,    interesting.
scenario,  . ., tcc always   fastest algorithm.
. conclusion.
  paper,  introduced  concept  shortest.
path corridors. motivated  driving directions .
mobile devices,  argued  existing approaches.
 mobile route planning  disadvantages,  .
using outdated information   inability  update.
directions   user deviates   optimal.
route. shortest path corridors achieve  best  .
worlds.   use   recent data   robust.
 deviations.  key idea   identify  good.
subtree   shortest path tree   target. .
 shown   corridors  </doc>
<doc title='027.txt'>
.
.
.
.
.
.
hierarchical heavy.
hitters   space.
saving algorithm.
. mitzenmacher., . steinke.,  . thaler.
abstract.
 hierarchical heavy hitters problem extends  notion  frequent items  data.
arranged   hierarchy.  problem  applications  network traffic monitoring,.
anomaly detection,  ddos detection.  present  new streaming approximation algorithm  computing hierarchical heavy hitters   several advantages  previous.
algorithms.  improves   worst-case time  space bounds  earlier algorithms,.
 conceptually simple  substantially easier  implement, offers improved accuracy.
guarantees,  easily adopted   distributed  parallel setting,    efficiently implemented  commodity hardware   ternary content addressable memory .tcams.
 present experimental results showing   parameters  primary practical interest,.
 two-dimensional algorithm  superior  existing algorithms  terms  speed .
accuracy,  competitive  terms  space,   one-dimensional algorithm  also.
superior  terms  speed  accuracy    limited range  parameters.
. introduction.
finding heavy hitters,  frequent items,   fundamental problem   data.
streaming paradigm.   practical motivation, network managers often wish .
determine   addresses  sending  receiving   traffic,  order.
 detect anomalous activity  optimize performance. often,  large volume .
network traffic makes  infeasible  store  relevant data  memory. instead,.
  use  streaming algorithm  compute .approximate. statistics  real time.
given sequential access   data  using space sublinear    universe.
size  stream length.
.harvard university, school  engineering  applied sciences, michaelm.eecs.harvard.edu.
 work  supported  part  nsf grants cns-., ccf-.,  iis-.
.harvard university, school  engineering  applied sciences, tsteinke.seas.harvard.edu.
 work  supported  part   lord rutherford memorial research fellowship  nsf.
grant ccf-.
.harvard university, school  engineering  applied sciences, jthaler.seas.harvard.edu.
supported   department  defense .dod.   national defense science . engineering graduate fellowship .ndseg. program.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
 present  analyze  streaming approximation algorithm   generalization   heavy hitters problem, known  hierarchical heavy hitters .hhhs.
 definition  hhhs  motivated   observation   data  naturally hierarchical,  ignoring   tracking frequent items may lose useful.
information. returning   example   addresses, suppose   single entity.
controls   addresses   subnet .,  .   wildcard byte. .
 possible   controlling entity  spread  traffic uniformly among  set .
 addresses,    single  address within  set  addresses .
  heavy hitter. nonetheless,  network manager may want  know   sum .
 traffic    addresses   subnet exceeds  specified threshold.
one  expand  concept   consider multidimensional hierarchical.
data.  example, one might track traffic  source-destination pairs  .
addresses   router level.   case,  network manager may want  know.
    heavy hitter  network traffic   level  two  addresses,   source  address   destination subnet,   source subnet .
 destination  address,   two subnets.  motivates  study  .
two-dimensional hhh problem.  present  definitions shortly, following previous work   explored hhhs   one-dimensional  multi-dimensional.
hierarchies ., ., ., ., ., ., .
hhhs  many applications,    central  proposals  realtime anomaly detection .  ddos detection .   addresses serve .
 motivating example throughout  paper,  algorithm applies  arbitrary.
hierarchical data   geographic  temporal data.  demonstrate  .
algorithm  several advantages, combining improved worst-case time  space.
bounds   practical advantages   simplicity, parallelizability, .
superior performance  real-world data.
 algorithm utilizes  space saving algorithm, proposed  metwally .
. .,   subroutine. space saving   counter-based algorithm  estimating.
item frequencies, meaning  algorithm tracks  subset  items   universe,.
maintaining  approximate count   item   subset. specifically, .
algorithm input   stream  pairs ., .     item   . .   frequency.
increment   item.   time step  algorithm tracks  set   items,.
   counter.   next item    stream    ,  counter  updated.
appropriately. otherwise,  item   smallest counter    removed .
replaced  ,   counter    set   counter value   item replaced,.
plus .  approach  replacing items   set may seem counterintuitive, .
 item  may   exaggerated count  placement,   result  .
   large enough,  heavy hitters will appear   final set. indeed, space.
saving   identified    accurate  efficient algorithm  practice.
 computing heavy hitters ., ,   later discuss,  also possesses strong.
theoretical error guarantees . sample executions  space saving   found .
 full version   paper .
related work.  require  notation  introduce prior related work. .
notation  formally defined  section .   follows,    sum  .
frequencies  items   stream, .   accuracy parameter    outputs .
within .   true count,   represents  size   hierarchy .specifically,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.main.
.
pagei.
.
.
.
.
.
.
.
 size   underlying lattice.  data belongs . unitary updates refer .
systems   count   item increases   .   step,  equivalently,.
  just count item appearances.
 one-dimensional hhh problem  first defined  .,  also gave.
 first streaming algorithms  . several possible definitions  corresponding.
algorithms   multi-dimensional problem  introduced  ., .  definition  use     opinion   natural,   considered  several.
subsequent works ., .  terms  practical applications, multi-dimensional.
hhhs  used  ., .  find patterns  traffic termed .compressed traffic.
clusters.,  .  real-time anomaly detection,   .  ddos detection.
 space saving algorithm  used  .  algorithms   one-dimensional.
hhh problem.  algorithms require . space,   requires .
space.  recently, . presented  algorithm   two-dimensional hhh.
problem, requiring . space.
 recent work studies  hhh problem   focus  developing algorithms well-suited  commodity hardware   ternary content-addressable.
memories .tcams. .  algorithms  also well-suited  commodity hardware,   describe  section .
 contributions.  solving  approximate hhh problem,  seek  optimize  time  space required  process  update   output  approximate hhhs   estimated frequencies.  also seek  optimize  output.
quality,  terms   number  prefixes   final output   accuracy .
 estimates.  approach  several advantages  prior work.
.  worst-case space bound   algorithm  .  beats  space.
bound  .
.
.
. log .
.
 .  .,  . bound   one-dimensional.
algorithm  .,   . bound   two-dimensional algorithm .
. additionally  algorithm provably requires . space  realistic.
assumptions   frequency distribution   stream.
.  worst-case time bound   algorithm per insertion  . log . .  .
case  arbitrary updates  .   case  unitary updates.   .
 depend   . previous time bounds per insert  . log .  ., ., .
.  obtain  refined analysis  error propagation  achieve better accuracy.
guarantees  provide non-trivial bounds   number  hhhs output  .
algorithm  one  two dimensions.  bounds   provided  .
algorithms  ., ., .
.  space usage   algorithm   fixed  priori, independent   sum.
 frequencies  ,    depends   number  counters maintained  .
instance  space saving,   set  .   absence  assumptions .
 data distribution.  contrast,  space usage   algorithms  . .
. depends   input stream,   algorithms dynamically add  prune.
counters   course  execution,    infeasible  realistic settings.
.  algorithm  conceptually simpler  substantially easier  implement.
 previous algorithms.  firmly believe programmer time   viewed.
  resource similar  running time  space.   able  use  off-theshelf implementation  space saving,   fact notwithstanding,  still spent.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
roughly  order  magnitude less time implementing  algorithms, compared .
  ., .
.  algorithms extend easily  restricted settings.  example,  describe.
 section .   efficiently implement  algorithms using tcams,  .
parallelize ,   apply   distributed streams,    handle.
sliding windows  streams  deletions.
 present experimental results showing   parameters  primary practical interest,  two-dimensional algorithm  superior  existing algorithms .
terms  speed  accuracy,  competitive  terms  space,   onedimensional algorithm  also superior  terms  speed  accuracy   .
limited range  parameters.  short,  believe  algorithm offers  significantly.
better combination  simplicity  efficiency   existing algorithm.
. notation, definitions,  setup.
notation  definitions.  theoretical framework developed   section.
derives  .  several subsequent works ., .
 examples throughout  paper,  consider   address hierarchy .
bytewise granularity.  example,  generalization  .  one.
byte  .,  two bytes  .,  three bytes  ., .
 four bytes  .  two dimensions,  consider pairs   addresses,.
corresponding  source  destination ips.   prefix    fully general.
 either dimensions  two parents.  example,  two parents   .
pair ., .  ., . .
., .
 general,   dimension   data  ,   height   hierarchy .
 . dimension  .   case  pairs   addresses,  . .  . . . . .
denote  par., .  generalization  element   dimension .  example, .
 . ., .
 par., . . ., .  par., . . ., .
denote  generalization relation  .  example,.
., . . . . ., . . .
define  .   . . . . . . .  generalization relation defines  lattice.
structure   obvious manner.  overload  notation  define  sublattice.
  set  elements   . .  . . . .     .  .   denote .
total number  nodes   lattice.  .
.
. . .
 call  element fully specified      generalization   .
element, . .  fully specified.  call  element fully general .
dimension   par., .   exist.  refer   unique element   fully.
general   dimensions   root.  label  element   lattice  .
vector  length , whose ith entry    ,  indicate  lattice node .
element belongs ,   vector corresponding   fully specified element.
  . entry equal  ,   vector corresponding   root .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
 entries equal  .  example,  element ., .
 assigned vector ., .,  . . . . ., .  assigned vector ., .
 define level.   lattice    set  labels    sum  .
entries   label equals .  overload terminology  refer   element .
  member  level.   label assigned     level.   .
.
. .
denote  deepest level   hierarchy.
definition . .heavy hitters. given  multiset   size    threshold .,.
 heavy hitter .   element whose frequency     smaller  . .
 . denote  frequency   element   .  set  heavy hitters .
 . . . . . .
 henceforth assume   given  multiset   .fully-specified. elements .
 .possibly multidimensional. hierarchical domain  depth ,   threshold .
definition . .unconditioned count. given  prefix , define  unconditioned.
count    . .
.
. .
 exact hhhs  defined inductively   set  prefixes whose conditioned.
count exceeds . ,   conditioned count   sum   descendant nodes.
  neither hhhs    descendant   hhh. formally.
definition . .exact hhhs.  set  exact hierarchical heavy hitters .
defined inductively.
. hhhl,  hierarchical heavy hitters  level ,   heavy hitters  ,.
   fully specified elements whose frequencies exceed . .
. given  prefix   level., . .  . , define hhhpl.    set.
. . hhhl. .  . . . hhhpl.   set  descendants   .
  identified  hhhs. define  conditioned count      .
.hhhpl. .  set hhhl  defined .
hhhl . hhhl. . . . . . level. . . . .
.  set  exact hierarchical heavy hitters hhh  defined   set hhh.
 depiction   exact hhhs   two-dimensional hierarchy defined .
 example stream   found   full version   paper .
finding  set  hierarchical heavy hitters  estimating  frequencies.
requires linear space  solve exactly,   prohibitive. indeed, even finding .
set  heavy hitters requires linear space .,   hierarchical problem  even.
 general.   reason,  study  approximate hhh problem.
definition . .approximate hhhs. given parameter .,  approximate hierarchical heavy hitters problem  threshold .   output  set  items  .
 lattice,  lower  upper bounds fmin.  fmax.,    satisfy.
two properties,  follows.
. accuracy. fmin. . . . fmax.,  fmax. . fmin. . .  .
 .  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
. coverage.   prefixes , define     set . .  .  . . define .
conditioned count    respect      .
.
. .
 require   prefixes  .  ,  . . .
intuitively,  approximate hhh problem requires outputting  set  .
  prefix  large conditioned count . respect   .  omitted, along.
 accurate estimates   unconditioned counts  prefixes   . one might.
consider  natural  require accurate estimates   conditioned counts  .
 .   well,   shown  ., . space   necessary  .
required equally accurate estimates   conditioned counts,    .
excessively large  practice.
 algorithm, sketched.  algorithm utilizes  space saving algorithm,.
proposed  metwally  . .   subroutine,   briefly describe  relevant.
properties, including guarantees shown  . space saving takes  input  stream.
 pairs ., .,     item   . .   frequency increment   item.
 tracks  small subset   items,   counter    .  .   next item.
   stream    ,  counter  updated appropriately. otherwise,  item.
  smallest counter    removed  replaced  ,   counter  .
 set   counter value   item replaced, plus .
    sum   frequencies  items   stream,     number.
 counters maintained  space saving,     . ,   res. denote .
sum     top  frequencies. berinde  . . showed     . ,.
.
. . .  res.
.  , .
 .  .   estimated  true frequencies  item , respectively.
 setting  . .,  implies  . . . .  ,   . counters  needed .
ensure error   .   estimated frequency.  frequency distributions.
whose .tails. fall  sufficiently quickly, space saving provably requires . . . space.
 ensure error   . .see .   details.
using  min-heap based implementation  space saving, insertions takeo.logm.
time,  lookups require . time  arbitrary positive counter updates.
  updates  unitary .  . .,  insertions  lookups  .
processed  . time using  stream summary data structure .
 algorithm  hhh problems  conceptually simple.  keeps one instance.
  heavy hitter algorithm   node   lattice,   every update  .
compute  generalizations    insert  one separately   different heavy.
hitter data structure.  determining  prefixes  output  approximate.
hhhs,  start   bottom level   lattice  work towards  top, using.
 inclusion-exclusion principle  obtain estimates   conditioned counts .
 prefix.  output  prefix whose estimated conditioned count exceeds .
threshold . .
 mention   ideas underlying  algorithm   implicit .
earlier work  hhhs,   apparently  considered impractical  inferior.
  complicated approaches. notably, . briefly proposes  algorithm similar.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
  based  sketches.  algorithm  handle deletions  well  insertions,.
 requires  space   significantly less efficient output  insertion.
procedures. significantly,  algorithm   mentioned  .   extension,.
   studied experimentally.  algorithm similar    briefly described.
 .  show  asymptotic tightness   lower bound argument. interestingly,.
 clearly state  algorithm   meant   practical. finally, . describes.
 procedure similar   one-dimensional algorithm,  concludes    .
slower  less space efficient   algorithms.  therefore consider one.
  primary contributions    identification   approach   .
practical,   fact superior  many respects   complicated approaches.
 chose  space saving algorithm .   heavy hitter algorithm. .
contrast,  algorithms  ., .  conceptually based   lossy counting.
heavy hitter algorithm .  number   advantages enjoyed   algorithm.
  traced directly   choice  space saving  lossy counting,  .
.  example,  one-dimensional hhh algorithm  .  also based  space.
saving, yet  algorithm  better space guarantees.
. one-dimensional hierarchies.
 full version   paper contains pseudocode  example executions  .
one-dimensional algorithm,   much simpler   case  arbitrary dimension .  discussed,  use  space saving algorithm   node .
 hierarchy, updating  appropriate nodes   stream element,  .
conservatively estimate conditioned counts  determine  appropriate output set.
 following lemma  useful  proving   one-dimensional algorithm.
satisfies various nice properties.  proofs  omitted due  space limitations.
lemma . define  .    set . .  .  ,  . , . .  .  . . . .
  one dimension,  . .
.
. .
theorem . using . . space,  one-dimensional algorithm satisfies  accuracy  coverage requirements  definition .
 remark   realistic assumptions   data distribution,  algorithm satisfies  accuracy  coverage requirements using space . . details.
  .
theorem .  one-dimensional algorithm performs  update operation .
time . log . .   case  arbitrary updates,  . time  unitary updates.
 output operation takes time . .
 performing  refined analysis  error propagation,  bound  number.
 hhhs output   one-dimensional algorithm,  use   give accuracy.
guarantees   estimated conditioned counts.
theorem .  . . . .  total number  approximate hhhs output  .
one-dimensional algorithm    . .  maximum error   approximate.
conditioned counts,  . . ,    . .
 upper bound  output size  theorem .  nearly tight,   may .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
. exact heavy hitters.  example,  realistic values  . . .  . . .,.
theorem . yields  upper bound  .
. two-dimensional hierarchies.
 moving  one  multiple dimensions,   output procedure must change.
 one dimension, discounting items   already output  hhhs  simple.
   double-counting involved, since  two children   item  .
common descendants.  deal   double-counting,  use  principle .
inclusion-exclusion   manner similar  .  .
  high level,  two-dimensional output procedure works  follows. .
,  start   bottom   lattice,  compute hhhs one level   time.
  node ,    estimate  conditioned count    discounting .
counts  items   already output  hhhs. however, lemma .  longer.
holds.    necessarily true   . . .
.
. .  two  .
dimensions,   fully specified items   two   ancestors ,.
  subtracted  count multiple times.  algorithm compensates .
adding  counts back   sum.
 formally presenting  two-dimensional algorithm,  need  following theorem.  glb., . denote  greatest lower bound    .,  ,.
 unique common descendant     . satisfying . . . . . . . . . .
. .  . .   case    .   common descendants,  treat.
glb., .   .trivial item.   count .
theorem .  two dimensions,     set    expressible   greatest.
lower bound  two distinct elements  ,    .   distinct elements.
 . .
 . .
.
.
. .
.
.
.
 give pseudocode   two-dimensional output procedure  . .
compute estimated conditioned counts  . . fmax.
.
. fmin.
.
. fmax.,.
 fmax.  fmin. denote upper  lower bounds   unconditioned.
counts  , respectively.    one-dimensional case,  accuracy guarantees   algorithm follow immediately    space saving. coverage.
requirements  satisfied  combining theorem .  accuracy guarantees.
 two-dimensional algorithm performs  insert operation  . log . .
time  arbitrary updates,  . time  unitary updates, just  .
 one-dimensional case. although  output operation  considerably .
expensive   multi-dimensional case, experimental results indicate  .
operation   prohibitive  practice .see section .
using theorem .,  obtain  non-trivial upper bound   number .
hhhs output   two-dimensional algorithm.
theorem .  . .min., .,     depth  dimension . .
small enough .,  number  approximate hhhs output   two-dimensional.
algorithm   .
.
.
.
. . .
.
. . . .
.
.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
 error guarantee obtained  theorem . appears messy,  yields.
useful bounds  many realistic settings.  example,   addresses  byte-wise.
granularity,  . . plugging  . . ., . . . yields . . . .,   .
close   maximum number  exact hhhs. . . .
higher dimensions.  higher dimensions,    keep one instance .
space saving   node   hierarchy  compute estimates fmin.  fmax.
  unconditioned count   prefix .  need  modify  output.
procedure  conservatively estimate  conditioned count   prefix.
  show   natural generalization  theorem .   hold.
 three dimensions. however,   compute estimated conditioned sublattice.
counts  . .
 . . .
.
.
fmin. .
.
.,.glb.,.
fmax.
inclusion-exclusion implies   .  .,  hence  outputting    . . . .
satisfy coverage.
. extensions.
 algorithms  easily adopted  distributed  parallel settings,   .
efficiently implemented  commodity hardware.
distributed implementation.  many practical scenarios  data stream .
distributed across several locations rather  localized   central node. .
example, multiple sensors may  distributed across  network.  extend .
algorithms   setting.
multiple independent instances  space saving   merged  obtain .
single summary   concatenation   distributed data streams   .
constant factor loss  accuracy,  shown  .  use  form   result.
,    length   concatenation   distributed data streams.
theorem . ., theorem ., simplified statement. given summaries   distributed data streams produced   instances  space saving   . counters,.
 summary   concatenated stream   obtained    error  .
estimated frequency    . .
 handle  distributed data streams,  may simply run one instance  .
algorithm independently   stream . . counters .,  afterward, .
 node   lattice, merge   corresponding instances  space saving  .
single instance.   merge,    single instance  space saving  .
node   lattice   essentially   error guarantees .   small.
constant factor.   centralized implementation.
parallel implementation.     algorithms,  update operation involves.
updating  number  independent space saving instances.   therefore trivial.
 parallelize  algorithm.   parallelized  algorithm using openmp.
 limited experiments show essentially linear speedup,    point  .
reach  limitation   shared memory constraint.
tcam implementation. recently,     effort  develop network.
algorithms  utilize ternary content addressable memories,  tcams,  process streaming queries faster. tcams  specialized, widely deployed hardware.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
 support constant-time queries   bit vector within  database  ternary.
vectors,  every bit position represents ., .  .  .   wild card bit.
matching either  .   .   query,    one   match,  address.
  highest-priority match  returned. previous work describes  tcam-based.
implementation  space saving  unitary updates,  shows experimentally .
  several times faster  software solutions .
since  algorithms require  maintenance   independent instances .
space saving,   easy  see   algorithms   implemented given access.
  separate tcams,  requiring just   kbs  memory.   effort,.
  devise implementations   algorithms  use just  single commodity.
tcam. commodity tcams  store hundreds  thousands  millions  data.
entries .,  therefore  single tcam  store tens  instances  space saving.
even  . . .  description, alternatives,  simulation results.
appear  .
sliding windows  streams  deletions.  algorithms  described.
 work  insert-only streams, due   use  space saving. however, .
accuracy  coverage guarantees   hhh algorithms hold even   replace.
space saving   heavy hitter algorithms.     proofs  accuracy  coverage applied  inclusion-exclusion principle  express conditioned.
counts  terms  unconditioned counts,   used  fact   heavy hitter algorithm provides accurate estimates   unconditioned counts.  analysis.
 independent   heavy hitter algorithm used. hence   extend  results.
 additional scenarios  using  algorithms.  discuss  settings  sliding.
windows  streams wtih deletions   .
. experimental results.
  implemented two versions   algorithm    tested  using gcc.
version .   host  four single-core .-bit amd opteron . processors.
 running  .ghz   . cache  .  shared memory.  first.
version . termed hhh  . uses  heap-based implementation  space saving.
  handle arbitrary updates,   second version . termed unitary .
. uses  stream summary data structure    handle unitary updates.
 versions use  off-the-shelf implementation  .  space saving. .
optimizations,  well  different tradeoffs  time  space, may  possible.
 modifying  off-the-shelf implementation.  used  real packet trace .
www.caida.org .   experiments . .  tried  traces  confirm.
  results  demonstrative. note     graphs   color  may.
 display well  grayscale. throughout  experiments,  algorithms define.
 frequency    address    address pair    number  packets.
associated   item,  opposed   number  bytes  raw data. .
ensures   algorithms .including unitary. process exactly   updates.
 tested  algorithms   byte-wise  bit-wise granularities  one.
 two dimensions. bit-wise hierarchies   expensive  handle,  , .
number  nodes   lattice structure implied   hierarchy, becomes much.
larger. however,  may  useful  track approximate hhhs  bit-wise granularity.
 many realistic situations.  example,  single entity might control  subnet  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
.
.
addresses spanning just   bits rather   entire byte. however,  observed.
similar .relative. behavior   algorithms   bit-wise  byte-wise.
granularity,  display results   byte-wise hierarchies  succinctness.
 comparison  also implemented  full  partial ancestry algorithms.
 ., labeled full  partial respectively.  compare  algorithms. performance  several respects. time  memory usage,  size   output set,.
  accuracy   unconditioned count estimates.  algorithm performs.
 least  well    two  terms  output size  accuracy. except .
extremely small values  . .less   .,  correspond  extremely.
high accuracy guarantees,  two-dimensional algorithm  also significantly faster.
.  three times faster   parameter settings.  one-dimensional.
algorithm  also faster   competitors  values  . greater   .,.
 competitive across  values  .  algorithm uses slightly  memory.
  competitors. ,  discuss  aspect separately.
 summary,  one-dimensional algorithm  competitive  practice .
existing solutions,  possesses  desirable properties  existing solutions.
lack,   improved simplicity  ease  implementation, improved worst-case.
guarantees,   ability  preallocate space even without knowledge  stream.
length.  two-dimensional algorithm possesses     properties,  .
significantly faster  existing solutions  parameter values  primary practical.
interest.  main disadvantage   algorithms  slightly increased space usage.
   implementations  available online  .
memory.  versions   algorithm use  memory  full  partial.
 difference  hhh, partial,  full   small constant factor. unitary.
uses  twice  much space  hhh.  largest difference appears  one dimension,  shown  figure .  difference  much smaller  two dimensions,.
 shown  figure .   cases,  better space usage  partial comes .
 cost  significantly decreased accuracy  increased output size,  discussed.
.  conclude   situations   decreased accuracy  partial   tolerated,  memory usage   algorithms    major disadvantage,.
 hhh  full  similar memory requirements, especially  two dimensions.
ideally,    able  present  results   independent variable.
 programmer-level object   memory usage, rather   error-parameter.
.  practice,  programmer may  allowed .   space  deploy  hhh.
algorithm   sensor,    optimize speed  accuracy subject  .
constraint.    mapping  .  memory usage  straightforward.
  algorithm . space saving implementation uses . bytes per counter, .
 use  fixed . counters.,  mapping  less clear  partial  full,  .
space usage  data dependent,  counters added  pruned   course .
execution. figures .  . show  empirical mapping  space usage.
 .   fixed stream length   . . million  one-  two-dimensional.
bytewise hierarchies.  setting highlights  importance   improved worstcase bounds, even though  algorithm uses slightly  space  practice. .
  imperative  guarantee assigned memory will   exceeded,  .
algorithm allows   aggressive choice  error parameter  maintaining .
worst-case guarantee.
. accuracy comparison .
two dimensions.
figure . accuracy  output size comparisons.
 emphasize     optimize memory usage using characteristics .
 data,  suggested  theorem .   therefore likely   algorithms .
function  less memory  partial  full  many practical settings.
time.  observe    one  two dimensions,  unitary  hhh.
 faster  partial  full except  extremely small values  .  speed.
  algorithm   setting  .  illustrated   fixed stream length .
 . . million  figures .  .  algorithms  </doc>
<doc title='10_ALENEX_12.txt'>
downloaded  knowledgecenter.siam.org.
fast packed string matching  short patterns.
simone faro. . .uzhan .lekci.
abstract.
searching   occurrences   pattern   text   fundamental problem  computer science  applications .
many  fields, like natural language processing, information retrieval  computational biology.   last two.
decades  general trend  appeared trying  exploit .
power   word ram model  speed-up  performances.
 classical string matching algorithms.   model  algorithm operates  words  length , grouping blocks .
characters,  arithmetic  logic operations   words.
take one unit  time.
  paper  use specialized word-size packed string.
matching instructions, based   intel streaming simd.
extensions .sse. technology,  design  fast string.
matching algorithms   case  short patterns. .
 experimental results  turns  , despite .
quadratic worst case time complexity,  new presented algorithms become  clear winners   average  short.
patterns,  compared    effective algorithms known  literature.
. introduction.
given  text   length    pattern   length .
  alphabet .  size .,  exact string matching problem consists  finding  occurrences  .
pattern   .  problem   extensively studied  computer science    direct application.
 many areas. moreover string matching algorithms.
 basic components  many software applications .
play  important role  theoretical computer science.
 providing challenging problems.
  computational model   matching.
algorithm  restricted  read   characters  .
text one  one  optimal complexity  .,  .
achieved  first time   well known knuth-morrispratt algorithm . .kmp. however  many practical.
cases   possible  avoid reading   characters .
 text achieving sub-linear performances  average.
 optimal average . log. . time complexity .
 reached   first time   backward-dawg.dipartimento  matematica  informatica, universita. .
catania, italy.
.tak national research institute  electronics .
cryptology, turkey.
matching algorithm . .bdm. however,  algorithms.
  sub-linear average behavior may   read .
 text characters   worst case.   interesting .
note  many   algorithms   even worse.
.-time complexity   worst-case .
  last two decades  lot  work   made.
 order  exploit  power   word ram model.
 computation  speed-up classical string matching.
algorithms.   model,  computer operates .
words  length , thus blocks  characters  read .
processed  .  means  usual arithmetic.
 logic operations   words  take one unit .
time.
   solutions  exploit  word ram.
model  based   bit-parallelism technique  .
 packed string matching technique.
 bit-parallelism technique . takes advantage .
 intrinsic parallelism   bit operations inside .
computer word, allowing  cut   number .
operations   algorithm performs   factor .
 . bit-parallelism  particularly suitable  .
efficient simulation  nondeterministic automaton. .
first algorithm based  , named shift-or . .,.
simulates efficiently  nondeterministic version  .
kmp automaton  runs  .ndmw .,   still.
considered among  best practical algorithms  .
case   short patterns  small alphabets ., .
later   fast bdm-like algorithm .bndm., based.
  bit-parallel simulation   nondeterministic.
suffix automaton,  presented  .  variants.
  bndm algorithm ., ., ., .  among .
 practical efficient solutions  literature .see .,.
. however,  bit-parallel encoding requires one bit.
per pattern symbol,   total  dmw  computer words.
thus,  long   pattern fits   computer word,.
bit-parallel algorithms  extremely fast, otherwise.
 performances degrades considerably  dmw  grows.
though     techniques  maintain good.
performance   case  long patterns ., ., ., .,.
 limitation  intrinsic.
  packed string matching technique multiple.
characters  packed  one larger word,  .
 characters   compared  bulk rather .
individually.   context,   characters  .
string  drawn   alphabet  size .,   wlog . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
different characters fit   single word, using blog . bits.
per characters.  packing factor  . . wlog . .
 first theoretical result  packed string matching  proposed  fredriksson .  presented .
general scheme    applied  speed-up many.
pattern matching algorithms.  approach relies .
 use   four russian technique . tabulation., achieving  favorable cases  .-space .
.  log . . . . occ.-time complexity,  . . .
denotes  arbitrary small constant,  occ denotes.
 number  occurrences    . bille . presented.
 alternative solution  . nlog.  .  . occ.-time.
 . . .-space complexities   efficient segmentation  coding   kmp automaton. recently.
belazzougui . proposed  packed string matching algorithm  works ino. . .occ. time  .
space, reaching  optimal . . occ.-time bound .
. .  . . . however, none   results   .
practical interest.
 first algorithm  achieves good practical.
 theoretical results   recently proposed .
ben-kiki  . .  algorithm  based  two.
specialized packed string instructions,  pcmpestrm.
  pcmpestri instructions .,  reaches .
optimal .occ.-time complexity requiring  .
extra space. moreover  authors showed  .
algorithm turns    among  fastest string.
matching solutions   case   short patterns.
however,     noticed   current generation.
intel sandy bridge processors, pcmpestrm  pcmpestri.
 .-cycle throughput  .  .-cycle latency,.
respectively .
  length   searched pattern increases,.
another algorithm named streaming simd extensions.
filter .ssef., presented  .lekci  . . extended  multiple pattern matching  ., exploits.
 advantages   word-ram model. specifically.
 uses  filter method  inspects blocks  characters instead  reading  one  one. despite .
. worst case time complexity,  ssef algorithm.
turns    among  fastest solutions  searching  long patterns ., . efficient solutions .
 also designed  searching  packed dna sequences ., . however   paper    take.
 account  type  solutions since  require .
different type  data representation.
streaming simd technology offers singleinstructions  perform  variety  tests  packed.
strings. unfortunately  instructions  heavier.
  instructions provided    family .
 consequence   relatively high latencies. hence,.
  paper  focus  design  algorithms using.
instructions  low latency  throughput, .
compared   used  . specifically  present.
 new practical  efficient algorithm   exact.
packed string matching problem  turns   .
faster   best algorithms known  literature.
  case  short patterns.  algorithm, named.
exact packed string matching .epsm.,  based .
three different search procedures used , respectively,.
 short patterns . .  . . ., short patterns.
. .  . .  medium length patterns . . .
 use specialized packed string instructions  .
low latency  throughput,  compared  .
used  .  search procedures   . worst.
case time complexity. however,    good.
performances  average.
. notions  terminology.
throughout  paper  will make use   following.
notations  terminology.  string   length  . .
 represented   finite array . . .  characters.
  finite alphabet .  size . thus . will denote.
 . .-st character  ,  . .  . ,  . . . .
will denote  factor . substring.   contained.
  . . .-st   . . .-st characters .
,  . .  .  . .   cases  will denote .
  . . .-st character  ,    . . .
 . . . . . .
 indicate  symbol   number  bits .
 computer word   symbol . . dlog . .
number  bits used  encoding  single character.
  alphabet .  number  characters  .
alphabet  fit   single word  shown  . .
. without lose  generality  will assume along.
 paper  . divides    .   even value.
 chunks  . characters,  string   represented.
  array  . . .  . .  length  . . . . . .
 particular  denote  . . . . . ., .
 . . . . . .,  . .  . .  last.
block .   complete   mod . . .  .
case,  rightmost remaining characters   block.
 set  zero.
although different values  .  .  possible,.
  cases  assume  . . .  . . ., .
   common case  working  characters.
 ascii code    word ram model  .-bit.
registers,   almost  available  recent commodity processors supporting single instruction multiple data .simd. operations.
finally,  recall  notation   bitwise infix.
operators  computer words, namely  bitwise .
.,  bitwise  .   left shift .
operator . shifts   left  first argument  .
number  bits equal   second argument.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.  new packed string matching algorithm.
  section  present  new packed string matching.
algorithm, named exact packed string matching algorithm .epsm.,  turns    efficient  .
case  short patterns. epsm  based  three different.
auxiliary algorithms,   name epsma, epsmb.
 epsmc, respectively.
 first two auxiliary algorithms  designed .
search  patterns  length,  , .  .
length   pattern  longer  .  algorithms.
adopt  filter mechanism.  first search   substring   pattern  length . ,   candidate occurrence   found,  naive check follows.
 third algorithm adopts  filtering based solution.
 three algorithms run  . worst case time.
complexity  use, respectively, .min.,., .
 . additional space,     constant.
parameter. however,   . .  epsma.
 epsmb algorithms reach, respectively,  .
.
. . occ.  . . occ. time complexity.  first.
search procedure  designed   extremely fast .
 case   short patterns, .   . . ,.
 second algorithm turns     good choice.
 . .  . .,   third algorithm turns.
   effective   . .  practical cases.
 tuned  epsm algorithm  order  run epsma.
 . .  . ., epsmb  . .  . .,   run.
epsmc    cases.
  follows,  first describe  section . .
computational model  use   description  .
solutions.   independently present  three.
auxiliary algorithms epsma,  section ., epsmb,.
 section .,  epsmc  section .
.  model.
  design   algorithms  use specialized.
word-size packed string matching instructions, based .
 intel streaming simd extensions .sse. technology.
simd instructions exist  many recent microprocessors supporting parallel execution   operations.
 multiple data simultaneously via  set  special instructions working  limited number  special registers. although  usage  simd  explored deeply.
 multimedia processing, implementation  encryption.decryption algorithms,    scientific calculations,     much addressed  pattern.
matching.
  model  computation  suppose  .
  number  bits   word  .   size .
 alphabet.  indicate   symbol . . wlog .
 number  characters  fit   single computer.
word.
  practical applications   . . .
.ascii code. moreover sse specialized instructions.
allow  work  .-bit registers, thus reading .
processing blocks  sixteen .-bit characters   single.
time unit .thus . . .
  design   algorithms  make use  .
following specialized word-size packed instructions. .
 instruction  describe     emulated.
 using sse specialized intrinsics.
wscmp., . .word-size compare instruction.
compares two w-bit words, handled   block  .
characters.  particular   . . . . . . .
 . . . . . .   two w-bit integer parameters,.
wscmp., . returns  .-bit value  . . . . . .,.
  . .      . ,   . .
otherwise. fig. shows  example   application.
 wscmp., ., assuming  . ., . . .  . . .
 wscmp specialized instruction   emulated.
 constant time  using  following sequence .
specialized simd instructions.
.  cmpeq epi., .
 .  movemask epi.
specifically   cmpeq epi. instruction compares two .-bit words, handled   block  sixteen .bit values,  returns  .-bit value  . . . . . .,.
  . .
.      . ,   . .
. otherwise.    .-cycle throughput   .-cycle latency.
  movemask epi. instruction gets  . bit parameter , handled  sixteen .-bit integers,  creates.
 .-bit mask    significant bits   .
integers  ,  zero extends  upper bits.
wsmatch., . .word-size matching instruction.
reports  occurrences   short string    w-bit.
parameter , handled   string  . characters. .
parameter    string  length  . .
specifically,   . . . . . .,   . . . . . .,.
  wsmatch., . instruction returns  .-bit.
integer value,  . . . . . .,   . .  .
  . .    . . . . .  . ., .  occurrence.
    begins  position . notice   . . .
.  .  . ., since  occurrence      begin.
  position greater  . fig. shows  example.
  application  wsmatch., ., assuming  . .,.
. . ., . . .   . .
 wsmatch., . instruction   emulated .
constant time  using  following sequence  simd.
specialized instructions.
.  mpsadbw epu., .
.  cmpeq epi., .
 .  movemask epi.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
figure .  example   application  wscmp., ., assuming  . ., . . .  . . .
. . . . . . . . . . . . .
. . . . . . . . . . . .
. . . .
. . . . . . . . . . . . .
figure .  example   application  wsmatch., ., assuming  . ., . . ., . . .   . .
    .-bit register   bits set  ., .
 . .
specifically   mpsadbw epu., . instruction gets two .-bit words, handled   block .
sixteen .-bit values,  returns  .-bit value  .
. . . . . .handled   block  eight .-bit values.,.
   computed   .
.
. . .  . .
 . . . . . .
thus     . .
.     . .
   . . . . . ., .  occurrence   prefix.
   length . begins    position . .
 mpsadbw epu. instruction  .-cycle throughput   .-cycle latency.   cmpeq epi. .
 movemask epi. instructions   described.
.
wsblend., . .word-size blend instruction.
blends two w-bit parameters, handled  two blocks.
 . characters. specifically   . . . . . . .
 . . . . . .,  instruction returns  w-bit integer.
 . . . . . .,   . .,  . .  .
.,   . .  . .  . ., .  .
.
.
.
.
. . . . . . . . fig. shows  example.
  application  wsmatch., ., assuming  . .,.
. . .  . . .
 wsblend., . instruction   emulated .
constant time  using  following sequence  simd.
specialized instructions.
.  blend epi., , .
shuffle .  shuffle., ., ., .
 .  shu. epi., shuffle.
 instruction blends two .-bit integers,  .
. . . . .   . . . . . ., handled  packed .-bit.
integers, according   third parameter .  particular.
 returns  .-bit integer  . . . . . .   . .
  . .,   .  otherwise.   set  . .
. .
get  . .   blend epi. instruction  .-cycle throughput   .-cycle latency.
  shu. epi. instruction shu.  w-bit parameter,  . ., handled  four .-bit values,.
according   order    shuffle macro. .
 case  get  . .   shu. epi.
instruction  .-cycle throughput   .-cycle latency.
wscrc. .word-size cyclic redundancy check.
computes  .-bit cyclic redundancy checksum .crc.
signature   w-bit parameter.    error-detecting.
code commonly used  digital networks  storage.
devices  detect accidental changes  raw data .
 also  used   hash function.
 wscrc. instruction   emulated  constant time  using   crc. . simd specialized instructions,  computes  . bit cyclic.
redundancy check   .-bit block according   polynomial.  instruction   .-cycle throughput .
 .-cycle latency, thus provides  robust  fast way.
 computing hash values.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . .
.
. . . .
. . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
figure .  example   application  wsmatch., ., assuming  . ., . . .  . . .
additional specialized instructions.
 addition    listed instructions, given .
.-bit register ,   description  make use .
 symbol .  indicate  set  bits   whose.
value  set.  formally, given  .-bit register.
 . . . . . .,   . . . . . .  .
.   . . moreover, given  value  . ,  use.
 simplicity  expression . .  indicate  set.
 values .  .  . .
 cardinality   set .   computed .
constant time  using  simd specialized instructions  popcnt .  calculates  number.
 bits   parameter    set  .  instruction  .-cycle throughput   .-cycle latency.
differently  list  values  .   efficiently.
listed  .-time  .-space,  using  tabulation approach, ino.-time ando.-space.  .
latter case  need  .-time preprocessing phase.
 order  address  . possible registers.
  now ready  describe  three auxiliary algorithms used   epsm algorithm.  pseudocode.
  three algorithms  shown  fig. .
. epsma. searching   short patterns.
 epsma algorithm  designed   extremely fast.
  case   short patterns  although  .
 adapted  work  longer patterns  performances.
degrades   length   patterns increase.
 preprocessing   algorithm .lines . .
computed   prefix   pattern  length . .
min., . .  . .   whole pattern  preprocessed  searched, otherwise  algorithm works .
 filter, searching   occurrences   prefix .
length . ,   occurrence   found,.
naively checking  whole occurrence   pattern.
specifically  preprocessing phase consists  constructing  array   . different strings  length.
.  string   array exactly fits   word  .
bits.  i-th string   array  consists  . copies.
  character .  formally  string ., .
. .  . .,  defined  . . .  instance, .
 .    pattern  length  . ., . . .   . .,.
  consists  two strings  length . . ., defined  . . .  . . .  preprocessing.
phase   algorithm requires .min., . .-time.
 .min., . .-space.
 searching phase   algorithm .lines .
processes  text   chunks  . characters. .
 . . . .    . . . . .    string .
represented  chunks  characters.  block  .
text, ,  compared   strings   array .
using  instruction wscmp.
  . . . . . .   .-bit register returned.
  instruction wscmp., .,  . .  . . .
  easily proved   . .      k-th.
character   block   equal   , .   .
 . .  .remember  . . .
. finally .
 . . . . . .   .-bit register defined   .
. . . . . . . . . . . . . . . . . .
  easy  prove  . . . . .   occurrence beginning  position         . .
 fact  . .   . . . . .,   . . . . .
. . .,.
 implies  . . . . ,   . . . . .
. . .
,   . .  algorithm reports  occurrences.
  pattern  positions . . .,  . otherwise.
 know  occurrences   prefix   pattern.
 length . begin  positions . . . thus .
algorithm checks  occurrences beginning   positions.
  maintain,   value ,  . .  . ., .
list   values   set .,  naive check  .
occurrences   done  .-time.   .
.  occurrences   reported  .-time.
finally, observe   . . . possible occurrences.
crossing  blocks   .  naively checked .
 algorithm .lines .
 overall time complexity   epsma algorithm  .,    worst case  naive check.
 required   position   text. however, .
 . .  epsma algorithm achieves  .occ. time.
complexity,  occ   number  occurrences .
 pattern    text .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
epsma .,, , .
. . . min.,.
.  . .  . . . .
.   . .  . . .
. . .
.  . .  . . .
.  . .
.   . .  . . . .
.  . wscmp., .
.  .  . . . .
.   . .
.  report occurrences  . .
. else check positions . .
.   . .  . . .
. check position . . .
epsmb .,, , .
. . . min.,.
. . . . . . . .
.  . .  . . .
.  . wsmatch., .
.   . . .
.   . .
.  report occurrences  . .
. else check positions . .
.  . wsblend., .
.  . wsmatch., .
.   . . .
.   . .
.  report occurrences  . .
.
. .
. else check positions . .
.
. .
epsmc .,, , .
. mask . .
.  . .  . . .
.  . wscrc. . .
.  .  . mask.
. . . . .
. . . . . . .
.  . .  . . .
.  . wscrc.
.  .  . mask.
.    . . .
.  . . .  . .
.  check position . .
. . . .
figure .  epsma .  top.,  epsmb .
 middle.   epsmc .  bottom. auxiliary.
algorithms.
. epsmb. searching  short patterns .
epsmb searches   whole pattern   length.
 less  equal  .  works   filter algorithm.
 longer patterns. however,   based   .
efficient filtering technique  turns    faster .
 second case.
 .   minimum  .  .
moreover  .   prefix    length . .
searching phase   algorithm .lines . processes.
 text   chunks  . characters.   . . . .
  . . . . .    string  represented  chunks.
 characters.  block   text, ,  searched.
one  one  occurrences   string . using .
instruction wsmatch.
specifically,   . . . . . .   .-bit.
register returned   instruction wsmatch., .
., .
. .  . .     . .     .
occurrence  . begins  positions    block ,.
 . .  . . ,  . .  . hence  . .
 algorithm simply returns positions . ,  .
 . . otherwise,  .
. . ,  algorithm naively.
checks   whole occurrences   pattern starting.
 positions . ,    . .
notice  generally packed string matching instructions allow  read  blocks   . characters . bits   case  sse instructions., .
 . . . . occurrences   pattern beginning   second half   block   checked.
separately.  particular  new block, , obtained .
applying  instruction wsblend., .,  processed.
  similar way  block .   case  report.
 occurrences   pattern beginning  positions.
. . . . ,  . .  . . one may argue .
 blending  used instead  simply shifting  window.  reason   sse instructions used  .
context require  operands   .-byte aligned .
memory,   performance degrades significantly.
otherwise. thus, blending   advantageous.
 resulting algorithm   . worst case.
time complexity  require . additional space.
  . .  algorithm reaches  optimal.
. occ. worst case time complexity.
. epsmc. searching  medium length.
patterns  epsmc algorithm  designed  .
faster  medium length patterns.   based  .
simple filtering method  uses  hash function .
computing fingerprint values  blocks  . characters.
  similar way   rabin-karp algorithm . .
fingerprint values  computed  using  hash function.
 . . . ., ., . . . , . . .,   constant parameter .
. practice  chose  . .
 function   computed    fast way .
using  wscrc specialized instruction,   particular.
. . wscrc. . .,    . .
  preprocessing phase .lines .  fingerprint value   bits  computed   substrings .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 pattern  length .   table   size . .
computed  order  store starting positions   substrings   pattern, indexed   fingerprint values.  particular   . . . . . .
.,   . .  . .
 preprocessing phase   epsmc algorithm.
takes . .-time.
  . . . .    . . . . .   .
string  represented  chunks  characters. .
 searching phase .lines .  epsmc algorithm.
inspects  blocks   text  steps  . .
positions.   inspected block   fingerprint.
value .  computed   positions   set.
. .  . .  naively checked.  epsmc.
algorithm   . worst case time complexity .
turns     effective  practical cases.
. experimental results.
  section  present experimental results  order.
 compare  performances   newly presented.
algorithms   best solutions known  literature   case  short patterns.  consider  .
fastest algorithms   case  short patterns  listed.
  recent experimental evaluation  faro  lecroq.
., .  particular  compared epsm  .
following algorithms.
  hash algorithm using groups   characters .
.hashq.
  extended backward oracle matching algorithm.
., . .ebom.
  tvsbs algorithm . .tvsbs.
  shift-or algorithm . .
  shift-or algorithm  q-grams . .ufndmq.
  fast-average-optimal-shift-or algorithm .
.faosoq.
  backward dawg matching algorithm using.
q-grams . .bndmq.
  simplified bndmq algorithm . .sbndmq.
  forward bndmq algorithm ., ., .
.fbndmq.
  crochemore-perrin algorithm using sse instructions . .ssecp.
 remember   epsm algorithm consists .
 epsma algorithm,   . .,   epsmb.
algorithm  . .  . .,    epsmc.
algorithm   . .
  case  algorithms making use   grams,.
 value   ranges   set ., ., .  algorithms.
  implemented    programming language.
   tested using  smart tool .  exact.
string matching.  experiments  executed locally.
  machine running ubuntu . .oneiric.  intel.
. processor  . memory. algorithms .
 compared  terms  running times, including.
 preprocessing time.   evaluation  used.
 genome sequence,  protein sequence   natural.
language text .english language.,  sequences  .
 sequences  provided   smart research tool.
  input file,   searched sets  .
patterns  fixed length  randomly extracted  .
text,   ranging  .  . .short patterns. ,.
 mean   running times   reported.
table ., table .  table . show  experimental results obtained   gnome sequence,  protein sequence   natural language text, respectively.
  case  algorithms using q-grams  .
reported   best result obtained   variants.
 values    obtained  best running times.
 reported  apices. running times  expressed .
hundredths  seconds, best results   boldfaced.
 underlined.
 experimental results  turns   .
epsm algorithm  mostly  best performances .
short patterns.  searching   genome sequence .
 second    bndmq algorithm  . .  . .
   ssecp algorithm   . . observe.
however   epsm algorithm  .  . times.
faster   ssecp algorithm   cases.
 searching   natural language text .
epsm algorithm obtains   cases  best results,.
  second  bndm based algorithms  .
. .  . .
 increasing lengths   pattern  performances   epsm algorithm remain stable, underlining  linear trend  average. however,  performances   algorithms based  shift heuristics,.
slightly increases.    evident  searching.
  protein sequence,   algorithms based .
bit-parallelism   grams turn     faster.
solutions  longer patterns. however,   latter.
cases  epsm algorithm  always  close  best.
solutions.
  interesting  observe   epsm algorithm.
 faster   ssecp algorithm  almost  cases,.
  gap   evident   case  longer.
patterns.  fact, despite  optimal worst case time.
complexity,  ssecp algorithm shows  increasing.
trend  average,   epsm algorithm shows .
linear behavior.
. conclusions.
 presented  new packed exact string matching.
algorithm based   intel streaming simd extensions.
technology.  presented algorithm, named epsm, .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 . . . . . . . . . . . .
table . experimental results  searching . patterns   natural language text.
based  three auxiliary algorithms   used .
. .  . .,  . .,   . ., respectively. despite.
 .-worst case time complexity  resulting.
algorithm turns     fast   case  .
short patterns.   experimental results  turns.
   epsm algorithm   general  best.
solutions   . .    interesting .
investigate  possibility  improve  performances.
 packed string matching algorithms  introducing.
shift heuristics.
</doc>
<doc title='11_ALENEX_10.txt'>
downloaded  knowledgecenter.siam.org.
 parallelizing matrix multiplication   column-row method.
andrea campagna. konstantin kutzkov. rasmus pagh.
abstract.
 consider  problem  sparse matrix multiplication .
 column row method   distributed setting  .
matrix product   necessarily sparse.  present  surprisingly simple method  .consistent. parallel processing  sparse outer products .column-row vector products.
 several processors,   communication-avoiding setting.
  processor   copy   input.  method.
 consistent   sense   given output entry  always assigned    processor independently  .
specific structure   outer product.  show guarantees   work done   processor,  achieve linear.
speedup    point   cost  dominated .
reading  input.  method gives  way  distributing.
. parallelizing. matrix product computations  settings.
  main bottlenecks  storing  result matrix,.
 inter-processor communication. motivated  observations  real data  often  absolute values   entries.
  product adhere   power law,  combine  approach  frequent items mining algorithms  show .
 obtain  tight approximation   weight   heaviest.
entries   product matrix.
  case study  present  application   approach .
frequent pair mining  transactional data streams,  problem    phrased  terms  sparse ., .-integer.
matrix multiplication   column-row method. experimental evaluation   proposed method  real-life data.
supports  theoretical findings.
. introduction.
column row vector products .aka. outer products. .
ubiquitous  scientific computing. often one needs .
compute  aggregate function  several products.
 notably,  product  two matrices   written   sum  outer products. observe   product  two sparse matrices   dense   worst.
case,  will typically  much less sparse   input matrices.    practical problem  algorithms.
 multiply  high-dimensional, sparse matrices,.
.work supported   danish national research council.
  sapere aude program.
.acam.itu.,  university  copenhagen, denmark.
.konk.itu.,  university  copenhagen, denmark.
.pagh.itu.,  university  copenhagen, denmark.
   markov cluster algorithm . popular .
bio-informatics.   approaches  approximating matrix products   use less space ., . .
   address   balance  work   parallel  distributed setting. state-of-the-art clusters .
bio-informatics  easily   combined main memory capacity  .   . thus   potential.
 computing huge result matrices  computation .
storage   used efficiently.
based   observation  handling  output.
data, rather   input data,    main bottleneck  present  method  parallelizing  computation  sparse outer products   setting  .
input  assumed   broadcast.   communication  allowed .  , algorithms need   communication avoiding.   best knowledge   .
previous work  .sparse. matrix multiplication  .
 setting.  standard approach   assume  .
input  distributed among processors,   communicate  needed.  noted  demmel  . .
communication  often  bottleneck  parallel sparse.
matrix computations.  believe    settings.
.   ethernet-connected cluster.  broadcast  cheap,   total capacity  point-to-point.
communication   bottleneck,  approach  trades.
broadcasting  input  reduced inter-processor communication  improve performance, assuming  .
total work remains      computation.
 load-balanced well.
     communication  .
broadcast   input    need  consider  particular parallel  distributed memory model. however,.
 concreteness  will  now  speak  parallelization across multiple processors.  practical reasons  also restrict  experiments   setting  .
multi-core architecture.  algorithm avoids communication  distributing  matrix output entries  .
consistent way, .,  processor will process either.
 nonzero terms contributing   given output entry,.
 none  .   case study  consider . matrix products arising  data mining applications, .
 task   approximate  largest entries   result matrix well.   done  combining  method.
 parallelizing outer products  known heavy hitter.
algorithms.
. copyright . siam.
unauthorized reproduction   article  prohibited.
 algorithm works   data stream setting, .
 vectors  given one   time,  space  saving past vectors   available.  contrast, traditional.
work  parallel matrix multiplication requires  .
whole input   stored   memory   system. however,  main point    space saved.
  storing  input,  rather   .possibly non-dense. output  distributed evenly among .
processors.  believe    many interesting opportunities ahead  parallel processing  data.
streams, especially  computations  require .
 .quasi-. linear time   input size.
. background.
parallel matrix multiplication.  major algorithmic problem    approached using .
method  sparse matrix multiplication.  product.
 matrices , . .   computed  summing.
  outer products  columns    rows  .
assuming  outer products  dense  simple algorithm distributes  computation among several processors    work load  equal   .
 need  communication   processors .
shared data structures.  one   processors will sum.
  submatrix   outer products  size . . . ,.
   column  row vectors    read .
 processor.  approach, first described  cannon .,  known  achieve  good scalability .
 growing number  processors.
however,   situation   outer products.
 expected   sparse,  simple algorithm  .
guaranteed  achieve good scalability.  reason .
    know  advance  specific structure.
  output matrix   might happen  certain.
.
 . . -submatrices  dense  many others .
sparse,  implies   workload   balanced.
among processors.  approach  avoid  problem.
  initially permute  rows .resp. columns. .
 left .resp. right. input matrix.  corresponds.
 permuting  rows  columns   output.
matrix. however,  approach  vulnerable  .
situation    nonzero output entries  .
well distributed among rows  columns.  example,.
 half   work  computing  output relates .
 single output row  column,  work will  .
distributed among.
.
    processors.
also,   often  case   . know .
advance  exact dimensions   sparse matrices.
   generated   streaming fashion. matrix.
multiplication   streaming setting  recently.
received  attention ., ., . randomized.
algorithms   designed approximating  values.
 individual entries   matrix product running .
subcubic time  subquadratic space  one  two.
passes   input matrices  requiring access .
 certain columns  rows.
 refer  .   overview  state-of-the-art.
results  parallel matrix multiplication relying  interprocessor communication.
. overview  contributions.
parallel sparse matrix multiplication. hashing  long  used  load balancing tasks, mapping.
 given task    random bucket .  good hash.
function will distribute  tasks almost evenly among.
 buckets,   different processors will handle.
given buckets  get  similar load.  computing  matrix product   think   entry  .
output matrix   task. however,   decide  simply hash  entries   product . parallel.,  lot .
inter-processor communication will  needed  identify  entries   bucket   nonzero  .
given outer product.  approach turns  around,.
 uses  carefully chosen hash function  allows .
processor  efficiently identify  output entries hashing   given bucket.  particular  processor ,.
without communication  shared data structures, process exactly  terms  belong   bucket,  .
additional overhead   linear   size   input vectors.  show   approach  particularly.
well suited  matrix multiplication   column-row.
method  individual outer products  sparse .
  resulting matrix product.
approximate matrix multiplication.  already mentioned, randomized algorithms running .
subcubic time, using  small amount  memory .
performing   limited number  scans   input.
matrix  gaining    popularity ., .,.
. instead  computing exactly  matrix product,.
 algorithms return  approximation  individual.
entries.  matrix products   entries adhere .
 skewed distribution,  approximation   heaviest.
entries  known     high quality.  reader .
referred  .    detailed discussion   list.
 applications  approximate matrix multiplication.
inspired     observations  real.
data,  compose  parallel matrix multiplication.
method  two known algorithms  finding frequent.
items  data streams. space-saving .  countsketch .  former gives deterministic upper.
 lower bounds   true value   latter .
 unbiased estimator.  algorithms  capable.
 handling weighted updates  space-saving .
restricted   positive updates.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 concretely,  main contributions   summarized  follows.
.  new algorithm   parallelization  .
multiplication  sparse matrices   column row.
method.
.  combination     approximate.
matrix multiplication.
.  theoretically analyze  expected time complexity,  load balancing among cores   approximation guarantee   algorithm  .
assumption  zipfian distribution   entries.
weights . common situation  many real-life applications.  particular,  count-sketch.
 always based   initial hashing.splitting.
step,  believe   work   first  investigate  composition  hashing  spacesaving  approximate matrix multiplication.
. extensive experimental evaluation   approach.
  context  frequent pair mining  transactional data streams.
. preliminaries.
notation  vectors ,  .   outer product.
     denoted   . .  matrices.
, . .  denote    ith column .
     jth row    ,  . . .
. . ., . . . ,  . .  ith element   vector .
 written  .  weight   entry ., . .
 product    inner product   ith row .
  jth column  ,  ,  . . alternatively,.
  column-row notation    also written .
. ., .,  sum   ., . entry.
  outer products.  clear   context .
refer  entries  larger absolute weight  heavy.
entries.  number  non-zero entries   .  .
written  .
 family   functions    .  k-wise.
independent    function  .  . . chosen.
uniformly  random    holds.
. . . . . . . . . . . . . . . . .
 distinct elements  .  , . .  . ,   . . .
will refer   function chosen uniformly  random .
 k-wise independent family    k-wise independent.
function.
 elements   adhere  zipfian distribution.
 parameters      . .
   absolute.
weight    ith  heavy element   .
frequent items mining algorithms.  will.
use two well-known frequent item mining algorithms.
count-sketch .  space-saving .  subroutines.  give  brief overview    work.
 count-sketch every item   hashed  .
hash function  . . . .   position   array.
 consisting   estimators,     .
real number. upon updating  weight   item.
,  add .  .   corresponding estimator.
 using  uniform sign hash function . evaluating.
  either .  .  processing  stream.
 frequency   given item    estimated .
. .  intuition     heavy item .
contribution   items will cancel   will.
 significantly affect  estimate.     .
pairwise independent    sufficient  show .
  appropriate number  estimators   skewed.
distribution  item weights  heavy items will .
assigned   one estimator  high probability.
 probability  correct estimates   amplified.
 working   . . hash functions  returning .
median    estimates upon  query   frequency.
  given item.
 space-saving algorithm offers upper .
lower frequency bounds, rather   unbiased estimator.  keeps  summary   stream consisting  .
triples .itemj , countj , overestimationj., . .  . . .
. triples  sorted according   count value. upon.
 arrival   new item   algorithm distinguishes.
  following cases.
.    . slots  already full,  insert  new.
triple  ., ., .
.    already recorded,  increase  corresponding counter  .  update  order   summary.
. otherwise,  replace  last triple.
.item., count., overestimation.   new.
triple ., count. . ., count.
 processing  stream  return   estimate .
 item weight either  counter   summary , .
 recorded,  overestimation   last counter .
 list.   stream  length ,  overestimation .
 given counter  bounded  .    guaranteed.
  item occurring   . times will .
  summary.  comes   fact  .
increase   overestimation   item  recorded.
  summary  witnessed  . different items  .
summary    happen   . times.
however,  algorithm  known  perform extremely.
well  practice  report almost  exact weights .
 heaviest entries, see . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 natural generalization   algorithms works.
 weighted positive updates.   straightforward.
 count-sketch,   space-saving  .
issue  consider    efficiently update  summary.  solution achieving amortized constant time per.
update  presented  .
.  approach.
 algorithm. assume   given matrices.
, . .     stored  column-major.
ordered triples    row-major ordered triples. .
 overview  efficient implementations   model .
refer  chapter .  .  skeleton   algorithm.
  following.
. define  count-sketch estimators . alternatively space-saving summaries  . triples, .
 small constant .
.   kth column  row vectors  . ,  . ,.
 . ., hash  entry    one  .
estimators.
.   outer products   processed return.
 estimate   entries.
  parallel version,  processor keeps track .
 subset   estimators,   total space remains.
fixed. thus,     shared nothing model  .
need   shared memory .   requirement  .
 processor sees  column  row vectors  .
outer product. pseudocode   algorithm  given .
figure .  refer     crop algorithm, .
refers   fact   processor crops  output.
matrix  produce  small fraction  ,   also .
acronym  .column-row parallel.
 crucial property   analysis  experimental.
evaluations    heaviest entries   often.
collide,  thus  obtain high quality estimates.
  weight.  combine two different ways .
estimating  weight   heaviest entries based .
 count-sketch  space-saving algorithms. .
particular,  use  distribution hash function  .
. . . . .  split  set  entries  . parts,.
 use  space-saving sketch   count-sketch.
estimator   part.  size .   hash table.
  size   space-saving sketch determines.
 accuracy   estimates.
parallel processing  entries. .vely  .
just iterate   entries   outer product,.
   like  algorithm  runs  time linear.
  number  nonzero elements   input vectors.
  entries hashing   given interval   hash.
table.   words, given sufficient parallelism  .
handle  given data rate even     huge number.
 entries   given outer product.
lemma .  ,  .  . .  pairwise independent.
hash functions. given input vectors     .
nonzero entries    interval  . ., ., . . . , .
 . .  .  . .   construct eabl ,  set .
entries occurring   outer product  hashing  .
value  ,  expected time .eabl . .
proof.  exploit  special structure   hash.
functions. ., . . . . . mod .   .wise independent hash function ,  .  . . .
,  . .   easy  show   construction.
implies   .  . .  also pairwise independent.
 find  entries   nonzero value    hash.
 ., .  first sort  indices   nonzero value.
     according   hash value  arrays.
      , respectively. entries  .
hash value   right range correspond  elements .
    sum  ., . . . . , . . . since.
 hash values  pairwise independent   sort.
 bucket sort  expected linear time. one way  find.
 entries   right range    iterate .
elements  ,     two binary searches.
   find  values   right ranges. however,.
    improved  processing   sorted.
order,  exploiting   entries  hash value .
 right range correspond  intervals    will.
 moving monotonically left. thus,   fixed index.
  find  entries ., .,  . .   hash value .
., . ., .  time linear   number  .
entries.  brings   time  .eabl . .
parameters.  will assume  data  .
lightly skewed   . .  will distinguish .
 cases  . .  . .   . .  order .
keep  presentation concise  particular case  . .
will   analyzed.   analysis  will also use.
  parameter  total number  nonzero entries .
occurring   matrix product.  value   .
 known  advance. one  either  conservative.
 assume  . .,    case  positive.
input matrices use efficient methods  estimating .
number  nonzero entries .  two passes   input.
 allowed.
. analysis.
load balancing. first  show  pairwise independent hashing  entries guarantees good load balance among processors.  show   outer products    number  non-zero entries  considerably bigger   number  processors, crop.
achieves good scalability  high probability.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
function crop.
input. matrices , . ., interval ., .,  list . spacesaving summaries    . entries, array  . real.
numbers , pairwise independent hash functions ,  .
. .,  .  . ., .
.   . . .
.  . ith column  ,  . ith row  .
.  . hash., , , , ., .
.   .  .
. update space-saving summary . .
 entry .
. . . . .  . .
function hash.
input. pairwise independent hash functions ,  .  . .,.
vectors  . ,  . , interval ., .
. sort  nonzero entries     according     .
arrays   , respectively.
.  . .length,  . .
.   . .  .length. . .
.  . . .  .
.   . .  .  . .
.  . .
.  . . .  .
.  .  . .
.   . .length. break for-loop.
.  . . .  .
.  .  . ., .
.   . .length.  .  . .
. else. break for-loop.
. return  set .
figure . .crop algorithm.  high-level description   single.
run   algorithm.  description   hash functions.
 .  . .   .  . ., .  sent   processors .
 computation starts.   detailed pseudocode description.
 space-saving  count-sketch  reader  referred  .
original works ., .  processing  input matrices one .
obtain  estimate  individual entries   corresponding.
space-saving summary  count-sketch estimator.
theorem . suppose  run  instances  crop.
 disjoint intervals    size,   input .
column  row vectors ,  . .   . . . .
  . .  probability   number  entries.
processed   given instance will deviate   .
.   expected value  bounded  . .
 . . .
proof.  distribute  nonzero entries    .
processors.  consider one    processors, say.
.     indicator random variable denoting.
whether  entry   hashed   range  .
clearly, . . .   .
.
. . thus, .
 . .  . since  hash function  pairwise.
independent   variance      . .
.  . .
.
.
.
 . . . .
.
.
.
 .
.
 . . .  . using chebyshev. inequality.
  . .  estimate  probability  .
number deviates    . .
. . . . . . .  .
. .
.
 .
. .
.
. .
.
. .
  theorem essentially says   .
expect  sufficient number  entries per core   given.
outer product,  probability   work load will.
deviate     small constant factor  .
expectation, namely .,   small. thus, .
expect   computation    small fraction.
  outer products will   well balanced among.
processors   will  considerably affect  total.
performance.
  following  present results   estimates.
based  space-saving .giving guarantees  .
upper.lower bounds.,  well   unbiased countsketch estimator returned   algorithm.
quality  estimates.
theorem .  ,   .  nonnegative matrices.
     nonzero entries   adhering .
 zipfian distribution  parameters   . .
processing  outer products aibi, . .  . ,  crop.
  buckets   space-saving data structure  .
entries.
.   . .,  entry  weight  least . . . .
recorded  one   space-saving summaries .
probability   .  running .log . .
instances  crop  parallel,  report  entries.
 weight . . .    probability .
least . .
.   . .,  entry  weight  least.
.max. . ,.
.
. .  recorded  one  .
space-saving summaries  probability  .
.  running .log . . instances  crop.
 parallel,   . max., . .,  report .
entries  weight .max. . ,.
.
. .  .
 probability  least . .
proof.   minimum absolute weight  heavy.
entries  ., . . . .  end   proof .
will obtain bounds  . depending  .  will.
estimate  probability   heavy entry   .
reported.   zipfian distribution  obtain .
 . . . .
.
 entries will  weight  . .
   bucket  hashes .  first consider .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
case    . entries  weight  .
 hashed  .  expected number  heavy entries.
hashed    .   . .  get  markov.
inequality   probability .    .
heavy entries will land      .  already.
discussed  section .,   total weight  non-heavy.
entries hashed    less  .   .
heavy entries hash  ,   heavy entries will .
reported.   .
.
. .
   total weight .
non-heavy entries.   following  will use  fact.
  . .   . .   . .
  . .,     number  distinct entries.
  matrix product.  follows  integration .
 corresponding continuous function.   expect.
non-heavy entries  total weight .  land  .
    indicator random variable denoting.
whether  jth non-heavy entry  hashed   .
 .
.
.  . clearly, . . . applying.
markov. inequality  obtain . . . . . .
.  want . . .   . . .
  . . thus together   bound.
  number  heavy entries   bucket  set.
 . max. . .
.
. .
.
 ., .
.
. . similarly,   .
.    . ., hence  bound  .
. . .
.
. .
.
 . thus,   . .,  will consider entries.
heavy   weight  . . .max. . ,.
.
. . .
  . .  . . . . .   union bound .
probability   entry  weight  least .  .
reported    . . . . .
 running  copies   algorithm  parallel.
 reporting  entries   reported  .
summary   least . cases,   amplify .
probability   correct estimate  exp. .
analysis follows  standard application  chernoff.
inequality. thus,   given values    .
  heavy entry  bound  probability  .
 reported  . .
.
   . .   . .,.
respectively. since  number  heavy entries  .
case  bounded  .  ,   union bound .
bound  error  .   heavy entry will  .
reported.
count-sketch  analyzed  zipfian data  .
original publication .
theorem . .  , . .    entries.
  adhere   zipfian distribution  parameters.
   . .  processing  outer products.
akbk  crop   count-sketch estimators, .
entry  approximated  additive error   .
. ckz .  probability   .  running .
. . instances  parallel  additive error   .
. ckz .   entry holds  probability  least . .
 lower bound.  present  lower bound  .
space needed  report  heaviest entry   matrix.
product   column-row method.  course, .
applies also   harder problem,   reporting .
larger set  heavy entries,  estimates.
theorem .  algorithm  always outputs .
heaviest entry   matrix product ,  even just .
weight   heaviest entry,   one pass  .
outer products aibi,  . ., must encode   state.
 entry weights,   sense   two prefixes .
 outer products differ   weight   entry,.
 algorithm must   different states  seeing .
prefixes.
proof. since   allowed  one pass  .
column  row vectors   input matrices,  will.
consider  outer products   stream  updates.
  output entries.   prefix   stream.
consider  count vector    entry records.
 weight   prefix.     algorithm .
computes  heaviest entry   data stream. consider.
two distinct weight vectors   , corresponding .
different stream prefixes.  argue   must  .
two different states  seeing  prefixes. suppose.
  latter claim   true,     .  .
algorithm     state. since    differ, .
must   least one entry ., .  distinct weights.
  two weight vectors.   implies  .
 extend  streams   sequence  makes .
entry ., .  heaviest one  one   weight vectors,.
say . , ., . becomes  heaviest entry, .
   happen  . still,  algorithm .
    state   cases, returning  .
result  weight.  contradicts  assumption .
 always returns  correct answer,   assumption.
    resulted    state must  false.
intuitively,   generally applicable ways .
storing  weights   entries   either store .
weight explicitly,  store  column  row vectors.
seen  far.
. frequent pair mining  transactional data.
streams.  case study.
 original motivation   parallelize  mining.
 frequent pairs   high speed transaction stream.
 already explained,  problem   seen  .
instance  sparse matrix multiplication aat  .
column row method.
 use  following notation  transactional data.
streams.     set  items.  transaction  . .
  set  items.  call  subset  . ., . .  .
pair.   stream  transactions ,  support .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 pair    number  transactions containing .
sup. . . .  . .,  . .   consider .
transaction    ., .-valued sparse n-dimensional.
vector    set  pairs occurring   given.
transaction   nonzero entries   diagonal .
 outer product     transpose.
. frequent pattern mining. considerable work.
  done  parallel  distributed implementations  frequent itemset methods.  refer  zaki.
. survey .   overview   main techniques    investigated. subsequent work.
 focused  either multi-core computing, aiming .
minimize  overhead  access  shared data structures ., .,   recently gpu computing, focusing  representations  data  allow efficient gpu.
implementations .see . ., .  recent results.
  best knowledge,  known methods  parallelising frequent itemset mining use either  shared.
data structure,   .vertical., column-by-column layout   data .  item,  sorted list   transactions   occurs.   former case  shared.
data structure will become  bottleneck  scaling .
many cores.   latter case one   longer .
 space-efficient streaming algorithm,  computing  vertical representation requires storing  transactions.   also well-known   sparse matrices  representation,  supports fast computation  inner products, leads  higher time complexity.
 methods based  outer products. see .  .
overview  theoretical results  .serial. sparse matrix.
products.
. related work  stream mining. though .
view  new load balancing technique   main.
contribution   work,  application  stream.
mining  interesting    right.   following.
 briefly review related work   area.
manku  motwani . first recognized  necessity  efficient algorithms targeted  frequent itemsets  transaction streams  presented  heuristic approach generalizing  stickysampling algorithm.
 straightforward approach  mining  frequent pairs.
  reduce  problem    mining frequent items.
 generating  item pairs   given transaction.  .
. .  campagna  pagh . present randomized.
algorithms  transaction stream mining.  theoretical bounds   quality   estimates however.
heavily depend   assumption  transactions .
either generated independently  random   process  arrive   random order.   already clear .
 experiments  .   optimistic assumptions.
  hold  many data sets.   schemes ., .
dataset .  pairs . .  distinct pairs.
mushroom . . . . . .
pumsb . . . . . .
pumsb star . . . . . .
kosarak . . . . . .
retail . . . . . .
accidents . . . . . .
webdocs . . . . . . .
nytimes . . . . . . .
pubmed . . . . . . .
wikipedia . . . . . . .
table . information  data sets   experiments. nytimes.
 pubmed  taken   uci machine learning repository .bag  words data set.  wikipedia dataset  .
crafted according    described  ., page .  .
data sets    frequent itemset mining implementations.
.fimi. repository.   last three data sets  number .
distinct pairs  estimated using  hashing technique  .
  context  sparse matrix multiplication  number  pairs.
  total number  nonzero entries   outer products .
 number  distinct pairs   number nonzero entries  .
output matrix.
  easy  find  ordering  essentially  transaction stream  breaks  randomness assumption,.
 makes  perform much worse   theoretical.
bounds.  therefore believe    conservative.
model  needed  derive  rigorous theoretical analysis,.
 exploiting observed properties  real data sets.
. experimental evaluation.  worked .
 cache-optimized java implementation working .
 primitive data types  used  built-in random.
number generator  store hash values   table.
unless otherwise reported  ran experiments .
 mac pro desktop equipped  quad-core intel.
.ghz  .  main memory.   architecture.
  . cores   total  .  cache available.
 . cores share .   cache.
datasets.  evaluated  performance   algorithm   following datasets. mushroom, pumsb,.
pumsb star  kosarak, taken   frequent.
itemset mining implementations .fimi. repository,.
wikipedia . crafted according    described  .,.
page .,  nytimes  pubmed taken   uci.
machine learning repository.
table . summarizes  data sets used  experiments.   cases,  use  order    transactions  given   stream order.
accuracy  results.  first set  experiments.
shows results   precision   counts obtained.
 crop using  space-saving data structure  size.
.,.,  record  two pairs.  accuracy depends.
  amount  space used   number  pairs .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 interested  reporting. assume  pairs  sorted.
 decreasing order according   frequency,  say.
 ith pair  rank .  made one experiment.
fixing  space usage,  looking  results  pairs.
 decreasing rank .computed exactly.,  one .
varies  space usage  considers  top-. pairs.
 practice,  may  hard  foresee  much space.
will  needed   particular stream,  probably one.
will tend  use  much space  feasible  respect.
 running time .ensure in-cache hash table.,  .
amount  memory   made available   system.
 consequence   will  even  precise results.
 results   experiments   nytimes data set.
  seen  figure .
varying space usage  now investigate .
happens   quality  results   space usage.
 crop  pushed ,  beyond,  limits.  ,.
 chose  work  . representative data sets, namely.
mushroom, retail  accidents,  decreasing space.
usage, plotting  ratio   upper  lower.
bounds   top-. pairs returned   algorithm.
  shown  figure .    see  .
transition   poor   good quality .
fairly fast.
larger space-saving data structures.  estimated  number  pairs  ratio  least .
 lower  upper bound  varying  number.
 pairs   bucket  keeping  total number.
 pairs   sketch constant.  counted  number  pairs   .-th bad estimate, . .
. pairs   lower bound less  .   upper bound. since  algorithm  randomized  chose.
.  cut-off  order    sensitive  outliers .
 estimates.  fixed  total number  pairs .
 kosarak dataset  .    accidents.
dataset  .   varied  pairs per bucket.
 .  .  effect  much better estimates .
  space usage, see figure .
count-sketch estimates  result   unbiased count-sketch estimator   kosarak.
dataset  . buckets  . pairs per bucket  presented  figure .  ran  algorithm . times.
   pair reported  least . times  return.
 median   estimates.  plot shows  ratio   estimates   exact count   .
pairs  highest support computed  apriori. .
reported pairs  ratio .  general  observe .
 estimates given  space-saving  tighter.
scalability.  order  assess  scalability  .
approach,  performed  following experiment. .
ran  algorithm   space-saving data structure.
  kosarak dataset   sketch  size .  .
cores.   run  computed  recall   top.
. . . . .
actual rank.
.
.
.
.
.
.
.
 .
.
 .
.
 .
.
.
, .
.
lat.
ive.
 .
 .
.
 .
lue.
. . . .
.
.
.
.
.
.
.
.
.
.
.
number  buckets.
estimate quality  top . pairs.
 .
 .
retail.
accidents.
mushroom.
figure . .  plot   left side shows upper  lower.
bounds  nytimes computed  crop using . buckets. values.
 normalized  dividing  true support. upper bounds.
shadow lower bounds, exact bounds  visible    red.
dot   blue dot .    seen, upper bounds .
generally tighter  lower bounds. .   right-hand side.
 plot  average ratio  lower  upper bound  top-.
pairs,  three representative data sets,  function  number .
buckets.    seen,    quick transition  poor .
excellent precision.
. pairs   dataset, see table .  idea  .
 core  handle  sketch  size . using  .
local cache.  running time   time needed  .
processes  complete. given   core needs .
. sec  read  input transactions, sort  according.
  hash values   items   decide .
pairs   responsible ,   good scalability .
observed.  results indicate  using parallelism.
 approach    efficient  achieves .
accurate results.
load balance.   run experiments evaluating  distribution  pairs among  buckets. .
running  experiments,  kept track   number  pairs processed   core.  results  .
experiments  reported  table .  numbers .
 table confirm   pairs spread evenly amongst.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . .
.
.
.
.
.
.
.
.
.
.
.
pairs.
.
.
.
 .
 .
.
.
.
.
 .
ith.
.
 .
.
 .
 .
.
.
 .
.
.
 .
 .
kosarak.
accidents.
. . . . . . .
.
.
.
.
.
.
rank  pairs.
.
.
.
 .
 .
.
.
.
 .
.
 .
.
.
 .
.
.
figure .   left side   number  estimates  ratio.
  least .  . bad estimates   seen   given.
number  pairs   space-saving summary.   see  sharp.
improvement   quality   estimates   observed .
increasing  number  pairs   summary.   righthand side  plot represents  ratio  estimates  true count.
  top . pairs  kosarak.  top . pairs  reported.
  algorithm      pairs  estimates  within.
 factor . however,  estimates  worse   given .
space-saving    total space usage.
 buckets meaning  parallelism greatly improves.
 running time   algorithm, since  will .
 core    sustain  much larger burden .
 others.   negative situation  bring .
performances   algorithm close   sequential one.
progress  processing.  ran four processes,.
   operating system allocate one   core.
 tracked  progress   process  time. .
result   kosarak dataset  shown  figure .
  nytimes dataset  figure .    seen,.
 cores make almost identical progress  running.
 full speed.   data streaming setting  means.
   expect  manage streams  require .
cores  run  close  maximum speed,  needing.
cores . . . .
time.sec. . . . .
recall . . . .
table . recall  kosarak.
dataset cores average maximum.
retail.
. . .
. . .
. . .
kosarak.
. . .
. . .
. . . . . . .
webdocs.
. . . . . . .
. . . . . . .
. . . . . . .
nytimes.
. . . . . . .
. . . . . . .
. . . . . . .
wikipedia . . . . . . .
table .  table shows  average  maximum number.
 pair occurrences handled   core.    seen, .
maximum  quite close   average.
 cache   small number  transactions.
somewhat surprisingly  inconsistent  .
 results,  observed however   experiments   multicore cpu  various architectures.
  always suggest  good scalability  increased number  cores.  example,  webdocs.
dataset consists  long transactions , thus  time.
 reading  input   dominate. however,.
 observed  even   processing time becomes.
better   cores  advantages   .
cores become less  less pronounced.  particular,.
 running time  processing  data set .
eight cores instead  four cores decreases   factor .
 .   ratio   running time .
one core  two cores   .  reason  .
 core   small amount  dedicated . cache.
   sufficient  keep  whole interval  .
hash table assigned     leads  memory contention among processes.  means  potential .
 method   fully exploited  distributing .
work  several processors    work  rather.
small sketches   data stream.
 precisely, experiments   carried .
 order  verify   algorithm scales,  terms .
time,  parallel computations  used.  ran .
algorithm  various datasets using different number.
 cores  order  highlight  parallel nature .
 algorithm. table . reports    results .
obtained.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . .
time . .
.
.
.
.
.
.
.
.
.
.
cti.
.
 .
.
.
.
. . . . . .
transaction number . .
.
.
.
.
tim.
 .
. .
.
figure .   left side  see  progress   current.
transaction number   core running crop   nytimes.
data set,   period   . seconds    right-hand.
side  total time recorded  every . transaction .
running crop  . cores   kosarak data set.
 one  see  exact running times   evaluation   scalability   algorithm appear somewhat cumbersome since  improvement  running.
times   suggest  good scalability.   .
due   flaw   implementation   consequence.
  specific xeon . architecture.  core .
 small amount  dedicated cache, namely . . .
order  obtain correct estimates  need  large number  buckets    fit  cache   leads.
 memory contention.  considerably smaller size.
  sketch  achieve almost perfect scalability. .
ran another set  experiments   mac pro desktop.
equipped  quad-core intel .ghz.   architecture   . cores   total  .  cache.
available  . cores share .   cache.  running.
time  . parallel processes   two times better.
  running time  . parallel processes  .
improvement  . processes    good, clearly indicating cache contention among . cores   optimal.
use  . processes.
dataset .  cores   . cores  . core.
retail.
. .
. . .
. .
kosarak.
. .
. . .
. .
webdocs.
. .
. . .
. .
nytimes.
. .
. . .
. .
wikipedia.
. .
. . .
. .
table . experiments ran   intel xeon .
. ghz equipped  .   ram.   .
gnu.linux, kernel version .  number .
processes used  .   four datasets. times .
given  milliseconds .  number  buckets.
  largest datasets    order .  .
observe    case, millions  pairs per second.
 manipulated   algorithm.
  large dataset   high number  pairs .
 nytimes  simple java implementation nevertheless.
processed almost . million pairs per second  .
.-core mac pro,  total running time  .
. seconds.  sketch contained . buckets.
  enough  find  exact counts   top.
 hundred pairs.  throughput   competing.
hash table solution   upper bounded  .
number  updates  random memory locations possible.
.disregarding time  hash function computation, .
 overheads.   mac pro  number  .
updates per second  estimated  around . millon.
per second,  updating  .  table using . cores.
 means     least  factor  . faster.
  implementation based   large, shared data.
structure.
</doc>
<doc title='12_ALENEX_26.txt'>
downloaded  knowledgecenter.siam.org.
robust gossip-based aggregation.  practical point  view.
gerhard niederbrucker. wilfried . gansterer.
abstract.
  last years, several gossip-based aggregation.
algorithms   developed  focus  providing resilience  failure-prone distributed systems.
 main objective   algorithms   efficient.
in-network computation  aggregates even   case.
 system failures occur  runtime.   paper,  evaluate performance  limitations  practical computations   gossip-based aggregation algorithms    promising theoretical fault tolerance properties.
theoretical analyses   algorithms usually address   principal ability  handling  overcoming  certain kind  system failure.    time,.
   formal results   concrete impact .
failure handling   performance   algorithms,.
. .,  terms  convergence speed.  leaves  wide.
gap  theory  practice,   illustrate .
 paper.  order  bridge  gap,  first categorize common system failures  interest. , .
experimentally investigate  well  common failure types  handled  practice   considered algorithms     extent  state-of-the-art.
methods provide  reasonable degree  fault tolerance.
 practice.  experimental studies reveal . .
certain failure handling approaches  work  theory exhibit unacceptable performance  practice .
.    cases  failure handling mechanisms.
used introduce new problems, . ., numerical inaccuracy.
 investigations illustrate    failure.
types .  permanent node failures.  algorithmic advances  required  achieve resilience.
  reasonably small overhead  acceptable performance.
. introduction.
gossiping  epidemic protocols   used  computing aggregates  data across distributed systems.
gossip-based algorithms provide high flexibility  respect   underlying computing infrastructure, scale.
.university  vienna, research group theory  applications  algorithms. email. gerhard.niederbrucker.univie.,.
wilfried.gansterer.univie.
well due   focus  nearest neighbor communication  promise  high potential  providing fault tolerance   algorithmic level. recent approaches aim.
 utilizing  potential  integrating fault tolerance.
mechanisms  different kinds  nature  less resilient base methods.  integration  fault tolerance.
mechanisms causes usually  minor overhead  .
resulting algorithms  theoretically able  handle .
wide range  system failures .see section .   comprehensive discussion   algorithms  consider .
 paper.   theoretical investigations usually.
  principal ability  overcoming system failures.
 studied,  concrete impact   failure handling .
 overall computation, . .,  terms  convergence.
speed  performance,  usually  discussed. moreover, practical aspects like  influence  floating-point.
arithmetic   theoretical results   discussed.
  literature,  experimental evaluations  carried   varying environments   respect .
varying metrics. therefore,  available experimental.
results   literature   compared directly.
thus,  aim   thorough comparison   analysis   practical applicability  recently proposed.
fault tolerant gossiping algorithms  identify inherent.
problems  open questions  future research.
 particular,  investigate  well  failure.
handling mechanisms  current gossip-based aggregation algorithms work  practice.   course  ,.
 aim   comparison   strengths  weaknesses  existing algorithms  well    analysis   theoretically predicted behavior  affected  practice.   paper,  consider  recently proposed fault tolerant aggregation algorithms.
flow-updating ., limosense ., push-flow . .
 novel push-cancel-flow . . section . moreover,   baseline  failure-free scenarios,  include.
 push-sum algorithm .   closely related .
 discussed algorithms,   much  limited .
terms  fault tolerance. furthermore,  precisely define various classes  failures  interest  simulate.
   experimental evaluations.  order  perform  thorough comparison despite   randomness.
present  gossip-based algorithms,  also develop .
sound evaluation methodology  produces unbiased.
results.
. copyright . siam.
unauthorized reproduction   article  prohibited.
contributions.  present  in-depth experimental analysis  state-of-the-art fault tolerant gossipbased aggregation algorithms  study  behavior.
 realistic scenarios     reach   corresponding theoretical results available   literature.
 observe   characteristics  real computations.
 floating-point arithmetic  partly.depending.
  concrete algorithm. major impact  fault tolerance properties. moreover,  observe  certain.
fault tolerance mechanisms lead  unexpectedly high.
overhead    even identify commonly shared.
problems   considered algorithms.   observations  bridge  gap   .partially. existing theoretical analysis   algorithms   behavior  practice. thus,  observations show .
 theoretical ability  overcoming system failures .
 insufficient  practice.  carrying   experiments  use  self-made simulator  allows  wide.
range  experiments    large scale.
synopsis.  section .  review  considered.
aggregation algorithms  discuss  theoretical.
properties  expected .fault tolerance. behavior. .
section .  summarize  evaluation methodology.
 precisely define  notions required  empirically.
verify  expected .fault tolerance. properties  .
considered algorithms. section .  devoted  .
experimental work  reveals several weaknesses  .
considered algorithms    identified  .
theoretical analyses existing  far. section . concludes.
 paper.
. robust gossip-based aggregation.
  section  clarify  kind  aggregation.
problems   going  consider   types.
 fault tolerance   destinguished. moreover, .
briefly discuss  algorithms   going  evaluate.
later .
. environments  targets   following,.
 always assume  connected,  otherwise arbitrary.
network   nodes  allows  point-to-point.
communication  connected nodes. formally, .
network  modeled   undirected graph  . ., .
  identify  vertices   graph .nodes  .
network.  natural numbers, . .,  . ., . . . , . .
 .  . .  neighborhood  node   defined .
 . . . ., . . .   communication   node .
limited   neighborhood. moreover, without loss .
generality,  focus  investigations   problem .
scalar distributed aggregation. furthermore,   .
discussed algorithms  easily adapted  perform .
complex non-scalar aggregates   sums.averages .
vectors  matrices.
 means,  initially every node  holds .
initial value  .    goal   in-network.
computation   global aggregate, . .,  average.
. ., locally   node. concretely, every node.
 computes  sequence  estimates ., . . .
 .theoretically. converges   target aggregate.
 . ., limt. . . .  communicating  .
neighborhood . reasons   make clear.
  next section,  consider   paper solely.
algorithms  aim  robustly computing weighted.
averages. thus,    discussed algorithms .
able  distributedly .locally   node. compute .
global sum  average   local input data. .
means,  every node  hosts  value .,  weight.
.   objective    . . .
converge towards  .
.
. .
.
. .
. fault tolerance aspects  decentralized.
computation  aggregate information  distributed.
systems   fundamental operation  serves .
building block   complex operations.  .
principles, gossip-based algorithms   flexible .
  high fault tolerance potential.  crucial requirement   gossip-based algorithms  converge.
  correct result    .global. information .
conserved   whole course   computation.
clearly,  hardness   condition  determined .
 concrete kind  operation   performed. . .,.
  want  compute  minimum   maximum.
  data hosted   nodes,  algorithm  .
 ensure   times  . . .using  notation  .
previous section.
. min.
.
. . min.
.
., max.
.
. . max.
.
.
 conditions  relatively easy  guarantee  .
hardly effected   kinds  failures since .
 computation  high degree  natural redundancy.
 accomplished, . .,    nodes hold .
correct minimum.maximum. moreover, one .
note  close relationship   computation .
 discrete aggregates   problem  spreading.
rumors .see . ., .
 stated   previous section,  focus  .
paper  computation  weighted averages.  .
problem,  conservation property  algorithms .
 ensure translates    . . .
.
.
. .
. .
.
.
. .
. .
.
 contrast   conservation properties . .
conservation property .  basically affected  .
kind  failure   system. thus,  property.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 highly non-trivial  guarantee  explicit fault.
tolerance mechanisms  needed.  exactly .
reason  consider  problem   paper .
investigate    extent fault tolerance  .
algorithmic level  also  provided   much.
harder problem.
  search  efficient distributed aggregation algorithms  received  lot  attention . .,.,.
non-trivial fault tolerance aspects   addressed.
recently ., ., ., . fault tolerance   aggregation level  inherently challenging, since  requires.
 development  strong fault tolerance techniques.
solely working   algorithmic level. moreover,.
well-established fault-tolerance techniques like abft.
. ., middleware-based approaches like .diskless.
checkpointing .see, . ., .  purely hardware-based.
approaches like triple modular redundancy . . .
  efficiently utilized due   simplicity  atomicity   single aggregation.
degrees  fault tolerance fault tolerance  .
clearly defined  different fields  applications require different notions  fault tolerance.  distinguish.
  following   fault tolerance abilities .
 discussed methods  consider  following exemplary notions  fault tolerance ordered  weaker .
stronger notions.  algorithm  tolerates  failure .
. . .
. . . .  computation   crash   uncontrolled way  information   occurrence.
  failure  available . termination.
. . . .  computation terminates successfully,  .
computed result   necessarily correct.
. . . .  correct result  computed  , possibly failure-dependent,  priori unknown overhead.
concretely, handling  failure may   situations  less efficient  starting  computation.
 scratch.
. . . .  correct result  computed   bounded,.
reasonably small, overhead.  reasonably small.
 mean   process  recovering  .
failure takes .much. less effort  restarting .
computation.
. . . .  correct result  computed without overhead.
 nature  gossip-based algorithms guarantees fault.
tolerance  least   sense  .   requirements  .    reach   averaging.
problems considered . contrast  discrete aggregates.
  superior notion  fault tolerance  reasonable.  interesting question. also  existing.
theory leaves open.  well .certain kinds . failures  tolerated  practice, . .,     pay .
arbitrarily high price   correct result . ., .
   efficiently compute correct results despite failures occurring   computation . . consequently,   henceforth state   algorithm.
handles  certain kind  failure,  mean   handles  failure   sense  .
 review   following   promising fault.
tolerant aggregation approaches  aim  tackle .
problem  fault tolerant distributed aggregation .
evaluate  strength  .practical. limitations. .
subsequent discussion   algorithms  obviously.
 cover  fundamental properties  different.
approaches   algorithms.   detailed exposition.
 refer   literature .
. algorithms especially   sake  performance comparisons  include  non fault tolerant.
push-sum algorithm . . .see figure .   investigations.    algorithm initially every node.
holds two values.  actual input data   scalar.
weight  determines  type  aggregate .
shall  computed .sum, average, etc.   iteration   algorithm every node picks  random neighbor  sends half   data   selected neighbor.
 received values  simply added   respective.
local values.  central property  ensuring  fully.
accurate computation   target aggregate proved .
  so-called global mass conservation .see, . ., .,.
 states   initial data    preserved.
  whole course   computation . equation . obviously,  kind  system failure hurts.
 property  thus,  aggregation algorithm .
  fault tolerant    guarantee mass conservation  purely local means.  crucial property responsible  many good properties    algorithm.
  monotone . exponentially fast. convergence.
 respect   maximal local error emax . section . thus,  network-wide worst local approximate   improve  time.   baseline  .
performance  distributed aggregation algorithms .
consider  complexity  .optimal. deterministic parallel reduction algorithms . .  well connected.
networks, . ., networks   short diameter,  .
algorithm  shown  scale logarithmically  .
number  nodes .,. exactly like optimal deterministic.
approaches.
limosense .lms.  basic idea behind limosense .   incorporate fault tolerance mechanisms.
   algorithm   changing  algorithms.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. local variables.
 . ., . . .
. initial values.
 . ., .
.   received pairs  .
.  .  . .
. end .
.  . choose  neighbor.
uniformly  random.
.  . .
. send   .
. local variables.
 . ., ., , . .
.
, , .
.
,. . .
. initial values.
 . ., ., , . ., .
.   received pairs , .
. , . .,.
. end .
.  . choose  neighbor.
uniformly  random.
. , . , . .
.
. ,.
. send ,  .
figure . left. push-sum . without  .explicit. fault tolerance mechanisms. right. push-flow . .
utilizes  graph theoretical flow concept  become fault tolerant. push-flow reduces  push-sum  .
absence  failures.
principal shape  behavior  failure-free environments.   done  keeping .locally   node. .
 communication link   neighboring node histories .sums.  sent  received values.  transmitting.
 every iteration  complete history .instead  .
current message .,  receiving node , . ., easily.
recover  lost messages.  keep  ever growing histories reasonably small,  push-pull mechanism .
supposed   applied periodically.  failure-free cases.
limosense reduces    algorithm  hence, fast.
convergence  guaranteed.
flow-updating .  contrast  limosense.
 extends   algorithm  fault tolerance mechanisms, flow-updating .   entirely independent.
approach.   based   following two ideas. .
 node computes  local estimate   aggregate .
average    recent estimates  got  .
neighbors. .  graph theoretical flow concept .
used  communicating local information fault tolerantly, . ., instead  keeping histories   limosense.
 nodes  flow-updating keep   communication link  flow variable ,  describes  amount.
 data   .flowing.  node   .  contrast.
 histories, flow variables stay small  definition .
 push-pull mechanisms  required. moreover, .
ensuring flow conservation . ., , . .,.  global.
property  mass conservation translates   entirely.
local property    origin   extraordinary.
high fault tolerance potential provided   flow concept.
push-flow .  principal  push-flow algorithm . aims  combine  positive aspects .
flow-updating  limosense, . ., utilizing  flow.
concept  providing  algorithm     absence  failures equivalent    algorithm. .
 flow-updating  flow concept  used  one ingredient   entirely new algorithm,   recently.
shown,   flow concept  even  used  .
 general way  deriving fault tolerant variants .
gossip-based algorithms without changing  shape.
 properties  failure-free environments. thus, .
 algorithm   viewed   special outcome .
 methodology applied    algorithm .see figure . moreover,  kind  transformation  . .,.
 done  general classes  gossip-based aggregation.
algorithms  described  .  average consensus algorithms . consequently,    derived algorithms.
   fault tolerance properties  therefore,.
  consider   algorithm   evaluations.
push-cancel-flow .pcf.  push-cancelflow algorithm .   novel advancement   .
algorithm  leads  significant qualitative improvements  terms  numerical accuracy  computational efficiency . system failures occur.  theoretical advance   pcf algorithm    algorithm ,   flow variables   pcf algorithm.
converge   target aggregate whereas  converge.
 arbitrary values   case    algorithm. .
seemingly simple theoretical difference  responsible .
   .practical. advantages   pcf algorithm.
   algorithm   competing approaches.
. section .
 general   two ways   algorithms.
overcome system failures. first, certain types  failures, . ., message loss, get corrected solely  executing  algorithm without  explicit failure detection.
 correction.  difficult .permanent. failures require  contrast   knowledge   kind .
occurrence   failure    failure handling.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 possible.   done  algorithmically excluding.
 failed component.   computation. concretely,  setting  respective history  flow variables  zero. even though limosense,   algorithm   pcf algorithm produce results  .
.theoretically. equivalent    algorithm  failurefree environments,    preserve  properties.
   algorithm  failures occur.  notably,.
 monotone convergence  respect   maximal.
local error emax . section . gets lost   fault.
tolerant algorithms.
  four sketched fault tolerant aggregation.
algorithms provide superior fault tolerance properties.
compared   approaches  distributed aggregation .see, . ., ., .,    clear    extent  theoretically expected fault tolerance  .
observed  practice.   due   fact  .
theoretical work  failure recovery usually  deals.
  principal ability  tolerating system failures.
concretely,  means    . many kinds .
failures. assumed   algorithm   executed.
without  failures  long   needs  overcome.
 previously occurred system failure.  unsatisfying circumstance  one   motivating aspects  .
present in-depth experimental study.
. experimental methodology.
  section  discuss  formal background  .
experimental work  define  concise methodology.
 objectively evaluate  algorithms discussed  section .
. system failures  interest   preliminary.
step,  classify  precisely define  system failures.
   interest   context  robust distributed.
aggregation algorithms. moreover,  table .  depict.
 fault tolerance properties   expected .
 algorithm based   existing theoretical results.
 stated  section .,  expect  efficient failure.
handling   algorithms  therefore .
.
 table .
means   algorithm handles  respective failure.
  sense  . later,  section .,  update.
 comparison   practical point  view .
table . based   experimental work  observe.
 substantial gap  theory  practice, . ., .
observe often  fault tolerance behavior   sense.
 .
. categorization  failure types  categorize  system failures   interested  .
respect  three properties.  duration   failure,  available information   failure .
 affected component. moreover,  will use  systematic naming convention  providing  concise notation. concretely,  will abbreviate  considered failures  .duration.information.affected.
component.  duration  information  .
failure  specified   single letter   failed component  two letters, respectively.   following .
discuss  different characteristic properties   considered system failures.
duration.  terms  duration,  distinguish.
transient .  permanent . failures.   case.
  transient failure,  certain component  .
system fails   finite amount  time.  .
time span,  system  operating    .
effects   due   failure  corrected, . .,.
  communication link transiently fails,  successful.
communication   possible   finite amount .
time,    time span,  link  operating.
 .  speak   permanent failure, .
 effect   system failure gets never corrected. .
 obvious,  permanent failures  usually .
difficult  handle  transient failures.
information  failure.  distinguish three.
kinds  system failures. unknown ., known . .
neat . failures.   case   unknown failure,.
 information   existence  impact  .
system failure  available   algorithmic level. .
 case   known failure,  neighbors   node .
assumed   informed   existence  type .
failure immediately   failure occurred.  speak.
  neat failure,   component knows  .
upcoming problem   enough time  successfully.
complete  failure handling routine, . .,  sensor .
 sensor network   running   battery .
.neatly. sign    running computation  sending.
  data  another node. neat failures  easier .
handle  known failures,  unknown failures .
  difficult  handle.
affected component.   work,  consider.
  following four components may  affected  .
failure   aggregate computation.  link ., .
entire node ., algorithm data .  initial data.
.   link  mean  kind  communication.
link   speak   link failure whenever .
message   node   communicated .correctly.
  designated receiving node.  node failure .
denote  kind  failures  result   complete.
crash   node, . .,  operating system crash caused.
  defective hardware component.  say  .
algorithm data  affected   failure, whenever one.
  local variables   algorithm get corrupted.
  course   aggregate computation, . .,.
  bit flip. failures   initial data  defined.
accordingly  denote  kind  corruption  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
failure  lms   pcf.
tk-li.
. . . . .
pk-li.
. . . . .
tu-li .
. . . .
pu-li . . . . .
pn-no.
. . . . .
tk-no .
. . . .
pk-no .
. . . .
tu-no .
. . . .
pu-no . . . . .
pu-ad . .
. . .
pu-id . . . . .
table . expected theoretical fault tolerance properties.
 push-sum ., limosense ., flow-updating .,.
push-flow .  push-cancel-flow . . table .
  empirically observed fault tolerance. failures .
abbreviated according   definitions  section .
. initial data   failed node  excluded  .
aggregate.
data   initially given   nodes.
. failure description  principal  characteristic attributes  defined  section .  .
combined arbitrarily  define  set  system failures.
 interest.     combinations  meaningful interpretations    practical relevance .
hence,  will  consider  certain subset   possible combinations . table .   simulations.
 will  principal . certain points  time. inject.
single failures   specific type  study  impact,.
. .,      define  statistical failure model.
  exception   failure tu-li. ,  use.
. .  . .   message loss rate   failures.
  message transmissions  modeled  independent bernoulli processes. concretely,   message.
  sent   simulator,  flip  coin  decide.
. probability . whether  message  successfully communicated  . probability .  tu-li.
occurs   message gets lost.
table . shows  selection  system failures .
consider   relevant   context  gossip-based.
aggregation. additionally,  give detailed failure.
description  practical examples   described.
failures. moreover,  depict  table .  .theoretical.
fault tolerance   expect based   existing.
literature.  section .  evaluate   .
extent  expectations  fulfilled  practice .
observe substantial gaps  theory  practice.
. table .
. objectives  evaluation procedure .
discussed  section .,  consider   paper .
problem  scalar aggregation. moreover,  saw .
gossip-based aggregation algorithms  iterative processes  provide   point  time  estimate   target aggregate.  quantify  accuracy achieved   certain point   time,  use .
.relative. maximal local error emax   define .
emax. . max.
.
. . . .   denotes .
target aggregate  . denotes  local approximate  node   time .  means,  emax. . .
holds,   nodes   least  .-approximate .
 target aggregate. hence, whenever  specify  target precision . ,  say   algorithm reached .
target precision . time .  emax. . . .  gain.
 insights    network-wide approximates.
  certain point  time look like,  also consider .
minimal local error emin. . min.
.
. . .
 mean local error . .
.
. . . . . .
  corresponding standard deviation . .  case.
 set   simulations  target precision .  .
algorithm   reach , . ., emax. . .  .
times ,  abort  computation   predefined.
maximal number  iterations .usually .,  report  accuracy measures   last completed iteration  achieved accuracy.   usage  emax.
 measure   achieved accuracy guarantees .
 nodes reached  prescribed target accuracy, existing experimental work .see, . ., ., . often provides.
measures like  mean square error .mse. .  .
root mean square error .rmse. .   accuracy.
guarantees   single node   given.  differences   accuracy evaluation  fundamental .
  big influence   computed results  .
interpretation.
 central question   experimental evaluation .
gossip-based algorithms    account   various sources  randomness   experimental results.
concretely,    take  account three sources.
 randomness  strongly influence  behavior .
 algorithms   evaluations. .  communication schedules, .  input data  .iii.  coin.
flips   used  deciding whether    failure modeled   bernoulli process, . ., tu-li, occurs.
  clear  varying    parameters will lead.
 different results, . .,  terms  iterations needed.
 convergence. thus,  account   variations,.
 systematically vary    parameters  report statistical measures computed   number .
runs instead  presenting  result   single run. .
sufficiently large number   repetitions guarantees.
meaningful unbiased results   will also elaborate.
 details    number  kind  repetitions.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
failure description practical example.
.-li  communication link fails, . .,  successful transmission.
along  link   possible.
tk-li  nodes connected   failed link  informed   begin.
   end   finite failure period.
transiently released wire.
pk-li  nodes connected   failed link  informed  .
permanent failure   link   link fails.
permanently released wire.
tu-li sent messages get silently dropped   finite time period. .
sender believes   successful transmission   message .
neither sender  receiver  informed   failure  .
communication.
message loss  communication.
pu-li  entire communication   link gets silently dropped.
neither   nodes connected via  link  information.
  failure.
permanently broken wire.
.-no  node entirely fails, . .,   node  communicate .
 failed node . access  local data.
pn-no   permanently fails   certain point  time , .
node  launch  complete  failure handling routine.
sensor running   battery.
tk-no  neighboring nodes  informed   beginning  .
 end   finite failure period.
transiently shut  node.
pk-no   node permanently failed,  neighboring nodes .
informed   failure.
permanently shut  node.
tu-no  messages intended   failed node get dropped  .
finite period  time neither   neighboring nodes .
information   failure.
unexpected system reboot.
pu-no  messages intended   failed node get dropped  .
certain point  time . neither   neighboring nodes .
information   failure.
crash  node.
pu-ad local data .variables. maintained   algorithm gets.
silently corrupted.
bit-flip.  local variables .
 algorithm.
pu-id  initial data stored   algorithm gets silently corrupted. bit-flip.   .variables.
storing. initial data.
table . overview  system failures considered  failure description  practical examples.
influences  achieved results   experimental work.
 section .
one   central aims   provide  comprehensive  reproducible study   currently known.
theoretical properties  fault tolerant gossip-based aggregation algorithms translate  practice. targeting.
 aim  reproducibility  designed  simulator .
  way   kind  needed input data  read.
 permanently stored files.  means,  perform.
 simulation run   simulator,    provide.
.  input data   nodes     aggregated, .  communication schedule  every node.
. .,  neighbor   called  node   round.
.  .iii.  coin flips   necessary  decide.
whether certain failures occur  .    data.
 provided via separate input files   compiled .
extensive test data set   experimental evaluations.
  also available online . . section . furthermore, whenever  compare two   algorithms.
  experimental work,  algorithms use exactly.
  parameters, . .,  .random. communication schedules, .random. input data  coin flips .
exactly    hence,  possible difference .
 result   due   properties   respective.
algorithms. providing  test data set  compiled .
  central aspect since experimental results   existing literature  hard  reproduce due   lack.
 concrete environmental data .communication schedules, input data, etc. moreover,  plan  make .
whole simulation environment publicly available .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
completing  investigations.
. simulation environment  central goal .
 present experimental work   study   .
extent  theoretically predicted properties   considered algorithms hold  practice.  especially.
means,     run  evaluations   environment according   formal results available .
 literature. concretely,     considered algorithms,  means     ensure  execution   algorithms .  nodes.  synchronous.
rounds, . .,   round every node executes one iteration   present algorithm.  guarantees  .
 gain insights   experimental work  respect  existing theoretical results.  carry  .
simulations   self-made simulator  allows .
 vary  parameters  interest   considered algorithms. despite  simulator runs sequentially, .
results  computed    nodes  run  algorithms fully parallel  synchronous rounds. therefore,.
 obtain exactly   results     run.
 experiments physically  parallel.   considered algorithms actually behave  asynchronous environments     scope  existing formal.
analyses  subject  ongoing research . section .
since  aim   clear comparison   considered algorithms       single node degrees   nodes play  important role,  consider .
 present study  topologies   regular connection graph. due   regularity, . ., every node .
  number  neighbors,  avoid  positive .
negative outliers due   use   certain topology.
   hand,  use different kinds  regular.
topologies  also take  influence   topology .
 performance  consideration. concretely, .
simulator  simulate  kind  k-ary d-cubes . .
network connection graph. especially,  will consider.
. grids  tori  well  hypercubes due  .
neat formal properties, . .,  considered algorithms.
benefit   small network diameter . terms  fast.
convergence.    small node degree . terms .
fault tolerance.    log.   hypercube.
thus, hypercubes   prime example   topology.
 gossip-based aggregation works extremely well.
    observe  practice . section . .
theoretically predicted scaling  .log  . log . .
  network   nodes   target precision . terms.
 emax.  .  scaling behavior corresponds  .
optimal scaling  deterministic aggregation algorithms.
. .
. . . . . . .
.
.
.
number  nodes.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
 .lms.pcf optimal.
figure . number  iterations required  converge  flow-updating   push-sum-based.
approaches. simulation environment. hypercube.
topology,  message loss, convergence criterion.
emax . . . . iterations., communication schedules com-hc-. . . . ., input data.
inp-us-. . . . . see also table .
. evaluation  algorithms.
  following,  briefly discuss  evaluation data.
set .  compiled   experimental studies .
sketch  experimental results.
. evaluation data set  discussed  section .,.
 simulator reads  kind  environmental data .
permanently stored files.   sake  reproducibility,  compiled  extensive evaluation data set .
 gossip-based aggregation algorithms consisting  .
collection  .random. communication schedules  different topologies, different .random. input data sets .
well  outcomes  coin flips required   decision.
 tu-li occurs  , . .,   message gets silently.
dropped  .  communication schedules  drawn.
  appropriate discrete uniform distribution depending   used topology. concretely,  provide.
communication schedules  fully connected networks.
.com-fc-., hypercubes .com-hc-., . grids .com-.
 well  . tori .com-.   case   . .
  . . . . . . moreover,   network size .
provide corresponding input files containing  needed.
coin flips .ber-.  inputs  consider standard uniformly . .,  ., . distributed values .inp-us-. .
well  standard exponentially . ., . . . distributed.
values.
  extended abstract  provide exemplary insights   results  obtained   experimental.
studies.  detailed presentation  additional exper. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . .
.
.
.
.
number  nodes.
.
.
.
.
.
.
.
.
.
.
lms  pcf .
. . . . . . .
.
.
.
.
number  nodes.
.
.
.
.
.
.
.
.
.
.
lms  pcf .
figure . achieved accuracy  increasing number  nodes. simulation environment. . hypercube.
topology,  message loss, convergence criterion emax . . . . iterations., communication schedules.
com-hc-. . . . ., input data inp-us-. . . . . .left.  inp-es-. . . . . .right. see also.
tables .  .
iments  deferred   full version   paper. .
 explicitly stated else,  will   extended abstract always consider  .d-hypercube, . .,  network.
 . nodes  input data drawn   standard.
uniform distribution.
. failure-free scenarios   study .
practical impact  system failures  section . .
assume   section first failure-free environment .
discuss basic properties   considered algorithms.
 number  repetitions.  account  .
various sources  randomness   simulations .
always   repeat  certain scenario . input.
data    kind. sufficiently often    clear.
picture   difficulty   provided.  table .
 show   variation  communication schedules.
 input data leads   wide range  observed results.
convergence speed.  investigate algorithms.
 compute global aggregates locally  .
node. optimal parallel algorithms need .log . .synchronous. iterations .see . ., .  perform  computation  require  lot  assumptions   environment   usually hurt   context  distributed.
computing. moreover,  theory,   expect .
  algorithm .   fault tolerant variants.
converge asymptotically equally fast  well-connected.
networks, . .,  .log  . log . time.  figure .
  observe  theoretical claim   case  .
hypercube network. obviously, flow-updating shows.
 uncompetitive convergence speed  results .
 averaging technique used   algorithm . section . since flow-updating shares   fault tolerant properties    algorithm  will henceforth.
 consider   efficient  algorithm.
numerical accuracy.  existing theory .
gossip-based aggregation ignores  fact,   .
 deal  floating point arithmetic  real world systems. hence,    clear   theoretical predictions  convergence, etc.,  also  observed  practice.  non fault tolerant algorithms like  .
algorithm   problem  achieving full precision,.
 generally observe   discussed fault tolerant.
mechanism introduce numerical difficulties.  figure .
  see   achievable accuracy decreases unexpectedly fast   number  nodes. among .
fault tolerant algorithms  pcf algorithm shows .
far  best results.
. fault tolerance capabilities   following.
 inject different kinds  failures   computation  study  impact. since   considered.
fault tolerance mechanisms strongly dependend  .
individual node degrees  avoid extreme outliers .
considering regular network topologies.  assumption   restrictive since  results clearly translate.
also  practically relevant .almost regular. topologies.
like random geometric graphs.
silent communication failures. one   .
important failure scenarios  loosely coupled distributed environments  silently occurring communication failures,   refer   tu-li   classification scheme.  existing work clearly shows .
lost messages   handled  principal,  results .
 concrete costs  tolerating  certain rate  message.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . .
.
.,.
.,.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
message loss probability .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lms.
.pcf.
. . . . . . .
.
.,.
.,.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
xxxx.
message loss probability .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
lms.
.pcf.
figure . impact  message loss   convergence  limosense   .pcf algorithm. simulation.
environment. . hypercube topology, message loss probability , convergence criterion emax . . . .
iterations. top. communication schedules com-hc-. . . . ., input data inp-us-. . . . ., coin flips.
ber-. bottom. communication schedules com-hc-., input data inp-us-. . . . ., coin flips.
inp-us-. . . . . see also table .
loss  known.
 mentioned earlier,  simulator independently.
decides .based  coin flips given  input.  every.
communication   communication .silently. fails .
.  figure .  study  influence   increasing.
message loss rate   overall convergence. limosense  well   .pcf algorithm overcome .
type  failure without  explicit failure handling.
  limosense  failed communication   .
corrected   successful transmission   message .
  kind, . .,  message    sender.
 receiver,  flow-based approaches allow  .
bidirectional recovery.  means   successfully.
transmitted messages   two node   used.
  recovery.  theoretical advance explains .
superior convergence speed  flow-based approaches.
  empirically observe  figure .
  different approaches  handle message.
loss clearly differ   efficiency,  observe  principle satisfactory results, since  overhead increases.
gracefully   message loss rate. summarizing, despite    formal results   concrete overhead  tolerating  certain failure rate available,  get.
satisfying results  practice.
permanent failures.  contrast   handling.
 failures like tu-li   shown   possible.
without explicitly detecting  correcting occurring failures, tolerating permanent failures like pk-li requires.
  explicit failure handling.  current algorithms.
  done  algorithmically excluding  failed component   aggregate computation, . .,  setting.
flow  history variables  zero. thus,   failure.
handling   .artificial. operation    follow  usual steps   algorithm.  surprisingly,.
  intrusion   algorithm  severe consequence   basically observe  fall-back   convergence   arbitrary early stage independent .
 accuracy   already achieved .see fig. . .
fig. .  .  graphical illustrations   problem.
 behavior   studied figure . . limosense.
   algorithm.   see   overhead.
steadily increases  later  failure occurs. contrary.
 ,  pcf algorithm shows   minor constant overhead.   cases  pn-no  pk-no .
observe exactly   problems since  failing node.
  principal  interpreted   failure   .
communication links.
 observation used   pcf algorithm  gain.
 superior behavior  handling permanent failures .
 following.    algorithm  current estimate.
  node   computed .
.
.
.
.
.
. .
.
,.
.
.
. .
.
,.
.
  now set ,,  .   zero .due   permanent.
failure.  fraction .  change basically.
arbitrarily within  range   initial data .
thus,  will  general observe  fall-back  .
convergence    early stage. roughly speaking,.
 principal idea   pcf algorithm   achieve.
 fxi,.
.
,. . .    .  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . . . . . . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
index  flipped bit. sign .bit ., exponent .bits .  mantissa .bits .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . . . . . . . . . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
index  flipped bit. sign .bit ., exponent .bits .  mantissa .bits .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure .  single bit  gets flipped   flow variable   fixed node    local error  . . .top.
 . . .bottom.   first time, respectively.  strong relationship   iterations required .
convergence   index   flipped bit   observed. simulation environment. . hypercube topology, .
message loss, convergence criterion emax . ., communication schedules com-hc-. . . . ., input data.
inp-us-. . . . . see also table .
 also guarantees .
.
.
. .
.
,.
.
.
. .
.
,.
. .
.
., . .
.
,.
.
.
., . .
.
,.
.
 details   principal idea  realized concretely.
 refer  .
silent data corruption.  shape  flow-based.
aggregation algorithms . contrast  history-based approaches. allows  principal also  recovery .
silently occurring data corruptions  long   original input data   affected.  means, flowbased approaches   principle tolerate pu-ad .
 pu-id.  figure .  see   case   .
algorithm   position   single injected bit flip .
well   point  time   failure  injected.
influences  convergence speed. concretely,  observe   one hand  many bit flips   handled.
without  overhead whereas certain bit flips lead .
high overheads  even convergence problems. .
positions   overhead occurs   explained.
  fact     algorithm .without failures.
emax  monotonously decreasing, . .,    .
point  time  certain range  values. consequently,.
whenever  bit flip   effect  range,  algorithm naturally overcomes failure. clearly,  later.
 bit flip happens,  smaller emax gets  thus, .
 bits potentially lead   overhead . figure .
moreover,  argumentation also shows,   .
amount  bit flips   precise location  time .
occurrence determines  resulting overhead.
 understand better  certain bit flips even preclude  computation  correct results  briefly recapitulate  real numbers  represented  .double.
precision. floating point numbers.  real number  .
double precision  usually represented .
 . . . . . . . . .
  sign  . ., .,  mantissa . .  . .
  exponent . .  . . . . obviously, flips.
   significant bits   exponent  .
tremendous impact, especially   exponent  around.
 bias value .
  first glance  seems   irritating, .
 figure .  observe   earlier occurring bit.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . .
.
.
.
.
.
.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
xxxxxxxx.
accuracy prior   failure handling.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
 xxxx.
lms.
.
pcf.
figure .  single occurrence  pk-li  injected.
  fixed link  nodes     node.
. local error  . .   first time. except   pcf algorithm  observe   overhead  later  failure occurs    directly interpreted  improper failure handling. simulation environment. . hypercube topology,  message loss, convergence criterion emax . ., communication schedules com-hc-. . . . ., input data.
inp-us-. . . . . see also table .
flip  problems   flip    significant.
exponent bit whereas  later occurring bit flip leads .
problems  several    significant bits. .
observation   explained   nature   .
algorithm   know   flows gently develop.
. . grow.  time  reach  stable equilibrium.
  case   early bit flip,  always observe .
exponent smaller   bias value  .  thus,.
  change    significant bit leads  .
. absolute values. huge change   variable. .
  hand,   case   later bit flip, .
exponent sometimes exceeds  bias  therefore also.
 flip   next  bits   big impact  certain.
test cases.
summarizing,  see   diverse behavior  .
handling  bit flips .depending  several parameters.
 ranges   overhead   convergence wrong.
results. hence,  fully reliable protection  pu-ad.
   provided  state-of-the-art methods.
 table .  summarize  insights  gained.
  experimental work.  purely theoretical fault.
tolerance properties    observed substantial problems   practical behavior   evaluations  marked  . instead  .  central issue   revealed  table .      .
fault tolerance properties  . principal non fault.
tolerant. algorithm   preserved  approaches.
failure  lms   pcf.
tk-li.
. . . . .
pk-li.
. . . . .
tu-li .
. . . .
pu-li . . . . .
pn-no.
. . . . .
tk-no .
. . . .
pk-no . . . . .,.
tu-no .
. . . .
pu-no . . . . .
pu-ad . . . . .
pu-id . . . . .
table . practically observed fault tolerance properties.
 push-sum ., limosense ., flow-updating .,.
push-flow .  push-cancel-flow . . table .
  theoretically expected fault tolerance properties.
failures  abbreviated according   definitions .
section .
.histories  less efficient  flows,   observed results.
correspond   expectations  theory.
. failure handling   pcf algorithm   preserve.
 monotone convergence    algorithm,  shows .
 small overheads.
. initial data   failed node  excluded  .
aggregate.
striving  higher degrees  fault tolerance. besides.
, qualitative properties like full numerical accuracy.
get lost.   pcf algorithm addresses already.
   issues discovered   study  provides.
.major. qualitative improvements,  still shows several.
commonly observed weaknesses due   similar techniques   used. hence, entirely new fault tolerance techniques seem   required   improve.
fault tolerance.
. conclusions.
 theory, state-of-the-art robust gossip-based aggregation algorithms perform  well   non fault tolerant counterparts     time  provide high.
degrees  fault tolerance. since  existing theoretical.
work   address  performance impact  system.
failures, . .,  terms  convergence speed,  theoretical results   literature   sufficient   comprehensive evaluation  comparison  existing algorithms.  experimentally evaluated  theoretically.
 promising gossip-based fault tolerant aggregation.
algorithms  realistic .failure-prone. environments .
order  understand  well  existing mechanisms.
 achieving fault tolerance work  practice.
  experimental work  showed  simulation parameters like  .random. communication.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
schedules   input data  strongly affect .
achieved results    sound evaluation methodology  needed.  also illustrated   fault tolerance mechanisms incorporated   considered algorithms lead  unexpected practical problems  .
numerical inaccuracies. furthermore,  saw  several strategies  failure handling  work  theory   competitive  practice due  arbitrary.
fall-backs   convergence   aggregate computation. hence,  results presented   paper provide.
deep insights   behavior  practice  problems.
 state-of-the-art fault tolerant aggregation algorithms.
 reveal  big gap   existing theory .
 behavior  actual computations.
outlook. according   experimental observations  presented   work,  novel pcf algorithm shows substantial improvements  superior.
fault tolerance properties  previously existing approaches. nevertheless,  major failure types .
still   handled satisfactorily    .beneficial.
properties   baseline algorithms . ., monotone.
convergence  terms  emax.   preserved. thus,.
substantial theoretical investigations  required.
  focused   paper  scalar aggregation.
algorithms,  work naturally extends   complex.
operations built  top   atomic building blocks.
 particular,  aggregation-based distributed matrix.
operations .see .,., complex phenomena   .
expected due   complexity   algorithms .
 potentially large number  distributed aggregation.
processes involved. moreover,  work   fine-grained.
ns-. .-based simulation environment  allows.
 simulating aspects     reach  .
current theoretical results available   discussed.
algorithms.
</doc>
<doc title='13_ALENEX_14.txt'>
downloaded  knowledgecenter.siam.org.
 cost  address translation.
extended abstract.
tomasz jurkiewicz. kurt mehlhorn.
abstract.
modern computers   random access machines .rams.
   memory hierarchy, multiple cores,  virtual.
memory.   paper,  address  computational.
cost  address translation  virtual memory. starting.
point   work   observation   analysis .
 simple algorithms .random scan   array, binary.
search, heapsort.  either  ram model   .
model .external memory model.   correctly predict.
growth rates  actual running times.  propose  vat.
model .virtual address translation.  account   cost .
address translations  analyze  algorithms mentioned.
  others   model.  predictions agree .
 measurements.  also analyze  vat-cost  cacheoblivious algorithms.
. introduction.
 role  models  computation  algorithmics .
 provide abstractions  real machines  algorithm.
analysis. models   mathematically pleasing.
  predictive value.  aspects  essential.
  analysis   predictive value,   merely .
mathematical exercise.   model   clean .
simple, researchers will  use .  standard models.
 algorithm analysis   ram .random access.
machine. model .    .external memory.
model .
 ram model   far   popular model.
   abstraction   von neumann architecture. .
computer consists   control  processing unit .
 unbounded memory.  memory cell  hold .
word,  memory access  logical  arithmetic.
operations  words take constant time.  word.
length  either  explicit parameter  assumed  .
logarithmic   size   input.  model  .
simple   predictive value.
 external memory model  introduced   ram model   account   memory hierarchy  hence  ram model   predictive value  computations involving disks. modern.
.max planck institute  informatics, saarbru.cken, germany.
 saarbru.cken graduate school  computer science.
.max planck institute  informatics, saarbru.cken, germany.
machines   extensive memory hierarchy involving several levels  cache memory, main memory, .
disks, see section .   details.
 research started   simple experiment.
 timed six simple programs  different input sizes,.
namely permuting  elements   array  size ,.
random scan   array  size ,  random binary.
searches   array  size , heapsort   elements,.
introsort.   elements,  sequential scan   array.
 size .     programs, ., sequential.
scan   array  quicksort,  measured.
running times agree  well   predictions .
 models. however,  running time  random scan.
seems  grow  . log .   running time  .
binary searches seems  grow  .
.
 log. .
.
,  blatant.
violation    models predict.  give  details.
  experiments  section .
  measured  predicted running times differ. modern computers  virtual memories. .
process    virtual address space ., ., ., . . .
whenever,  process accesses memory,  virtual address    translated   physical address. .
translation  virtual addresses  physical addresses.
incurs cost.  translation process  usually implemented   hardware-supported walk   prefix tree,.
see section .  details.  tree  stored   memory hierarchy  hence  translation process may.
incur cache faults.  number  cache faults depends.
  locality  memory accesses.  less local, .
 cache faults.
 propose  extension    model, .
vat.virtual address translation.-model,  accounts.
  cost  address translation, see section . .
show   may assume   translation process.
makes optimal use   cache memory  relating .
cost  optimal use   cost   lru strategy, see section .  analyze  number  programs,.
including  six mentioned ,   vat model.
 obtain good agreement   measured running.
times, see section .  relate  cost   cacheoblivious algorithm    model   cost  .
.introsort   version  quicksort used  modern versions.
  stl.   purpose   paper, introsort   synonym.
 quicksort.
. copyright . siam.
unauthorized reproduction   article  prohibited.
vat model, see section .  particular, algorithms.
   need  tall-cache assumption incur   little overhead.  close   suggestions  .
research  consequences  teaching, see section .
related work.   well known   architecture  systems community  virtual memory .
address translation comes   cost. many textbooks.
 computer organization, . ., discuss virtual.
memories.  papers  drepper .dre., dre. describe computer memories, including virtual translation,  great detail. .adv. provides  implementation details.
 cost  address translation received little attention   algorithms community.  survey.
paper  . rahman .rah.  algorithms  hardware caches  tlb summarizes  work   subject.  discusses  number  theoretical models .
memory.  models discussed  .rah. treat address.
translation atomically, .,  translation  virtual.
 physical addresses   single operation. however,.
   longer true.  .-bit systems  translation.
process   tree walk.  paper   first  proposes  theoretical model  address translation .
analyses algorithms   model.
.  puzzling experiments.
. seven simple programs  used  following.
seven programs   experiments.     array.
 size .
. permute.   . . . . .  . random.
swap., .
. random scan.  . random permutation.   .
.  . . .  .  .
.  binary searches  random positions  .  .
sorted   experiment.
. heapify.
. heapsort.
. quicksort.
. sequential scan.
  ram,  first two,  last,  heapify.
 linear time .,   others  . log .
figure . shows  measured running times.  .
programs divided   ram complexity.  refer.
  quantity  normalized operation time. .
ram complexity   good predictor,  normalized.
operation times   approximately constant. .
observe  two   linear time programs show linear.
behavior, namely sequential access  heapify,  one.
  . log . programs shows . log . behavior,.
namely quicksort,      programs.
.heapsort, repeated binary search, permute, random.
access.,  actual running time grows faster  .
 ram model predicts.
 much faster  .
figure . also answers  . much faster. part.
  question. normalized operation time seems  .
 piecewise linear   logarithm   problem size.
observe    using  logarithmic scale  .
abscissa   figure.  heapsort  repeated binary.
search, normalized operation time  almost perfectly.
piecewise linear,  permute  random scan, .
piecewise linear    taken   grain  salt.
 pieces correspond   memory hierarchy. .
measurements suggest   running times  permute.
 random scan grow like . log .   running.
times  heapsort  repeated binary search grow like.
.
.
 log. .
.
.
. memory hierarchy   explain  .
argue   section   memory hierarchy .
 explain  experimental findings  determining.
 cost   random scan   array  size  .
  model  relating    measured running.
time.
 ,  . .,   size   i-th level   .
memory hierarchy. . . .  assume  . . .
 .  .    . .  . ., .,  array.
fits  level . . .    fit  level . .
 . .,  random address       . .
probability .     cost  accessing.
 address        .  expected.
. programs  compiled  gcc  version .debian .  run  debian linux  version .   machine .
processor intel xeon . .,. ghz, .mib. smart cache,.
.,. . qpi.  caption  figure . lists  machine.
parameters.   case  performed multiple repetitions .
took  minimum measurement   considered size  .
input data.  chose  minimum    estimating  cost.
 must  incurred.  also experimented  average .
median   results   change.  grew input sizes.
 factors  .  exclude influence  memory associativity.
 made sure   largest problem size still fitted  main.
memory.  also performed  experiments   machines.
 operating systems  obtained consistent results.
.kib  mib  modern, non ambiguous notations .
.  . bytes, respevtively.   details refer .
http.wikipedia.org.wiki.binary.prefix.
.  still working   satisfactory explanation  .
bumpy shape   graphs  permute  random access.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
. .
. .
. .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
permute. .
random. .access. .
binsearch. .
heapsort. .
heapify. .
introsort. .
sequen. .access. .
log.input size.
figure .  abscissa shows  logarithm   input size.  ordinate shows  measured running time.
divided   ram-complexity .normalized operation.
time.  normalized operation times  sequential access, quicksort,  heapify  constant,  normalized.
operation times    programs  .
total cost   external memory model  equal .
tem. . .
. .
.
. .
.
.
 . .
.
.
. .
. .
.
.
. . .
   piecewise linear function whose slope  .
 . .  . .  slopes  increasing, .
change    new level   memory hierarchy.
 used. figure . shows  measured running time .
random scan divided  em-complexity   function.
  logarithm   problem size. clearly,  figure.
  show  graph   constant function.
. virtual memory.
virtual addressing  motivated  multi-processing.
 several processes  executed concurrently .
  machine,   convenient   secure .
give  program  linear address space indexed  .
nonnegative integers. however, theses addresses  now.
virtual   longer directly correspond  physical.
.real. addresses. rather,    task   operating.
system  map  virtual addresses   processes.
  single physical memory.  mapping process .
hardware supported.
. function   form . log. . .  , ,  . .
 convex.  plot may  interpreted   plot   piecewise.
convex function.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
. .
. .
. .
. .
. .
. .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
log.input size.
figure .  running time  random scan divided .
 em-complexity.  used  following parameters.
  memory hierarchy.  sizes  taken .
 machine specification,   access times .
determined experimentally.
memory size . log.maximum access time.
level number  elements.  picoseconds.
. .kib . .
. .kib . .
. .mib .,. .
ram .
memory  viewed   collection  pages .
 . . cells.  virtual  real addresses consist   index   offset.  index selects .
page   offset selects  cell   page.  index  broken   segments  length  . logk.
 example,  processors   . family .see.
http.wikipedia.org.wiki.  . bit addresses  numbers .  . .,  . .,   . .
 remaining . bit  used   purposes.
logically,  translation process   walk  .
tree  outdegree .  tree  usually called .
page table .dre., .  walk starts   root.
 first segment   index determines  child .
 root,  second segment   index determines.
 child   child,   .  leaves  .
tree store indices  physical pages.  offset .
determines  cell   physical address, ., offsets.
  translated  taken verbatim.
 page table  stored   ram  nodes accessed   page table walk    brought .
fastest memory.  small number  recent translations.
 stored   translation-lookaside-buffer .tlb. .
tlb   small associative memory  contains pairs.
consisting  virtual  corresponding physical index.
  akin   first level cache  data.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.  virtual address translation model.
.vat model.
 full version   section   found  .
appendix.  model abstracts   . .
translation  performed   walk   tree  outdegree.
  depth   described .  translation.
process uses  translation cache    store .
nodes   translation tree.    changed .
insertions  evictions.     virtual address .
 , ., . . . , .   translation path.    root,.
.   child   root selected   first segment.
 ,   . translating  requires  access .
nodes   translation path  order.  nodes .
    accessed.  translation ends  .
 accessed.  next translation starts   next.
operation   .
 length   translation   number .
insertions performed   translation   cost.
  translation  . times  length.  length .
 least  number  nodes   translation path.
   present      beginning  .
translation.
.  replacement strategies since   .
 special case   cache   classic  machine, .
following classic result applies.
lemma . ., flpr.  optimal replacement strategy     factor . better  lru.
  cache  double size, assuming  caches start.
empty.
  caches,   natural  assume  initial.
segment property.
definition .  initial segment   rooted tree.
  empty tree   connected subgraph   tree.
containing  root.    initial segment.
property .isp.,    contains  initial segment.
  translation tree.   replacement strategy .
isp, ,   strategy,   isp   times.
isp  important ,   show later, isp .
 realized   additional cost  lru   little.
additional cost   optimal replacement strategy.
therefore, strategies  isp  significantly simplify.
proofs  upper  lower bounds. moreover, isp.
 easier  implement.  implementation  .
caching system requires  way  search  cache.
 requires  indexing mechanism. ram memory .
. real machines,    separate translation cache.
rather,   cache  used  data   translation tree.
.lru   strategy  always evicts  least recently used.
node.
indexed   memory translation tree.  case  .
 , isp allows  integrate  indexing structure.
  cached content. one    store  root.
  tree   fixed position.
lemma .   lru policy   use,  number   misses   translation  equal   layer.
number   highest missing node   translation.
path.
proof.  content   lru cache  easy  describe.
concatenate  translation paths  delete  occurrences   node except  last.  last  nodes.
  resulting sequence form  . observe  .
occurrence   node   deleted   node  part .
 latter translation path.  implies    contains   two incomplete translation path, namely.
 least recent path  still  nodes    .
 current path.  former path  evicted top-down.
  latter path  inserted top-down.  claim now.
easily follows.     highest missing node  .
current translation path.   descendant    contained   ,  claim  obvious. otherwise, .
topmost descendant present      first node.
  part   least recent paths   still  .
. thus   current translation path  loaded .
 ,  least recent path  evicted top-down. .
 consequence,  gap  never reduced.
 proof also shows  whenever lru detaches.
nodes   initial segment,  detached nodes.
will never  used .  suggests  simple.
.implementable. way  introducing isp  lru.  lru.
evicts  node  still  descendants   ,  also.
evicts  descendants.  descendants actually form.
 single path. next,  use lemma . .see appendix.
 make  algorithm lazy .   easy  see .
 resulting algorithm   islru  defined next.
definition . islru .initial segment preserving.
lru.   replacement strategy  always evicts .
lowest descendant   least recently used node.
proposition . islru  tcs   .   .
least  good  lru.
definition . ismin .initial segment property.
preserving min.   replacement strategy  tcs.
 isp  always evicts  node    used .
 longest time   future among  nodes  .
   current translation path    descendants. nodes  will never  used   evicted.
  others  arbitrary descendant.first order.
theorem . ismin   optimal replacement strategy among   isp.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
proof.     replacement strategy  isp, .
    first point  time   departs .
ismin.  will construct .  isp   .
depart  ismin including time     .
 misses  .     node evicted  ismin.
 time .
 first assume   evicts    later time.
. without accessing    interval ., .  .
simply evicts   time   shifts   evictions.
  interval ., .  one later replacement. postponing evictions   next replacement   cause.
additional insertions    break connectivity.
 may destroy laziness  moving  eviction   node.
right   insertion.   case . skips .
since  descendant        time ,  .
will will   used   longest time   future,.
none   children will  added    time .
therefore  change   break  connectivity.
 come   case   stores  till   accessed.
  next time, say  time .     node.
evicted    time . . evicts  instead   .
remembers    special.  guarantee  .
content   tcs   strategies   . differs.
     current special node till time ., .
 identical afterwords.  reach  goal . replicates.
 behavior   except  three situations.
.   evicts  parent   special node, . evicts.
 special node  preserve isp,    now.
 remembers  parent   special.  long.
  rule .  applied,  special node  .
ancestor  .
.   replaces  node    current special.
node, . skips  replacement   now .
remembers    special node. since  will.
 accessed  , rule .  guaranteed  .
applied  hence .  guaranteed  save  least.
one replacement.
.  time ., . replaces  special node  ,.
performing one extra replacement.
  shown   turn  arbitrary replacement.
strategy  isp  ismin without efficiency loss.
 proves  optimality  ismin.
  now state  isp-aware extension  lemma .
theorem .
min. . . ismin. . . islru. . .
. lru. . . .min.,.
 min   optimal replacement strategy  .
denotes  number  insertions performed  replacement strategy    initially empty   size  . .
  arbitrary,  fixed sequence  translations.
theorem . implies lru. . . .islru. .
ismin. . . .min.  inequalities  .
sharpened considerably.
theorem . lru. . . . islru. . .
ismin. . . . min. .
. analysis  algorithms.
  section,  analyze  translation cost .
 algorithms   function   problem size .
 memory requirement .    algorithms.
analyzed,  . .  assume.
. . .  .  cost  moving  single translation.
path         size   page,.
.,   least one instruction  performed  .
cell   page,  cost  translating  index .
 page   amortized.
.  . ., .,  fanout   translation tree  .
least two.
. . .  . . , .,  translation tree.
suffices  translate  addresses    much.
larger.   consequence log. . .  logk .
 . . . log. .  hence logk. . .  .
. . log. .
.  . , .,  translation cache  hold  least.
one translation path.
sequential access.  scan  array  size ,.
.,  need  translate addresses , ., . . . , .
  order,     base address   array.
 translation path stays constant   consecutive.
accesses  hence   . indices must .
translated   total cost    . . . . .
assumption .     . . . . . . .
 analysis   sharpened significantly. .
keep  current translation path  cache  hence .
first translation incurs    faults.  translation.
path changes  every  -th access  hence changes.
   total  .  times.  course, whenever .
path changes,  last node changes.  next  last.
node changes  every k-th access  hence changes.
  . times.  total,  incur.
.
.
.
. .
pki.
.
. .
.
 . .
.
.
 faults.  cost  therefore bounded  . .,.
  asymptotically smaller  ram complexity.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
random access.   worst case,  node.
  translation path   cache. thus  total.
translation cost  bounded  .    .
.
. . log. .
 will next argue  lower bound.  may assume.
   satisfies  initial segment property. .
translation path ends   random leaf   translation.
tree.  every leaf  initial segment   path.
ending   leaf  cached.     uncached node.
  translation tree  minimal depth     .
cached node  maximal depth.   depth    larger.
 two     depth  ,    better .
cache  instead   .  leaves use  instead.
 . thus   one   number  nodes .
cached  every translation path  hence  expected.
length   path cached    logkw  hence.
 expected number  faults   translation .
. logkw .  total expected cost  therefore  least.
.logkw . . . logk . . . . log. .,.
  asymptotically larger  ram complexity.
lemma .  translation cost   random scan .
 array  size    least . log. .  .
 . . log. .
binary search.    binary searches  .
array  length .  search searches   random.
element   array.  simplicity,  assume .
   power  two minus one. binary search  .
array  equivalent  search   balanced tree .
 root  stored  location .,  children  .
root  stored  locations .  .,   .
 cache  translation paths   top . layers  .
search tree   translation path   current node.
  search.  top . layers contain . . vertices.
 hence  need  store   . nodes.  .
translation tree.   feasible  . .  .  .
sequel,  . . log.
   remaining log  . . steps   binary.
search cause    cache faults. therefore  total.
cost per search  bounded .
.log . . .
.
. . log. .log . . .
.
.
.
log.
.
.
log.
.
.
.
 analysis may seem coarse.     search.
leaves  top . layers   search tree, addresses .
subsequent nodes differ   ., ., . . . , .
however,  will next argue   bound  .
essentially sharp   caching strategy. recall  .
. use vertex   nodes   search tree  node .
 nodes   translation tree.
two virtual addresses differ  ,  translation path.
differ   last dlogk. . nodes. thus  scheme.
 incurs  least.
.logn.
.
.
.
log.
.
.
.
.
.
.logn.
.
.
log . .
. .
.
.log . . . . .
.
.
log.
.
.
.
.
 faults.  next show   essentially holds true.
  caching strategy.
 theorem .,  may assume  islru  used.
  cache replacement strategy, .,  contains top.
nodes  recent translation paths.  . . dlog. .
  . . . vertices  depth .   binary.
search tree.  addresses differ  least . .
hence   two  addresses  translation paths.
differ   least  last  .
.
logk.
. .
.
nodes.
call  node  depth . expensive  none   last .
nodes   translation path  contained   .
 non-expensive otherwise.      .
inexpensive vertices  hence  probality  least.
.  random binary search goes   expensive.
node, call  ,  depth . since islru   cache.
replacement strategy,  last  nodes   translation.
path  missing   descendants  . thus, .
 argument   preceding paragraph,  expected.
number  cache misses per search   least.
.
.
.
.logn.
.
.
.
log.
.
.
.
.
.
.logn.
.
.
log . .
. .
.
.log . . . . .
.
.
log.
.
.
.
.
lemma .  translation cost   random binary.
searches   array  size     .
.
log .ndpw.
.
  least .
.
log .
.
.
 know  cache-oblivious algorithms   vanemde boas layout   search tree improves locality. .
will show  section .   improves  translation.
cost.
heapify  heapsort.  prove  bound  .
translation cost  heapify.  following proposition.
generalizes  analysis  sequential scan.
definition . extremal translation paths  .
consecutive addresses   paths   first  .
last address   range. non-extremal nodes .
 nodes  translation path  addresses   range.
     extremal paths.
proposition .  sequence  memory accesses .
gains access   page   range, causes  least one.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 miss   non-extremal node   range. .
 sequence  pages   range   accessed  .
decreasing order  bound  matched  storing .
extremal paths  dedicating logk. . cells   .
  required translations.
proposition .  , .    nonnegative integers. number  non-extremal nodes   union  .
translation paths       consecutive addresses.
  .
.
.
.
.
moreover,    set   .
.
.
.
addresses.
   union   paths  size  least . .
. . . .
proof.  union   translation paths   .
addresses contains   . non-extremal nodes .
 leaf level . level .   translation tree.  level.
,  . .,   bottom,  contains   .pki.
non-extremal nodes.
 overestimate  size   union   translation paths  counting one node   levels .  .
 every translation path  estimated non-extremal.
counting  nodes contained     translation.
paths   levels . thus  size   union .
bounded .
.
.
.
.pki. . .
.
 . .
.
.
. . .
.
.
 node  level . lies   translation path  .
consecutive addresses. consider addresses . ipk. .
 . ., ., . . . ,.
.
.
. . .,     smallest .
 set   addresses.  translation paths  .
addresses  disjoint  level .   level zero .
use  least one node  levels . .  . thus  size.
  union   least . . . . .
 array . storing elements   ordered.
set  heap-ordered  . . .  . . . .
   . .  . .  array   turned  .
heap  calling operation sift.   . .   .
sift. repeatedly interchanges  . .   smaller.
  two children   heap property  restored.
 use  following translation replacement strategy.
  . min.log , . . . . blogk. . . .
 store  extremal translation paths . . nodes.,.
non-extremal parts   translation paths   addresses ., . . . , .  one additional translation path.
. .blogk. . nodes  .  additional translation path   needed   . log .  .
siftdown  ., .  equal   address  ., . .
 address  one   children   . one  .
.  moved,    moved., .   address  one .
 grandchildren   . one   .  moved,.
  moved two levels .,   .  additional.
translation path .  used   addresses  .
   levels   level containing .
  upper bound  number   misses.
preparing  extremal paths causes   . misses.
next, consider  translation cost  , . .  .
 . .  assumes . distinct values. assuming.
 siblings   heap always lie    page.,.
 index .  part   address   .
translated.     decreasing  time  hence.
proposition . bounds  number   misses  .
number   non-extremal nodes   range.  use.
proposition .  count .   . ., . . . , . .
use  proposition   .   . . .  obtain .
bound .
.
.
. .
. .
.
.
 misses.     . . . . .  .  . .,.
 . . .   .  . .,  use  proposition .
 . .  obtain  bound   .
.
.
. . .
.
. .
.
.
. .
. . .
. .
.
.
. .
. .
. .
. . .
.
. .
.
.
.
. .
.
 misses.   . siftdowns starting  layers.
  ,  use .    siftdown,.
 need  translate   log  addresses  .
translation causes less   misses.  total  less.
 .log . summation yields.
. . .
. .
.
.
.
.
.
.
.
.
.
. .
.
.
 log .
.
.
.
.
 .
.
.
.
 log .
. .
.
.
  realistic values   parameters,  third term.
 insignificant, hence,  cost  .
.
. . npp .
.
. .
next prove  corresponding lower bound  .
additional assumption   . . .  least one.
address must  completely translated, hence, cost .
.  addresses  . . . . . assume  least one.
address per page  subarray .,    never.
jump    . first  addresses  swept.
 .,   .   ,    accesses  .
subarray occur   meantime. hence,  lru strategy.
  use,   . . ,    least . . .
misses   lowest level   translation tree. .
. assumption   easily lifted  allowing  additional.
constant  running time    size.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
gives  .
.
.
.
.
part   misses lower bound. hence,.
 total cost  .
.
. . npp .
.
.
. cache-oblivious algorithms.
algorithms    model  allowed  use .
parameters   memory hierarchy   program.
code.   two adjacent levels   hierarchy,.
  two parameters.  size    faster.
memory   size    blocks   data .
transfered   faster   slower memory.
cache-oblivious algorithm  formulated without reference   parameters, .,   formulated .
ram-algorithms.   analysis makes use  .
parameters.  transfer   block  memory  called.
 io-operation.   cache-oblivious algorithm .
.,, .   number  io-operations   input.
 size     size   faster memory .also.
called cache memory.     block size.  course,.
 . .
 several fundamental algorithmic problems, .,.
sorting, fft, matrix multiply,  searching,  .
cache-oblivious algorithm  match  performance.
  best em-algorithms   problem .flpr.
 algorithms  designed    show good.
locality  reference   scales  therefore one may.
hope   also show good behavior   vat.
model.    algorithms require  tall-cache.
assumption  . .
theorem . consider  cache-oblivious algorithm.
 io-complexity .,, .,    size  .
cache,   size   block,     input size. .
 . .    . .   size   page. .
 number   faults   .
.
.
.akip,kip, .
proof.  divide  translation cache   parts.
 size   reserve one part   level  .
translation tree.
consider  level ,   leaves   translation tree   level .  node  level  stands.
 kip addresses    store  nodes. thus .
number  faults  level    translation process .
    number  faults   algorithm .
blocks  size kip   memory   blocks ., size.
akip . therefore,  number   faults   .
.
.
.akip,kip, .
theorem . allows   rederive   .
results  section .  example, linear scan  .
array  length   io-complexity   . . .
thus  number   faults   .
.
.
.
. .
.
kip.
.
. .
.
 . .
.
.
.
 also allows   derive new results. quicksort.
 io-complexity . log.,  hence .
number   faults   .
.
.
.
. .
 .
log.
.
 .
.
. .
. .
.
log.
.
.
.
.
binary search  van emde boas layout  iocomplexity logb ,  hence  number   faults.
  .
.
.
log .
log.kip .
.
.
.
log .
. .
. log .
.
. log .
.
.
.
. .
.
.
log .
.
.
log .
.
.
. .
.
. log .
.
.
log .
.
.
 . log .
.
matrix multiply  recursive layout  matrices.
 io-complexity .,  hence  number.
  faults   .
.
.
.
.akip .kip.
.
.
. . .
.
. .
.
. commentary.
 received  number  comments   like .
shortly address   section.
.  model   cover everything current computers  highly sophisticated machines .
many features.  single feature requires  lot .
attention   modeled properly.  concentrated.
  single feature  leads   greatest analysis discrepancies   sequential algorithms. .
model   current shape applies  various architectures .even though   developed  context  .
. machines.,  precise modeling  remove .
advantage. moreover,  model  designed   independent extension   ram model.  way .
  coupled   . instance parallel. models.
 well,  little   modification.
.    relate  .   vat model.
 ignore   cache misses. however, since every.
translation  followed   memory access, one .
see  ram memory just  one additional level .
 translation tree. therefore,  fact vat implicitly.
covers   cache misses    branching factor.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.  model   complicated   received comments   model   simple,  also.
received ones saying   model   complicated.
   feeling   impression  due   fact.
    proofs  somewhat technical. .
  results   proven easier  asymptotic notation  used earlier,    vat cost  early upper.
bounded   ram cost . sequential access patterns   memory. however,     first work.
  subject,  find  appropriate    careful.
 absolutely necessary.  time,   .
simplifications will appear.  particular,   increasing amount  evidence suggesting   .
algorithms exact value     bring  new insights, hence, analysis   significantly simplified .
setting  . .
.  translation tree  shallow   true .
height   translation tree  bounded  today.
machines  .,    translation cost  bounded.
however, even though   experiments   .
need   . levels,  slowdown occurred appears.
   significant  one caused  factor log .
 operational complexity. therefore, decreasing vat.
complexity   high practical significance. please note.
  . bit addresses  sufficient  address .
memory    constructed according  known.
physics,    practical reasons  consider.
longer addresses. therefore, current bound  .
height   translation tree   absolute.
. conclusions.
 introduced  vat model  analyzed  fundamental algorithms   model.  showed  .
predictions made   model agree well  measured.
running times.  work  just  beginning. .
 many open problems,  example.  translation cost  incurred  cache-oblivious algorithms .
require  tall cache assumption. virtual machines incur.
 translation cost twice.    effect  .
   optimal vat-cost  sorting.
 believe  every data structure  algorithms.
course must also discuss algorithm engineering issues.
one  issue    ram model ignores essential.
aspects  modern hardware.   model  .
vat model capture additional aspects.
references.
.adv. advanced micro devices. amd. architecture.
programmer. manual volume . system programming,.
.
. alok aggarwal  . vitter, jeffrey.  input.output complexity  sorting  related problems.
commun. acm, ., september .
.dre. ulrich drepper.  every programmer .
know  memory. . http.lwn.net.
articles.
.dre. ulrich drepper.  cost  virtualization. acm.
queue, ., .
.flpr. . frigo, . leiserson, . prokop,  . ramachandran. cache-oblivious algorithms. acm.
transactions  algorithms, pages . . ., .
 preliminary version appeared  focs .
. john . hennessy  david . patterson. computer architecture.  quantitative approach. morgan.
kaufmann, san diego, .
.mic. pierre michaud. .yet another. proof  optimality.
 min replacement. http.www.irisa.caps.
people.michaud.yap.pdf, october . .
.rah. naila rahman. algorithms  hardware caches.
 tlb.  ulrich meyer, peter sanders,  jop.
sibeyn, editors, algorithms  memory hierarchies,.
volume .  lecture notes  computer science,.
pages . springer berlin . heidelberg, .
. .
. . . shepherdson  . . sturgis. computability.
 recursive functions. journal   acm, .
., .
. . sleator  . tarjan. amortized efficiency.
 list update  paging rules. commun. acm.
.cacm., ., .
appendix.
  vat model.
vat machines  ram machines  use virtual addresses. virtual addresses  motivated  multiprocessing.  several programs  executed concurrently.
   machine,   convenient   secure.
 give  program  linear address space indexed .
 nonnegative integers. however, now  addresses.
 virtual.    longer correspond directly .
addresses   physical memory. rather,  virtual.
memories   running programs must  simulated.
 one physical memory.
 concentrate   virtual memory   single.
program.  real .physical.  virtual addresses .
strings  ., . . ., . . . ,  . .  ., . .
part   address  called index,   length  .
 execution parameter fixed  priori  execution. .
 assumed   . dlogk.last used address. . .
., . . . ,  . . part   address  called page offset.
    page size.  translation process  .
tree walk.    k-nary tree   height . .
nodes   tree  pairs ., .  . . .   . .
 refer  .   layer   node     .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
number   node.  leaves   tree   layer.
zero   node ., .  layer . . .   children.
 layer . . ., namely  nodes . . ., . ., .
 . . . . . . .  particular, node ., .,  root,.
 children . . ., ., . . . , . . ., . .  leaves.
  tree store page numbers   main memory .
 ram machine.  order  translate virtual address.
. . . . .,  start   root   ,   follow.
 path described  . . . . .  refer   path.
  translation path   address.  path ends.
  leaf .,.
.
. xik.
.     page index.
stored   leaf.   .    memory cell.
denoted   virtual address. observe,    part.
  real address.
 translation process uses  translation cache .
  store  nodes   translation tree. .
  changed  insertions  evictions.    .
virtual address   , ., . . . , .   translation.
path. translating  requires  access  nodes  .
translation path  order.  nodes     .
accessed.  translation   ends  .  accessed.
 next translation starts   next operation .
 .
 length   translation   number .
insertions performed   translation   cost.
  translation  . times  length.  length .
 least  number  nodes   translation path.
   present      beginning  .
translation.
.  replacement strategies since   .
 special case   cache   classic  machine, .
following classic result applies.
lemma . ., flpr.  optimal replacement strategy     factor . better  lru.
  cache  double size, assuming  caches start.
empty.
 result  useful  upper bounds  lower.
bounds. lru  easy  implement.  upper bound.
arguments,  may use  replacement strategy .
 appeal   lemma.  lower bound arguments,.
 may assume  use  lru.   caches,  .
natural  assume  initial segment property.
definition .  initial segment   rooted tree.
  empty tree   connected subgraph   tree.
containing  root.    initial segment.
property .isp.,    contains  initial segment.
. real machines,    separate translation cache.
rather,   cache  used  data   translation tree.
.lru   strategy  always evicts  least recently used.
node.
  translation tree.   replacement strategy .
isp, ,   strategy,   isp   times.
proposition . strategies  isp exist  .
tcs   . .
isp  important  strategies  isp .
easier  implement.  implementation   caching.
system requires  way  search  cache. .
requires  indexing mechanism. ram memory .
indexed   memory translation tree.  case  .
 , isp allows  integrate  indexing structure.
  cached content. one    store  root.
  tree   fixed position.  will show  isp .
 realized   additional cost  lru   little.
additional cost   optimal replacement strategy.
. eager strategies   initial segment property   prove  isp analogue .
lemma .,  need  better understand  behavior.
 replacement strategies  isp.  classic caches.
premature evictions  insertions   improve efficiency.  will show    holds true  tcs.
 isp.  will  useful   will use early evictions  insertions     arguments.
definition .  replacement strategy  lazy  .
performs  insertion   missing node    node.
 accessed right ,  performs  eviction .
  insertion       free cell.
otherwise.    case  strategy  eager. .
 stated otherwise,  assume   strategy .
discussed  lazy.
eager strategies  perform replacements .
  needed,   even insert nodes  .
 needed  . also,   insert  re-evict,.
 evict  re-insert nodes   single translation.
 eliminate  behavior translation  translation .
follows. consider  fixed translation  define  sets.
 effective evictions  insertions  follows.
 .evict. .    evict.
 insert.   translation.
 .insert. .    insert.
 evict.   translation.
please note    case .  . means.
.  one .     two evict.
without  insert.  ,  two insert.
without evict.
proposition .  effective evictions  insertions modify  content       way.
  original evictions  insertions.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
proposition .   single translation  .
strategy  isp   use.
.  node   current translation path  effectively evicted,    nodes missing  .
current translation path  effectively inserted.
.   node  effectively inserted,  ancestor  descendant    effectively deleted. subject  obeying  size restriction   ,  may therefore.
reorder effective insertions  effective deletions.
 respect    .  changing  order   insertions   changing  order .
 evictions.
lemma .  eager replacement strategy  isp.
  transformed   lazy replacement strategy .
isp   efficiency loss.
proof.  modify  original evict.insert.access sequence translation  translation. consider  current.
translation        set  effective.
insertions  evictions.  insert  missing nodes.
  current translation path exactly   moment   needed. whenever,  implies  insertion   full cache,  perform one   lowest.
effective evictions,  lowest means   children.
  node    .  must    effective eviction  otherwise also  original sequence.
 overuse  cache.   nodes   current.
translation path  accessed,  schedule  remaining effective evictions  insertions   beginning .
 next translation. first  evictions  descendantfirst order    insertions  ancestor-first order.
 modified sequence  operationally equivalent  .
original one, performs   insertions,   .
exceed cache size. moreover,  current translation .
now lazy.
. islru,  lru   initial segment.
property even without isp, lru   property.
.
proposition .   lru policy   use,.
number    misses   translation  equal .
 layer number   highest missing node  .
translation path.
proof.  content   lru cache  easy  describe.
concatenate  translation paths  delete  occurrences   node except  last.  last  nodes.
  resulting sequence form  . observe  .
occurrence   node   deleted   node  part .
 latter translation path.  implies    contains   two incomplete translation path, namely.
 least recent path  still  nodes    .
 current path.  former path  evicted top-down.
  latter path  inserted top-down.  claim now.
easily follows.     highest missing node  .
current translation path.   descendant    contained   ,  claim  obvious. otherwise, .
topmost descendant present      first node.
  part   least recent paths   still  .
. thus   current translation path  loaded .
 ,  least recent path  evicted top-down. .
 consequence,  gap  never reduced.
 proof  also shows  whenever lru.
detaches nodes   initial segment,  detached.
nodes will never  used .  suggests  simple.
.implementable. way  introducing isp  lru.  lru.
evicts  node  still  descendants   ,  also.
evicts  descendants.  descendants actually form.
 single path. next,  use lemma .  make .
algorithm lazy .   easy  see   resulting.
algorithm   islru  defined next.
definition . islru .initial segment preserving.
lru.   replacement strategy  always evicts .
lowest descendant   least recently used node.
due   construction  lemma .   .
following.
proposition . islru  tcs   .   .
least  good  lru.
remark .  fact  proposition holds also .
 . , even though islru  longer  isp  .
case.
. ismin.  optimal strategy  .
initial segment property.
definition . ismin .initial segment property.
preserving min.   replacement strategy  tcs.
 isp  always evicts  node    used .
 longest time   future among  nodes  .
   current translation path    descendants. nodes  will never  used   evicted.
  others  arbitrary descendant.first order.
theorem . ismin   optimal replacement.
strategy among   isp.
proof.     replacement strategy  isp, .
    first point  time   departs .
ismin.  will construct .  isp   .
depart  ismin including time     .
 misses  .     node evicted  ismin.
 time .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 first assume   evicts    later time.
. without accessing    interval ., .  .
simply evicts   time   shifts   evictions.
  interval ., .  one later replacement. postponing evictions   next replacement   cause.
additional insertions    break connectivity.
 may destroy laziness  moving  eviction   node.
right   insertion.   case . skips .
since  descendant        time ,  .
will will   used   longest time   future,.
none   children will  added    time .
therefore  change   break  connectivity.
 come   case   stores  till   accessed.
  next time, say  time .     node.
evicted    time . . evicts  instead   .
remembers    special.  guarantee  .
content   tcs   strategies   . differs.
     current special node till time ., .
 identical afterwords.  reach  goal . replicates.
 behavior   except  three situations.
.   evicts  parent   special node, . evicts.
 special node  preserve isp,    now.
 remembers  parent   special.  long.
  rule .  applied,  special node  .
ancestor  .
.   replaces  node    current special.
node, . skips  replacement   now .
remembers    special node. since  will.
 accessed  , rule .  guaranteed  .
applied  hence .  guaranteed  save  least.
one replacement.
.  time ., . replaces  special node  ,.
performing one extra replacement.
  shown   turn  arbitrary replacement.
strategy  isp  ismin without efficiency loss.
 proves  optimality  ismin.
  now state  isp-aware extension .
lemma .
theorem .
min. . . ismin. . . islru. . .
. lru. . . .min.,.
 min   optimal replacement strategy  .
denotes  number  insertions performed  replacement strategy    initially empty   size  . .
  arbitrary,  fixed sequence  translations.
proof. min   optimal replacement strategy,   .
better  ismin. ismin   optimal replacement.
strategy among   isp,    better .
islru. islru  better  lru  proposition .
lru. . . .min. holds  lemma .
. improved relationships.
theorem . implies lru. . . .islru. .
ismin. . . .min.   section,  sharpen.
 inequalities.
lemma . lru. . . . islru. .
proof.  nodes  sufficient  lru  store one.
extra path, hence,   construction, lru  .
larger cache always stores  superset  nodes stored .
islru. therefore,  causes    misses   .
lazy.
theorem . ismin. . . . min. .
 order  reach  goal,  will prove .
following lemmas  modifying  optimal replacement.
strategy  intermediate strategies   additional.
replacements.
lemma .    eager replacement strategy.
   size  . .  except   single special.
cell  isp,  causes    misses .
optimal replacement strategy    size   .
restrictions.
lemma .    replacement strategy  isp.
   size  .   causes    misses.
  general optimal replacement strategy   .
size  .
since ismin   optimal strategy  isp, theorem . follows  lemma .
  remainder   section  lemmas .
theorems require  assumption  .   .
 . however, even   latter theorems, .
sometimes  give  proof   case  . .
. belady. min algorithm recall  belady. algorithm min, called also  clairvoyant algorithm   optimal replacement policy.  algorithm.
always replaces  node  will   accessed .
 longest time   future.  elegant optimality proof   approach  provided  .mic. min.
  differentiate  nodes  will  .
used . therefore, without loss  generality  .
 now  consider descendant.first version  min.
  point  time,   call   nodes .
   still accessed   current translation .
required nodes.  required nodes  exactly .
nodes     current translation path,  .
descendants   last accessed node .  whole path.
  translation     begin.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
lemma . .      .  long  .
  descendant         required.
node, min will  evict .
.   . , min never evicts  root.
.   . , min never evicts  required node.
proof. . .   will  accessed ever , .
 will  used earlier .   translation., .
 min evicts   .   will never  accessed.
,  min evicts       .
descendants.first version. . . either  stores.
whole current translation path,   eviction occurs.
    cell     contains  node  .
current translation path, hence,  root   evicted.
    non required descendant   . .
. either  stores whole current translation path, .
   cell      content  will  .
used   required node. hence,  required node.
  node  will   needed   longest time.
  future.
corollary .   . , min inserts root  .
   first thing   first translation,  never.
evicts .
lemma .   . , min evicts  .non-required.
nodes   stored descendants   node  .
just used.
proof.  min evicts  node   current translation.
path    descendant   just translated node.
.lemma ., claim .,  also   ancestor  .
just translated node .lemma ., claim . hence, .
 just translated node  admissible.   algorithm.
evicts  node   current translation path  must.
  descendants .lemma ., claim .
lemma .  min  evicted  node  .
just accessed,  will continue    also   .
following evictions   current translation.  will.
refer    round robin approach.
proof.  min  evicted  node    just.
accessed,  means     nodes stored  .
 will  reused   evicted node. moreover,.
 subsequent nodes traversed     current.
translation will  reused even later     . .
case   .   claim holds  lemma .
corollary .   single translation min proceeds   following way.
.  starts   regular phase   inserts.
missing nodes   connected path   root .
  node ,  long    evict nodes .
will   reused  just used ones.
.  switches   round robin phase  .
remaining part   path.
  easy  see    . ,   path .
 traversed   round robin fashion, informally.
speaking,  gaps move   one.   gap .
stored nodes,    cell   used  store.
 node   gap now stores  last node  .
gap. storage   nodes   change.  way.
 number  nodes   path stored   .
  change either. however,  reduces numbers .
stored nodes  side paths attached   path.
. proof  lemma .  introduce  replacement strategy rrmin.  add  special cell  .
 ,   refer   remaining  cells  regular .  will show   cell  allows  .
 additional  misses,  preserve isp   regular .  start   empty ,   run min.
  separate   size    side  observe .
decisions.
 keep track   partial bijection. .  nodes.
  translation tree.  put one timestamp  .
every  access,    regular phase  min one.
   two accesses.  position evictions.
 insertion   timestamps,   one .
  two consecutive accesses.  time , .
maps every node stored  min      node.
stored  rrmin   regular . function . always.
maps nodes  . necessarily proper. ancestors  .
memory translation tree.  denote   .  ,.
  case  proper ancestors  . . .  say.
    witness  .
proposition . since  partial bijection . always maps nodes  ancestors,  every path  .
translation tree, rrmin always stores  least  many.
nodes  min.
 order  prove  lemma .  need  show .
 preserve properties   bijection .  isp. .
accordance   corollary ., min inserts  number.
 highest missing nodes   regular phase,  uses.
round-robin approach   remaining ones.
  first consider  case  min  .
regular phase  inserts  complete path.  .
case  substitute evictions  insertions  min .
 described .
 min evict  node .  .   descendants.
rrmin evicts .    case  find . .
descendant  .   descendants   .
.round robin min.
. partial bijection   set   bijection  two subsets.
  set.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
rrmin evicts .,   set . . . .
clearly,  preserved properties  .
.  isp.
holds.
now  min insert  new node .   point .
know   rrmin  min store  ancestors .
.  rrmin   store  yet, rrmin inserts  .
 set . . . .    already stored,  means .
  witness . .    proper descendant  .
  find  sequence   . .  . .  . . . .
. . . ,  ends   rrmin   store yet.
  exists  .   injection   finite set, .
 undefined  .  set . . .    elements.
  sequence except . rrmin inserts highest .
stored ancestor      set . . .  . note,.
 inserted node  might    required node.
properties  .  preserved,  rrmin  .
disconnect  tree  stores. also, rrmin performed.
  number  evictions  insertions  min.
note  well,    nodes   translation path.
.  identity. finally, proposition . guarantees .
 access  safe  perform   time  .
scheduled.
now   consider case  min   regular.
 round robin phase. assume   regular phase.
ends   visit  node .   point, min stores.
 .nonempty   .  due  collorary . initial.
segment    current path ending  ,   .
contain . child   current path,   contains.
 number .maybe zero.  required nodes. starting.
 . child, min uses  round-robin strategy.
whenever,    insert  required node,  evicts.
 parent.  .  .   number  evictions .
 regular  round-robin phase, respectively.
rrmin also proceeds  two phases.   first.
phase, rrmin simulates  regular phase  described.
. rrmin also performs . evictions   first.
phase  .   identity     end   first.
phase.  holds  . maps nodes  ancestors,.
 since min contains    entirety   end.
  regular phase.  .   number  nodes.
  current path  . min stores . . . .
   beginning   round-robin phase, .
     insert,    store .  ,.
    insert. since .   identity  .
 phase .   simulation  maps  . . .
required nodes stored  min  ancestors, rrmin.
stores  least  next . . . required nodes .
   beginning  phase .   simulation.  .
round-robin phase rrmin inserts  required nodes.
missing   regular  one   </doc>
<doc title='14_ALENEX_19.txt'>
downloaded  knowledgecenter.siam.org.
 unifying  space  .-sampling algorithms.
graham cormode. donatella firmani.
abstract.
 problem  building  .-sampler   sample nearuniformly   support set   dynamic multiset. .
problem   variety  applications within data analysis,.
computational geometry  graph algorithms.   paper,.
 abstract  set  steps  building  .-sampler, based.
 sampling, recovery  selection.  analyze  implementation   .-sampler within  framework,  show.
 prior constructions  .-samplers    expressed.
 terms   steps.  experimental contribution  .
provide  first detailed study   accuracy  computational cost  .-samplers.
. introduction.
 recent years,     explosion  interest.
 sketch algorithms. compact data structures  compress large amounts  data  constant size  capturing key properties   data.  example, sketches realizing  johnson-lindenstrauss lemma . allow  euclidean distance  high dimensional vectors   approximated accurately via much lower-dimensional projections ., ., . many constructions   new area  compressed sensing  also  expressed  sketches . since.
 sketches   updated incrementally  merged together,    used  streaming  distributed settings.
due   flexibility, sketches  found use   wide.
range  applications,   network monitoring ., log.
analysis .  approximate query processing .
  practical motivations,  since  .
often several competing sketch constructions   .
problem,   important  unify  compare  efficacy.
 different solutions. prior work  evaluated  performance  sketches  recovering frequent items ., .,.
  tracking  cardinality  sets  items ., . .
 work,  focus  sketches   fundamental sampling.
problem, known  .-sampling.   large data set  assigns weights  items,  goal   .-sampler   draw.
.approximately. uniformly   set  items  nonzero weight.   challenging, since   item may.
appear many times within  raw data,  may   aggregate weight  zero. meanwhile, another item may appear.
.graham.research.att.com.
.firmani.dis.uniroma.  work  done  .
author  visiting shannon laboratories  dimacs.
    non-zero weight.  sketch must  designed     aggregate weight influences  sampling process,   number  occurrences   item.
 sampling distribution turns     number.
 applications. drawing   sample allows one .
characterize many properties   underlying data, .
  distribution  occurrence frequencies,  .
natural functions   frequencies.  queries .
 .inverse distribution. . gives  fraction  items.
whose count  .  important within  variety  network.
 database applications . .-sampling  also used .
geometric data,  generate .-nets  .-approximations .
approximate  occupancy  ranges.   approximate.
 weight  .geometric. minimum spanning trees .
 recently,    shown  .-sampling allows .
construction  graph sketches,   turn provide  first.
sketch algorithms  computing connected components, kconnectivity, bipartiteness  minimum spanning trees .
graphs .
 response   motivations, several different constructions  .-samplers   proposed. early constructions made use  universal hash functions ., .
stronger results  shown using higher-independence.
hash functions .,   recently assuming fullyindependent hash functions . comparing  approaches,  observe     common outline  .
.  hashing procedure assigns items  levels   geometric distribution,    item  consistently assigned.
   level. whenever  appears   data. .
  level,  .sparse recovery. data structure summarizes.
 items  weights.   number  items  non-zero.
weight   level  small enough,   full set  .
recovered.  sample  drawn  choosing  appropriate.
level, attempting  recover  set  items   level, .
selecting one   sampled item.
although similar  outline,  constructions differ .
 details   process    description.  .
work,  provide  single unified framework  .-sampling.
  analysis,  demonstrate   prior constructions.
fit   framework based   small number  choices.
primarily,  strength  hash functions used,   nature.
  recovery data structures adopted.  characterization allows   better understand  choices   prior.
constructions.  also allows   present  detailed empirical comparison  different parameter settings,   . copyright . siam.
unauthorized reproduction   article  prohibited.
fluence   performance   sampling procedure, .
terms  speed  uniformity. despite  many applications,     prior experimental comparison.
 .-sampling algorithms   costs.  experiments.
show   algorithms   implemented effectively,.
 sample accurately   desired distribution  low.
costs.
outline. first,  present  formal definition  .sampling  section .  section .  give  .sampler algorithm,  analyze  performances  .
 achieved assuming  perfect s-sparse recovery algorithm.
  describe   construct  randomized exact ssparse recovery algorithm,  hence realize  .-sampler.
 finally discuss   framework incorporates  results  ., ., .  present  experimental comparison  methods  section .
.  .-sampling problem  give  formal definition  .p-samplers  data defining  vector.
definition . .p-distribution.   .    nonzero vector.   . .  call  .p-distribution corresponding  vector   distribution  .  takes  .
probability .
.
.  . . .
.
. .   .pnorm  .   . .,  .-distribution corresponding  .
  uniform distribution   non-zero coordinates .
,   denoted  supp .
 sketch algorithm   .-sampler    take .
input  stream  updates   coordinates   nonzero vector ,  output  non-zero coordinate ., . .
.  algorithm may fail  small probability . ,.
conditioned   failure, outputs  item  . supp  .
corresponding weight .  probability.
. . . .
. .
  parameter .  quantity . . . supp .  often.
called  .-norm .although    strictly  norm. .
represents  number  non-zero coordinates  .
.  .-sampling process.
 observe  existing .-sampling algorithms   described  terms   three-step process, namely sampling,.
recovery  selection.   illustrated schematically  figure .
. sampling. given vector ,  sampling process.
defines  vectors ., . . . , . .   . .
. generally,  also seek solutions  , given sketches  vectors.
  ,   form  sketch  .  sample   .-distribution.
 . .   algorithms   discuss   property.
  . .,  vector . contains  subset  .
 coordinates   input vector awhile  others .
set  zero. , supp . . supp .  vectors.
  materialized,   summarized implicitly .
 next step.
. recovery.  recovery piece creates  data structures based   parameter .    . .,  .
 s-sparse   structure allows   recover .
 probability . . .  call  .exact s-sparse.
recovery.
. selection.   .-sampler  used  draw .
sample,  level  . .  chosen    vector.
.   s-sparse . non-empty.   non-zero.
vector .   level  successfully recovered, .
 entry   vector ., .  selected  returned.
  sampled item.
 mentioned , existing .-samplers ., ., .
fit  pattern,  vary  details. specifically,  differ .
  subsets   chosen   sampling step,  .
 specification   s-sparse recovery data structure.
. .-sampling  k-wise independent hashing .
 section,  describe  analyze  instantiation  .
 framework  synthesizes  prior results  .
area.   show   captures existing algorithms .
 problem  special cases.
    k-wise independent family  hash functions,   . .,    . . . .  randomly.
selected  .  .-sampling algorithm  defined .
. sampling.  . . .,  set . . ,.
else set . . .  get . .   uniform.
probability  . . ,   . .log .
. recovery.  describe  analyze   perform.
 s-sparse recovery  section .
. selection.  selection process identifies  level .
   non-zero vector .  attempts  recover.
 vector   level,  .  successful,  nonzero coordinate ., . obtaining  smallest value.
 .  returned   sampled item.
 use  notation  . .   . .
 random variable    thought    sum  .
bernoulli random variables  . ., .,   represents.
 event . . ,  . supp .  expectation   .
. .
. analysis   .-sampler  show   .sampler achieves high success probability  small error .
 .-distribution, without requiring full randomness  .
  purpose   analysis,     perfect s-sparse.
recovery algorithm.  ,  algorithm   recover.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 . . .
return .
else.
return dense.
recovery.
recovery failure.
. . ., .
.
.
.
.
.
.
.
.
  . .
set . . .
else.
set . . .
sampling.
 .
.
 . . .
return ., .
else.
return fail.
selection.
., .
figure . overall .-sampling process,  . .log .
 vector xwith . . ,  otherwise outputs fail. .
 denote   selection step algorithm using .
lemma . .probability  successful recovery.
given  k-wise independent family ,   . . .
 . .log .,  .-sampler successfully recovers .
item  probability  least . .
proof.  .   vector extracted   sampling step.
 submitted   recovery step.  . . . . .
.  recovers  vector . . .  probability.
.,  .  s-sparse    will succeed. . .
outputs  non-zero coordinate ., .,  .  nonzero    choose .
 probability   event . . . .  .
therefore lower-bound  probability  success   .sampler, .outputs . supp . consider  particular .
level   .
.
.
. . . . .
.
  vector .,   compute  probability .
 event . . . . ,   probability   .
close   expectation . . . npj .
. . . . . .
. . .  . . .
. . .  . .
 invoke ., theorem .,  gives  chernoff.
bound-like result  limited independence.    .
sum  k-wise independent random variables,   .
 confined   interval ., .,    . .   .
dre.
. . . . . exp.
thus, since   . . . . ,  obtain.
. . . . . . . exp. . .
  . .  .
setting  . . log .  ensure    recover .
 level   high probability . possibly also recover.
 higher levels  also. hence,  obtain  claimed result.
  success probability   .-sampler.
.outputs . supp . . . .  . . . . .
.
lemma . .output distribution  .-sampler.
 . . .    success probability   .-sampler.
. lemma .   sampler outputs  item.
 . supp   probability . exp. . . .
proof.  make use   fact    chosen  .
.log .-wise independent   large enough range,.
    obtains  smallest value  .  chosen  probability . . . .  follows since   approximately min-wise independent . since   .wise independent,     chosen  probability.
. exp. .
however,    account   fact  .
instances fail, due    many items chosen  level.
.    argument,  happens  probability .
 . . . consequently,  probability  picking  .
affected     additive . amount. thus,  obtain.
   output  probability . exp. . . . .
note    setting,  single parameter  controls.
  relative error term   additive error term, .
 obtain  guarantee   form . . . . . .,  set.
 . .max.log ., log .
recovery level selection.   analysis indicates .
  likely    level    recovery  succeed,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
  sampling   level approximates  desired.
distribution.   implementation,   two approaches.
 choosing  level  recovery.  first   run .
approximate . estimation algorithm  parallel   .sampler,  use  estimate    choose  level .
  well-principled,  adds  overhead   process.
 alternative   aggressively attempt  recover vectors,.
 sample   first level  succeeds.  compare.
 alternatives empirically  section .
. sparse recovery   section,  discuss  .
implement  efficient s-sparse recovery algorithm. many.
approaches   made   question, due  .
connection  problems  coding theory  compressed.
sensing.  ., ganguly provides  solution   exact.
s-sparse recovery problem  non-negative vectors  .
.  space required  close  linear  .  .
 sketch-based solution  described  provides small.
failure probability   . ,  requires substantial space.
.polynomial  . ,  give  exact s-sparse recovery.
algorithm   . , built using multiple instances  .
.-sparse recovery structure.
. perfect .-sparse recovery  natural approach .
building  .-sparse recovery algorithm   keep track .
 sum  weights .,   weighted sum  item identifiers.
., .
. .
.
.supp   .   . .
.
.supp  .
given  update .,.   coordinates   input.
vector ,  counters  updated accordingly. . . . .
 . . .   easy  verify ,   input vector .
 indeed .-sparse,  . .   . . however, additional.
tests  required  determine    truly .-sparse.  simple.
test proposed  ganguly .   additionally compute.
. .
.
.supp   . .,  check  . . . .  test will.
always pass    .-sparse,    straightforward .
show   will  pass     .-sparse, provided .
entries    non-negative. however,   may contain.
negative entries,  test may give  false positive.
 now propose  variant test  works  arbitrary integer vectors.     suitably large prime, .
choose  random  . .  compute  fingerprint.
. .
.
.supp   .  mod ,  test  . . . . .
mod .
lemma .    .-sparse,   fingerprint test always gives  positive answer.    s-sparse,  . ., .
 fingerprint test gives  negative answer  probability.
 least . .
proof.    .-sparse,  input vector contains  single nonzero coordinate ., . therefore . .  .   . . . .
get . . . .  . .
.
 .  . , therefore . . . . .
mod ,  required.
   case,   easy  verify   fingerprint.
test gives  positive result  two cases. .   .-sparse. .
   root     polynomial . .
.
.supp   .
. . .
 .failure. probability   test  given  .
probability  . since .  degree , .   .
 roots  .    chosen independently   , ., ., .
probability    one   roots    .,  .
claimed result follows. .
 space required   .-sparse recovery algorithm.
 .log  . log  . log . bits,  .,.  .
range   frequencies  .   following  assume.
.log . log . log . . .log .
. exact s-sparse recovery algorithm  now describe   build  s-sparse recovery algorithm using .sparse recovery   primitive.  .   family  pairwise independent hash functions,    . . . .,.
 . .log .,  randomly selected  .  denote.
 .  .-sparse recovery algorithm shown   section .,     exact s-sparse recovery algorithm. similar  .,  use  two-dimensional array, .
log . rows  . columns,   cell contains .
instance  .,  illustrated  figure .
given  update .,.   coordinates  input.
vector , .,.  submitted  log . independent instances ofp.,     position .row, column. .
., .  perform  recovery,  algorithm interrogates    instances  .,  extracts  unique.
item stored ,    one.  total collection  recovered items  weights  returned   recovered vector .
lemma .  exact s-sparse recovery algorithm recovers  s-sparse vector ,  probability  least . . .
proof.  start   analysis   probability .reci.
  recovers  particular coordinate ., .  , .
 extend  result   .s-sparse. vector .   end,.
 ,   sum  . .  . . random variables.
 . ., .,    representing  event . .
.   . . . . . writing  .
 .,.supp  ,    ., . . . .,. . . .
 probability     recover    row .
therefore .
log . . . summed    non-zero.
coordinates,  recover    probability  least.
. . .
 comment     possibility   false.
positive  one   . structures erroneously reports .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
., .
.
.
.
.
.
.
.
.
.
.
.
.
.
log .
figure . exact s-sparse recovery  perfect .-sparse recovery.
singleton item.  probability  polynomially small .
 based   choice   prime  . poly.,  .
discount .  also remark    case    .
  entries,  procedure may recover  subset  .
  either accept  outcome,  detect   keeping .
additional fingerprint     entirety,  comparing .
  fingerprint   recovered vector.  size  .
data structure   . log. instances  ., . .
total  . log  log. bits.
. main result  comparison  previous results.
replacing  perfect s-sparse recovery procedure assumed.
 section .    procedure affects  output.
distribution     additive . hence, combining.
lemmas ., .,  .,  obtain.
theorem . given  k-wise independent familyfk, .
 . .   . .log . . log .,  .-sampler.
succeeds  probability  least . . . , conditioned.
 successful recovery, outputs  item  . supp  .
probability . . . . .
 space complexity   .-sampler .
. log.  log . bits,   set . . . . . .
space  dominated   .log . instances   s-sparse.
recovery algorithms.   set . . . . poly.,  .
additive error term  absorb  relative error term, .
 obtain.
corollary .    .-sampler using space.
.log. . bits  succeeds  probability  least .
, conditioned  successful recovery, outputs item  .
probability . . .  constant .
 now compare  construction   described .
prior work.
full independence.  analysis   .-sampler  .
assumes full independence  ,   recovery step.
 implemented   perfect s-sparse recovery algorithm.
jowhari, saglam  tardos prove   .-sampler  .
. note  tighter bounds  possible via  similar construction  .
 involved analysis. adapting  approach  eppstein  goodrich .
improves  log term  log.  log . ,   analysis .
price .  improves   logs . .
succeeds  probability  least . . . , conditioned.
  failure, outputs  item  . supp   almost.
uniform probability.  total space cost  .log . levels,.
   uses  s-sparse recovery algorithm   .
.log . assuming full independence means  . .
 assumed   .,    error arises   failure.
probability.
.-min-wise independence.  analysis   .-sampler.
 . assumes  log .-wise independence offk,   .
.,  get .-min-wise independence   elements .
 recovery step  implemented   exact s-sparse.
recovery algorithm,  . . .
monemizadeh  woodruff prove   .-sampler.
 . succeeds  probability  least . . . ,.
conditioned   failure, outputs  item  . supp  .
probability . . . . .  space complexity  stated.
 poly. log . bits . fact,  dependence  . appears.
    poly.log . essentially   result .
shown  theorem .,   dependency  log . .
log   made explicit.
pair-wise independence.  ., frahling, indyk .
sohler describe  .-sampler using pairwise independence.
  .  , items  mapped  levels  geometrically decreasing probabilities . .    level, items.
  hashed  . buckets,  information  one.
  buckets  retained. however,  secondary hashing   thought   equivalent  mapping   higher.
level  . log .,  attempting recovery   level .
similar approach  described  .  process succeeds.
  unique item  recovered.  analysis  lemma .
  apply directly   . .,   modified analysis.
suffices  show   probability  recovering  unique.
item  level . logn  .,  conditioned   event, .
probability  choosing  item  . .  appears .
 high accuracy .small .,  . repetitions required.
 obtain  sample  constant probability may drive .
space cost   approach higher   approaches. .
refer   variant approach  .fis.,   initials  .
authors.
. experimental evaluation.
  section  present  experimental analysis   .sampling process described  far.  experimental objec. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
tives  threefold. .  study  accuracy  .-sampling.
 k-wise independent hashing .  quantify  running.
time  space requirements   data structures,  .
 tune  parameter   practical scenarios. first, .
give  details   implementation, benchmarks, .
methodology.
framework implementation.  implemented  .sampler    framework  allows   compare different.
parameter settings  implementation choices.  set  .
.,   tests showed  setting smore  . .
 help  practice.
 conducted two sets  experiments based  .
assumptions   s-sparse recovery data structure, used.
 recover items   particular level .
.   purpose  testing different settings   .
 error due   sampling step,  kept exact.
information   items mapped   level.  lets.
 simulate  .ideal. s-sparse recovery process .
guarantees . . . however,  still consider  level.
  .failed.     items  mapped  .
level   sampling process. ,  compare .
two versions   recovery level selection step. one.
assuming .exact. knowledge     probe level.
dlogn.     tries  level  turn.
  item   sampled.
.  final experiments implement  efficient s-sparse.
recovery mechanism described  section . .
 representation,  space required  linear  ,.
   update  sketch  constant time  .
constant number  direct memory access. although.
 analysis indicates  log . rows  sufficient.
 guarantee recovery  high probability,  found.
  experiments  using .  . rows worked well.
enough  practice.
 measure  memory cost assuming   space.
 used  .empty. levels .   items mapped .
.,    account   occupied levels.  return.
  issue  section .
benchmarks. tests  performed  sets  .fixed.
vectors  . bit item identifiers . ,  . .
containing respectively ., .  . non-zero items.
 vectors  drawn randomly,  represented  streams.
containingn updates, one   non-zero entry.  adopt.
 standard random number generator    seeded,.
invoked whenever random values  needed.
 measure  accuracy   samplers based .
 close  sample distribution   uniform, based .
multiple repetitions   sampling process . different.
random choices   hash functions. note  .
will   variation   distribution simply due  .
bounded number  repetitions.  example,  analyze .
distribution  samples drawn   vector containing .
non-zero items,  need  number  samples    least.
 size    expectation  seeing  item . .
 experiments,  used . . . independent repetitions .
 . samplers  test  setting.   enough  see.
 overall trend  accuracy.  understand  well .
different samplers  ,  also compare   .ideal.
sampler,  samples items via  strong random number.
generator based   true .-distribution.  call .
process .balls-in-bins. .bib.
platform. running times  measured   . ghz intel.
core .  .   main memory, running debian .,.
linux kernel ., . bit.
. accuracy  .-sampler  results described  section . show   .-sampler  achieve high success.
probability  small error   .-distribution, without.
requiring full randomness  .  many   motivating scenarios  section .,  goal   obtain  output.
distribution    close  uniform  possible.
 enough repetitions,  expect   set  samples  contains approximately   number  occurrences   item  ,   item    drawn.
 . less. often, still  number .   occurrences  close   expected number according   .distribution.  measure  maximum relative error  .
obtained distribution  follows. letting . . . ,  define.
maxi.
.
.    accuracy   .-sampler.  plot.
 evolution   statistic   increases,   .
converge   desired distribution.
 theory predicts  choosing  proportional .
. least. log .  needed  order  achieve .-relative.
error. however,  constants  proportionality  .
emerge clearly   analysis. moreover,  hope .
 practice  moderate .constant.  will suffice, since .
cost  evaluating  hash functions scales linearly .
,  determines  main overhead   process.
hence  study  accuracy   .-sampler   varies.
.thus effectively capturing  algorithms described  .
 .   end,   test vector,  compare.
 accuracy   .-sampler,   number  samples.
increases   corresponding accuracy   uniform.
balls-in-bins process.  also compare   variant .sampler proposed  frahling, indyk  sohler . .fis.
 discussed  section .   use . repetitions.
  implemented using   codebase   .
samplers,  called  different parameter settings.
sparse vectors.  figure .  report  outcome  .
experiment  . non-zero items,  different settings.
.however,   applications,   graph sketching .   .
important  draw  item   support set supp .  exact.
distribution   matter.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
.
.
. . . . . . . . . .
.
.
.
.
.
accuracy . . .
fast selection slow selectionn known  levels.
. accuracy   increases.
.
.
.
.
.
.
.
.
. . . . . . . . . .
.
.
.
.
repetitions.
accuracy . . .
fis.
. accuracy  fis.
.
.
.
.
.
.
.
.
. . . . . . . . . . . . . . .
.
.
.
.
drawings.
accuracy . . .
.
.
. . . . . . . . .
bib.
fis.
 . .
 . .
 . .
 . .
. accuracy  number  repetitions increases.
figure . accuracy  .-sampler   . .
 figure .  show   accuracy  changes.
 different values     k-wise independent hash.
functions   versions   level selection step .
  known exactly,    try recovery   levels.
 successful. figure . shows  accuracy   fis.
variant  increasing number  repetitions. figure .
shows   accuracy changes   number  drawings.
increases.  particular,  figure . .
according   experiment,  get better accuracy.
  increases,   fis variant achieves good accuracy.
  small number  repetitions. finally,  shown .
 zoomed pane   figure .,  experiment suggests.
 rather small values  ,  instance .,  sufficient .
average  achieve comparable accuracy   fully random.
sampling process .bib.,  balls  bins process.
dense vectors.  figure .  report  outcome  .
 experiment  figure ., executed  denser vectors,.
containing respectively .  . non-zero items. ,.
 predicted   analysis,  accuracy increases  .
increase  value  .    hand, setting  . .
 enough  observe   error  close  . .
sampling   set  . non-zero items,  slightly.
bigger  .   denser vector.   data,  fis.
variant also performs well, although    slowest  .
methods compared   plot, due   number  parallel.
repetitions.
  larger vectors . . .,  overall accuracy.
performance seems poorer.  relative error  around.
. however,   mostly  function   number .
repetitions  insufficient  induce  true sampling.
distribution.  see   accuracy obtained  .
ideal .bib. process  quite similar   best   .samplers,   conclude   variation  dominated .
 random variation   number  selected items.
. success probability  .-sampler  main result .
section . shows   single parameter   control.
  error   output distribution   failure probability. according   experiments discussed   previous section, high accuracy   achieved  rather small.
values   independence parameter . however,  .
goal   draw  item  supp ,   important  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
.
.
.
.
. . . . . . . . . . . . . . .
.
.
.
.
drawings.
accuracy . . .
bib.
fis.
 . .
 . .
 . .
 . .
.
.
.
.
.
.
.
.
.
.
. . . . . . . . . . . . . . .
.
.
.
.
drawings.
accuracy . . .
bib.
fis.
 . .
 . .
 . .
 . .
figure . accuracy   number  drawings increases,     .
.
.
.
.
.
.
. . . . . . . . . .
.
ilu.
.
.
.
.
.
.
.
failure.
exp. .
exp.
.
.
 . .
 . .
 . .
figure . failures   increases,  . drawings.
number  failures   .-sampler  small.  recall .
  sampling process maps either .     nonzero items   level  chosen   selection step, .
 .-sampler fails  probability .  second source.
 error    s-sparse recovery algorithm  unable  recover  vector,    made smaller  adjusting.
 space allocated   algorithm.   end,  .
test vector,  compare  percentage  failed drawings .
 .ideal. s-sparse recovery experimental setup,   .
 done using  s-sparse recovery mechanism described .
section .
failure due  sampling step.  figure .  show .
 percentage  failures  . drawings, changes .
different values  .  also plot guidelines proportional.
 exponentially decaying probabilities,  compare  .
analytical bound   error .  exponential,  .
weaker constants.  observe   error  decay.
quickly    increased. moreover,  observed  .
suffices  use small values  ,  instance  . .,  ensure.
  failure rate holds steady, independent   number.
.
.
.
.
.
.
. . . . . . . . . .
.
ilu.
.
.
.
.
.
.
repetitions.
failure . . .
fis.
figure . failures  fis,  . drawings.
 repetitions made.
figure . shows  accuracy changes   fis variant   number  repetitions increases.   vector.
containing . non-zero items,  error   fis variant.
becomes rapidly smaller  .,   increase accordingly  number  repetitions.   dense vectors, .
fis variant  . repetitions rarely fails  draw  sample,.
displaying approximately   behavior    . .,.
. failure rate   .   . .,  around .
  . .
failure due  recovery step. figure . also shows .
 dashed line   outcome   experiment changes.
  s-sparse recovery mechanism  used.  observe.
  percentage  failures increases  little due  ,.
   gap decreases   increase .  theory.
predicts    sketch  size . . log .,  failure.
probability   s-sparse recovery algorithm  smaller .
.   experiments,  found   fact using .
constant number  rows . . sufficed    good.
probability  recovery. since  cost  updating .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
.
.
.
.
.
. . . . . . . . . .
.
.
.
working memory.
. levels.
. levels.
. levels.
 . .  . .  . .
figure . working memory   increases.
sketch scales linearly   number  rows, using .
small constant allows  execution   update operation.
 constant time.
. efficiency  .-sampler   following  analyze.
 space requirements  running time   .-sampler.
space usage.  evaluate  space required   .sampler   function  ,   test vector. figure .
plots  space used  kib .kib. . bytes.,  run .
single instance   .-sampler.  used  .-bit integers.
 represent  . , . .-bit integers  .,.,. . .
 . .-bit integers plus . .-bit integers  implement.
 instance  .  size   single level scales.
linearly   independently   input stream, .
  fis variant    . repetitions  implemented.
 . .-bit integers  represent  . .   single.
instance  . per level.  space required   .
 samplers depends   number  .non-empty. levels,.
 varies proportional  logn ,  ultimate number .
distinct elements.   know  advance good bounds .
 final . norm,  suggests   maintain  smaller.
number  levels.
running time. finally,  analyzed  impact    .
performance   sampling  recovery steps.  measure  total time  process  whole input stream, given.
  average  . repetitions.  might  expected,.
 time  dominated   sampling step. figure . shows.
  time required   .-sampler  barely affected .
 s-sparse recovery algorithm.  time required  .
fis variant  constant,   determined   number .
repetitions used  draw  sample.  . repetitions,.
 time cost  approximately equivalent     . .
 figure .
 main effort using k-wise independence   .
evaluation   selected hash function  . .  overall.
processing time grows linearly   .  proportional.
.
.
.
.
. . . . . . . . . .
.
.
.
processing time.
sampling .
sampling . recovery.
 . .  . .  . .
figure . processing time   increases.
 . increases, proving  usefulness   implementation.
based   limited independence  . figure ., together.
  analysis  accuracy  failure, suggests  .
  tradeoff   reliability   .-sampler  .
efficiency.  time  important, using  . .   . .
ensures fast computation.    hand,  selecting.
bigger values     ,  process becomes slower.
  fis variant,  achieving similar failure rates .
accuracy   data. hence   regime,  usage .
 fis variant  result  better performance.
. concluding remarks.
 problem  drawing  sample   .-distribution.
 multiple applications  stream processing, computational geometry  graph processing.   shown .
existing algorithms fit   framework  sampling, recovery  selection.  experimental study shows  .
framework   instantiated effectively. based  lowindependence hash functions,   able  draw samples.
close  uniform,  process millions  items per second.
 space overhead  moderate, indicating   algorithms  practical   small number  samples .
needed   large amount  data. however,   natural .
ask whether  samplers   made  space efficient,.
either   engineering  subroutines  parameters,.
   fundamentally new approach  .-sampling.
acknowledgments.  work  donatella firmani .
supported   visitor grant  dimacs, funded .
nsf.ccf award number .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
</doc>
<doc title='15_ALENEX_22.txt'>
downloaded  knowledgecenter.siam.org.
practical batch-updatable external hashing  sorting.
hyeontaek lim. david . andersen. michael kaminsky.
abstract.
 paper presents  practical external hashing scheme .
supports fast lookup . microseconds.  large datasets .millions  billions  items.   small memory footprint.
. bits.item.  fast index construction .  items.
 .-kib key-value pairs.  scheme combines three key.
techniques. .  new index data structure .entropy-coded.
tries. .  use  sorting   main data manipulation.
method.  . support  incremental index construction.
 dynamic datasets.  evaluate  scheme  building.
 external dictionary  flash-based drives  demonstrate.
 scheme. high performance, compactness,  practicality.
. introduction.
  amount  data stored  large-scale storage systems.
continues  grow,    importance  algorithms .
data structures  provide resource-efficient access  .
data.   paper,  address  question  external.
hashing. using  small amount  ram  efficiently locate.
data stored   .large. external disk  flash drive. .
solution, entropy-coded tries, provides three properties .
 important  practice.   memory  disk efficient. .
provides fast access. ,  using sorting   fundamental.
organizing method,  easy  engineer  high performance.
 reliability.
traditional external hashing schemes put emphasis .
 construction  evaluation speed   hash function.
  asymptotic size   generated hash function ., .,.
. however,  modern data-intensive systems, external.
hashing faces three challenges driven  technology .
application trends.
. flash drives. flash provides fast random access.
speed.typically .,.  .,.,. . per second.
.iops. ., ., compared     hundred iops.
 hard drives. flash also  fast sequential ., often.
exceeding . . prior studies  external hashing.
 considered  use  slow hard disks.  systems, therefore,   designed  take full advantage  high flash performance.
.carnegie mellon university, , usa. .cmu.edu.
.carnegie mellon university, , usa. dga.cmu.edu.
.intel labs, , usa. michael.kaminsky.intel.com.
. growing cost  memory. dram  become increasingly expensive  power-hungry relative   disk.
 flash storage.   result,  need  memoryefficient external hashing  grown.  .
asymptotic space use,  also  actual space use .
storing millions  billions  keys.
. mission-critical storage systems. services ranging.
 google  facebook  end-user software .
 web browsers use external hashing  build  highly.
memory-efficient external dictionary,  stores .
large number  key-value pairs  disk  flash .
provides fast retrieval   data items. ensuring .
correctness  high performance   dictionary .
 critical  difficult. using  well-studied software.
component.sorting.  main building block  external hashing  help achieve  goals.
 contributions   paper  three-fold.
. entropy-coded tries .ect. ect   minimal perfect hashing .mph. scheme  uses  array  highlycompressed tries   sorted dataset  external storage. given  distinct input keys,  assign unique.
values   range .,. .   input keys, whose.
order . index.  determined   hash values .
 keys.  represent  mapping   keys .
 indices  tries,     compressed using.
 new trie compression technique. combination .
huffman coding  elias-gamma coding  exploits.
 underlying statistical properties  tries created .
hashed keys. ect requires  . bits per key  average   in-memory index .close  minimal perfect.
hashing. information-theoretic lower bound  approximately . bits per key .  . microseconds .
lookup  key.  cpu requirement   reduced.
  fast ssds  trading  space efficiency.
. sort   basic building block  efficient external hashing.  demonstrate   use  .
well-engineered sort implementation  provide highperformance indexing  ect  even speed  .
external hashing schemes    originally based.
 sorting.  particular,  develop  modified version  eph .  uses sorting instead  partitioning,  show substantial performance improvements.
  original partition-based scheme. ect, .
. copyright . siam.
unauthorized reproduction   article  prohibited.
natively uses sorting,  turn outperforms  partitioning  sorting versions  eph.  addition, sort.
provides two engineering benefits. .  system design becomes easy  understand  implement. .
.  system  drop  index  fall back  binary search whenever desired. ,  simple assessment   system. correctness  possible  using.
 sort implementation    widely adopted .
data processing systems.
. incremental updates  dynamic datasets.  workloads dealing  dynamic datasets,   crucial  incorporate  series  updates   existing dataset.
quickly.  show  benefits  supporting incremental updates  ect  well    version .
eph.  handle batched updates,    perform.
 entire index construction   pre-existent data.
 partition.sort new changes ,   sequentially merge  new changes   previously indexed items  generating new in-memory structures.
  merge.  incremental process incurs less.
.   full construction   dataset,  reduces update time.
. design.
 section presents  design  entropy-coded tries.
.ect.  first presents  high-level overview  ect .
 describes major components   ect scheme .
detail.
. overview ect supports . retrieval  data items.
stored  external storage using approximately . bits .
dram per key  average.     keeping  data.
sorted  hash order . order   keys  applying .
hash function  ., grouping adjacent keys  virtual.
buckets .   contains keys  share  .
hash prefix   certain length.,  creating  efficient.
trie-based index   virtual bucket  quickly locate.
 index   particular pre-hashed key within  virtual.
bucket.
figure . depicts  ect construction process. .
box represents  item,   height   gray bar.
indicates  relative order   item. hashed key. .
scheme sorts  dataset  flash  builds  trie  .
disjoint group  adjacent keys .virtual bucket.  memory.
 construction,   data manipulation  sort, .
virtual bucketing  trie construction   move data .
flash.
figure . shows  data structures generated  .
ect scheme.  two-level index stores internal indexing.
information.  in-memory location   compressed trie.
representation   on-flash location   first item .
 virtual bucket.  internal index   additional.
benefit    allows dense storage   ect data.
structures. . compressed tries, one    generated.
  virtual bucket,  stored contiguously  memory .
achieve  small memory footprint.  . sorted hashkeys.
. associated values.  kept  flash without wasting.
storage space.
  following subsections,  detail  algorithms.
 data structures used  ect.
. sorting  hash order ect uses external sort .
 sole data manipulation mechanism. unlike many .
indexing schemes, ect   require  specific procedure.
 construct  structured data layout ., b-tree.   custom.
data layout ., eph . ect directly applies external.
sort   input dataset  obtain  final data layout .
 ect constructs  index.  sort   well-established.
building block  many algorithms  systems, ect .
take advantage  readily-available sort implementations .
achieve high performance  reliability ., . .
sort implementations  carefully tuned   wide range .
systems ., low .  computational demands., .
greatly reduces  engineering effort needed  deliver high.
performance  ect.
 unique feature  ect  respect  sort  .
   use  original key   sort key. instead,.
 hashes  key  uses  hashed result   sort.
key.  choice   hashing function  flexible .
long   provides  reasonably uniform distribution .
hash values   low  zero probability  collisions.
ideally, universal hashing . yields  best result  .
subsequent steps,  using  conventional cryptographic.
hash function ., sha-. also produces acceptable results.
  workloads   experiments.
 will refer   hash value   original key  .
hashkey  simply   key. using hashed keys enables two.
important design aspects  ect,   explain .
. virtual bucketing  sorting  hashkeys,. ect.
groups sets  adjacent keys  virtual buckets, partitioned.
    significant bits .msbs.,  illustrated .
figure .  shown  figure .,  process  looking .
 key involves first examining  msbs  determine .
virtual bucket  falls . ect consults  two-level index .
find,   virtual bucket,  location   compressed.
trie index  memory,   starting location  flash .
keys   bucket  stored.
 virtual bucketing process   move data .
storage.  merely represents  grouping   trie indexing.
 virtual bucket. trie  compressed  decompressed.
independently. compressing  reading  trie takes time.
roughly linear   size   trie,  larger tries compress.
.  implementation,  step occurs  sort  emitting  sorted.
keys.  process need   complete  virtual bucketing  begin, .
eliminates  need  re-reading sorted hashkeys  flash.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
input items.
sorting  virtual bucketing.
ects.
 memory.
trie construction   virtual bucket.
items sorted.
 hash.
 flash.
figure . workflow   construction  ect.
items  flash.
two-level index  memory.
compressed tries  memory.
upper.
lower.
figure . constructed ect data structures  memory.
  flash.
 efficiently  small tries.   result,  virtual.
bucket size ,  determines  many bits  .
 used  bucketing, provides  way  trade space savings.
 lookup time.  show  appendix    size .
 largest bucket,  relates   maximum amount .
computation required   lookup,  proportional  .
average size   buckets.
virtual bucketing adds marginal memory overhead .
index  buckets. since   in-memory  on-flash.
locations   buckets  monotonically increasing, ect.
 efficiently encode  offsets  using  two-level.
index. ect records  absolute offset  every . bucket.
.  bucket contains . keys  average. .,  .
.,  . log. .,    group  . buckets, .
maintains  offset  individual buckets relative   first.
bucket    bucket group.  upper level offsets.
use wide integers .-bit integers   implementation.,.
  lower level offsets use smaller .-bit integers .
save memory.    narrow data type   lower.
level, larger buckets .,   . keys per bucket .
average.  require  upper level offsets ., every.
. bucket   frequent.  avoid  overflow  .
lower level.   average bucket size  . keys, .
two-level index  in-memory  on-flash locations adds.
insignificant space overhead  approximately . bits per.
key   practical number . .  keys.
. compressed tries hashkeys   bucket  indexed   binary trie. similar  conventional tries, .
trie represents  key   path   root node  .
leaf node corresponding   key,   edge represents one bit   key.   result,  trie   one-to-one.
correspondence   leaf nodes  hashkeys.  i-th.
leaf node among  leaf nodes   trie corresponds  .
i-th smallest hashkey.  key lookup   trie  essentially.
finding  leaf node corresponding   key  counting .
 leaf nodes   left   leaf node.
however, unlike   tries used  text search, ect.
uses unique prefixes   hashkeys  remove unused.
information.   leaf node     sibling node,.
 leaf node  always removed   trie,   parent.
node becomes  new leaf node.  process significantly.
decreases  number  nodes   trie  preserving.
 relationship  leaf nodes  hashkeys. ,.
 internal node  becomes  new leaf node   ancestor.
 exactly one leaf node   original trie  full-length.
hashkeys. accordingly, ect  obtain  correct index.
  lookup key  using  prefix   key  traversing.
 trie. ect  stop descending  soon   arrives  .
leaf node.
ect reduces  amount  memory used  store .
trie  applying compression.  compressed trie  represented recursively  follows.
rep. . .
.
., . .  . . .  .,.
.left. ., . . rep.left. . rep.right. .
otherwise,.
.
. . . number  keys indexed  .
., leaf nodes   .,.
left. . . left subtrie   ,.
right. . . right subtrie   ,.
.,. . entropy code  symbol   context  .
 representation   pre-order traversal structure.
similar   recursive encoding  binary trees ., .
 differs   previous technique   way  describes  left subtrie.  measuring  size   trie,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 use  number  keys ., leaf nodes., excluding internal nodes,   left subtrie,   enables  efficient entropy coding. since  trie uses hashkeys,  keys  uniformly distributed   entire key space.   words,.
 bit  every key    probability   . .
. .left. . therefore follows  binomial distribution .
 . . .   . . based   known statistical distribution,   encode  key counts using entropy coding.
entropy coding uses  contextual information  . . . .
find  suitable code  .left. .   distribution .
.left. . depends  . . note    trivial tries .
. . . .,  entropy codes  simply  empty string,  .
trivial tries   one form .,  child nodes.
 decompressing  trie representation  .
lookup,   initially set   total number  keys  .
trie. .left. .   decoded   head   representation,  .right. .   calculated  .left. .,.
since .left. . .right. . . . . .  .left. . .
.right. .  restored, ect recurses   subtries .
setting    subtrie size  using  rest   trie.
representation.
 order  use  cpu cache efficienctly,  use huffman coding   small tries.  huffman coding  applied  large tries,  huffman tree  table size required .
compressing  decompressing counts grows superlinearly,.
  burdens  cpu cache space. thus,  avoid using.
huffman coding   trie whose size  larger   certain.
threshold.  term  threshold hmax.   trie contains    hmax leaf nodes .,  . hmax.,  use.
static huffman tables based   binomial distributions. .
larger tries,  apply elias-gamma coding .  combination   two entropy coding techniques reduces cache.
misses  ensuring huffman tables  comfortably fit  .
cpu cache.  investigate  effect   combination .
section .
 shrink  trie representation size ,  use .
 code  two special cases   trie size. .left. .
.  .left. . . .  ,   trie   keys  either.
left side  right side, ect treats     .
   affect  lookup result .recall   .
provide  correct index   key    indexed,.
  every possible key.  optimization reduces .
compressed trie size  . bits.key.
     focus   asymptotic space consumption   compressed trie representations  .
number  keys   trie  practically small ., around .
keys., even  ect indexes  large number  keys .,.
billions  keys. across many virtual buckets. therefore, .
focus   expected space consumption  tries  .
range. figure . plots  expected number  bits required.
 store  trie   function   number  keys stored  .
  analysis, hmax  fixed  .,   result  .
include  space  store  total number  keys   trie.
. . . . . . . . . . . .
number  keys   trie.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ect.
entropy.
figure . expected size   compressed representation .
 single trie containing  varying number  keys.
., . .   top-level.   number  keys increases,.
 representation size approaches . bits.key. compared .
 underlying entropy   trie,  combination  huffman  elias-gamma coding used  ect achieves good.
coding efficiency.
. incremental updates  employing sort   data.
manipulation method, ect  perform incremental updates.
efficiently, reusing  previously built sorted dataset .
flash. figure . illustrates  workflow  incremental.
updates.  new items .  entire dataset.  sorted.
   sequentially merged   existing sorted.
items.   sequential merge   reorder data.
globally,  better uses  buffer memory  sort  thus.
reduces  total amount  .  savings become.
significant   size   existing dataset grows larger.
  size   new dataset,  demonstrated  .
evaluation .section .
. sparse indexing   optimization  small items,.
ect  generate  compact indexes  applying .
idea  sparse indexes. addressing items   disk block.
level, rather   byte level. since disk  flash.
drives  block-access oriented devices,    certain.
minimum . size .,  block  . bytes. defined .
 interface. overheads  . operation processing .
 physical movement  mechanical parts ., disk heads.
 increase  efficient minimum . size. therefore,.
byte addresses returned   index save  . compared .
block addresses.  locating items   block level,  sparse.
index  yield   performance  making  .
compact  byte-level dense indexes.
ect realizes sparse indexing  pruning  subtrie .
belongs    block.  generating  representation   subtrie, ect keeps track   start  end locations   items indexed   subtrie.   subtrie con. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
existing sorted items.
 flash.
new input.
items.
intermediate.
sorted items.
sorting.
sequential merging  virtual bucketing.
items sorted.
 flash.
new ects.
 memory.
trie construction   virtual bucket.
figure . incremental updates  new items   existing.
dataset  ect.
input.
items.
items.
partitioned.
 hash.
partitioning.
searching   partition.
mphs.
 memory.
permuted.
items  disk.
figure . comparison   workflow   index.
construction  external perfect hashing .eph. .
within  bucket, items   ordered  global.
hash order,  permuted   local phf  mphf.
specific   bucket.
tains items    block .,  start  end locations.
share   block., ect simply omits  generation.
  subtrie representation.  handling  lookup, ect.
repeats   process  location tracking.   finds.
 subtrie whose items fit   single block, ect stops decoding subtries  reads  block   device    .
search  queried item within  block.
figure . shows expected compressed trie sizes  using.
sparse indexing.  trie contains . keys,  hmax  .
 .   items per block,  trie requires fewer  .
bit per key  expectation.
 sparse indexing  ect  stricter  k-perfect.
hashing .,  allows    hash collisions. ect.
generates  index  exactly  hash collisions . .
exception   last block  may contain fewer  .
items.,   leads   efficient use  storage space.
,   sparse indexing uses   data layout.
 flash, ect  generate  new dense  sparse index.
 already indexed items without repeating construction.
process, allowing   adapt  memory  performance.
requirements quickly.
. comparison   schemes.
  section,  discuss similarities  differences  ect   fast external hashing schemes, sum. . . . . . . . . . .
number  items   block.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure . expected size   compressed representation .
 single trie containing . items   varying number .
items   block.
marized  table .
. external perfect hashing external perfect hashing.
.eph. .   scalable external hashing scheme  requires.
. . operations  item retrieval  uses  small.
amount  memory   index.  shown  figure .,.
eph first partitions items  buckets using  hash values.
  keys.   bucket, eph constructs  perfect hash.
. cpu requirement  mmph    original mmph paper .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
function .phf.   minimal perfect hash function .mphf.,.
depending   memory  storage space requirement.
since phfs  mphfs result   specific offset  .
key,  keys   buckets  permuted .reordered. .
 phf.mphf order  stored  disk. eph achieves.
. bits.key  memory use,   . higher  .
bits.key used  ect.
 external memory . algorithm .,   .
eph variant  shares   partitioning approach, still.
requires . bits.key  mph  index  large number .
keys    fit  memory.
unlike eph, ect sorts  items  hash order, eliminating  additional permutation step.   show  section ., eph  benefit   modified  use external.
sort,   permutation step adds overhead  indicated .
 experimental results .section .
 performing incremental updates, eph requires.
additional steps  resolve item movement within   buckets.    stable ordering within  bucket.
across incremental updates  eph   order  .
key  determined   mphf specific   bucket, .
 involves re-permutation   items within  bucket.
whenever  key  added   removed   bucket.
worse,   size   bucket exceeds  certain limit .
shrinks    small size, eph must split  merge .
buckets.   data manipulation must  done separately.
  partitioning step  eph, support  incremental.
updates  eph complicates  system design  implementation.
. monotone minimal perfect hashing monotone.
minimal perfect hashing .mmph. ., ., ., like ect, uses.
sorting   data manipulation method,  builds  index   sorted table.  ect uses hash order  sorting  trie construction, mmph uses original keys, .
thus, requires  variable amount  computation  memory space depending   key distribution  characteristics. among various low-level indexing methods  mmph,.
.hollow tries. provides  smallest hash function size.
bits.key. random keys .,    best workload.
 minimizing  index size.
although mmph shares several characteristics .
ect    use sort,  focus  evaluation .
comparisons  ect  eph   yield.
smaller index sizes  mmph.
. evaluation.
 section presents  performance evaluation   external dictionary using ect   index.   comparison,.
 modified  original eph implementation,  .
supported  hash function interface,  provide  full functionality   external dictionary.  modified version .
eph  operate using  custom partitioning  well  uscomponent specification.
cpu intel core . . .quad-core. . . ghz.
dram ddr. . gib.
ssd raid-. array  three intel ssd .
.  .mlc.
table . experimental system setup.
ing external sort similarly  ect,  sort results  compatible  partition results.  addition,  implemented.
optional incremental construction  ect  extended eph.
 support   incremental construction functionality,.
  original eph implementation  supported index construction  scratch.
throughout  evaluation,  explicitly indicate binary.
prefixes .powers  . using . ., mib, gib.  avoid.
confusion   prefixes .powers  . ., , .
. experiment setup table . shows  hardware configuration   experiments.  input, output,  temporary data  stored   raid-. array consisting  three.
sata ssds,    provides   . . sequential read  . . sequential write throughput.
 use  webspam-uk. url list .  input.
keys . average . bytes per url.  associated values.
 . bytes   key. due   large size  .
key-value pairs,  use   . million unique urls  .
beginning   url list.   use hashkeys, using  first.
part   url list   introduce skew   input data.
unless specified,  input   standard workload  .
section.
 addition,  examine  performance   large.
number  items,  use . billion small key-value pairs,.
 consist  .-byte keys  .-byte values.  key .
hashed  . bytes   beginning   index construction, constituting  .-byte key-value pair  flash .
  construction  support later key-value retrieval.
   use  sparse indexing technique .section .,  avoid using   ect  make  fair comparison  eph,      implementation .
 technique.  workload  denoted  small-item,.
  experiment result  shown  section .
 experiments  performed  ubuntu . .bit.,   used nsort .   external sort implementation.  configuration   experiments involving time.
measurements  three runs,   range   results .
indicated   error bar.
.note  using  .-byte value   key significantly increases.
 data size  construction cost compared  prior studies ., ., .
stored  key . value. data  external storage.  study stores  key.
 value data  flash  provide  dictionary interface .retrieval   value.
associated   key.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
external perfect hashing.
.mph version.
monotone minimal perfect hashing .mmph.
entropy-coded tries.
.ect.
data manipulation method partitioning  hash .
permutation  mphfs.
sorting  original key.
order.
sorting  hash order.
low-level index type mph various compressed trie.
. complexity  construction . . .
memory requirement   large set  keys . bits.key . . bits.key . bits.key.
cpu requirement   in-memory lookup . .lookup . .lookup . .lookup.
table . summary   comparison  ect   fast external hashing schemes.
. . . . . . . .
buffer size  partition.sort .mib.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ite.
.
.
.
.
ect sort . cores.
ect sort . core.
eph sort . cores.
eph sort . core.
eph part . cores.
eph part . core.
figure . construction performance.
 varying buffer size  partition.sort.
. . . .
.  items used  construction .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ite.
.
.
.
.
ect sort . cores.
ect sort . core.
eph sort . cores.
eph sort . core.
eph part . cores.
eph part . core.
figure . construction performance.
  varying number  items.
. . . . . .
.  batch updates.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ite.
.
.
.
. ect sort incr . cores.
eph sort incr . cores.
ect sort . cores.
eph sort . cores.
figure . construction performance.
 different combinations  indexing  incremental construction.
schemes.  batch contains . .
new items.
. construction initial construction   external hashing involves  large amount  .  input data, temporary.
files,  output data. .   major bottleneck   overall construction process.  nsort  eph provide  settable parameter  controls  size  in-memory buffer.
space  use . efficiently  sorting  partitioning. thus,.
determining  appropriate buffer size  important.  excessively large buffer may decrease overall performance    page cache,  competes    main.
memory space,  also important  reading  input data.
 writing  final output.
figure . shows  construction performance  using different buffer sizes   partition  sort stage.
 experiment used . million key-value pairs, whose size.
. . . far exceeds  total memory size . gib. .
 ect  eph,  sort versions  use  . core.
.dotted lines. achieve  best performance using . mib.
 buffering,   partition-based eph .eph part. performs best   smaller buffer size  . mib .table .
 difference   nsort internally uses direct .
 bypasses   page cache,  thus  performance.
 less susceptible   reduced amount    page.
cache   in-memory sort buffer size  large. .
. cores .solid lines., ect works best  . mib buffer.
size.   result,   observe major performance.
boosts  using multiple cores due  nsort. internal optimization,    eph. custom partitioning, .
eph. custom data partitioning code uses . core  .
 directly benefit  multiple cores.  demonstrates.
 performance  engineering advantages  using  wellunderstood  well-optimized primitive   sorting .
 main data manipulation.
  subsequent experiments,  used  best buffer.
memory size   configuration. figure . plots .
construction performance  varying dataset size.  set.
 buffer size based   large dataset  .  items,.
 shows  smaller dataset sizes   insignificant.
effect   construction speed.
. index size despite  faster construction speed, ect.
generates  smaller index  eph.  index . million items   given dataset, ect used .  .
bits.key. eph required .  . bits.key. excluding.
 fixed-size lookup table  . mib,  .  including.
 lookup table . bits.key  total. ect. space consumption   least . lower  eph.   close .
 analytical result shown  figure .
. incremental updates  datasets    fully.
static, incremental updates improve  reconstruction speed.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
throughput . buffer size.
ect sort . cores .  items. . . mib.
ect sort . core .  items. . . mib.
eph sort . cores .  items. . . mib.
eph sort . core .  items. . . mib.
eph part . cores .  items. . . mib.
eph part . core .  items. . . mib.
table . best construction performance  .
scheme.
throughput total cpu time.
eph .  queries. . .
ect .  queries. . .
.difference. . .
table . random lookup performance  random.
queries using . threads.
  external hashing substantially. figure . plots performance boosts  incremental updates.  workload constructs  index using .  items. ,  adds another . .
items   batch  update  existing dataset.  repeats.
 update   . times   final dataset size reaches.
.  items.  clearly shown, using incremental updates.
outperforms versions  must rebuild  sorted.partitioned.
dataset  scratch rather  reusing  previously organized data.  performance gap increases   number.
 updates increases.  .  . updates. therefore, allowing incremental updates  important  improving.
 performance  storage systems  dynamic data.
. space . lookup speed tradeoff table . shows.
 full-system lookup performance difference  ect.
 eph, using .  random queries  .  items. .
lookup includes data item retrieval  flash, thus incurring.
.  experiment used . threads  take advantage  .
. parallelism  flash drives .   algorithms.
exhibit lookup speed exceeding .  queries., ect  .
slower  eph.  difference mostly comes  .
higher cost  ect. lookup process,  shown   total.
cpu time,  also includes  cpu overhead  .
processing   kernel. however,  difference  .
actual lookup speed  much smaller   difference.
  total cpu time, since  system. cpu  largely.
underutilized ., external lookup   .o-bound task.
therefore,   small extra end-to-end lookup cost, ect.
brings great savings   index size . smaller index size.
 eph.  amount  . performed    .
 schemes,   incur  single random . per lookup.
  bigger  faster array  flash drives  used,.
slow hash function evaluation may cause  underutilization.
  storage array. ect provides two knobs. virtual.
bucket size .   maximum trie size    apply.
. . . . . . . . .
bits per key.
.
.
.
.
.
.
.
.
.
.
.
tim.
.
.
.
.
.
.
.
.
figure .  tradeoff  size  in-memory lookup.
performance   single core  varying average bucket.
size .  hmax . .
. . . . . . . . .
bits per key.
.
.
.
.
.
.
.
.
.
.
.
tim.
.
.
.
hmax.
hmax.
hmax.
.
.
.
figure .  tradeoff  size  in-memory lookup.
performance   single core  varying maximum trie.
size  huffman coding .hmax.   . .
. . . . . . . .
buffer size  partition.sort .mib.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
ite.
.
.
.
. ect sort . cores.
ect sort . core.
eph sort . cores.
eph sort . core.
eph part . cores.
eph part . core.
figure . construction performance  varying buffer.
size  partition.sort .small-item.
throughput . buffer size.
ect sort . cores .  items. . . mib.
ect sort . core .  items. . . mib.
eph sort . cores .  items. . . mib.
eph sort . core .  items. . . mib.
eph part . cores .  items. . . mib.
eph part . core .  items. . . mib.
table . best construction performance   scheme.
.small-item.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
huffman coding .hmax. allow  system  obtain .
balance   in-memory data structure size  perlookup computation.  highlight  effect  adjusting.
knobs,  measure in-memory . . lookup performance.
using  single core .
figure . shows   setting  average virtual.
bucket size .  . keys, ect requires  little  . bits.
per item  cpu consumption   in-memory lookup .
. .  lookup speed allows  system  support   .
 queries per second per core without considering . costs.
  low memory use  ect,   system  . gib.
 dram  store  ect index,   index . billion.
items.    smaller number  keys   virtual.
bucket,  system  trade  memory efficiency  even.
higher lookup speed.
figure . shows diminishing returns  using  high.
value   maximum trie size  apply huffman coding.
.hmax.   moderate hmax value .  .,  system.
 achieve small index size  well  low lookup time.
. small items  small items  .-byte key-value.
pairs,  construction process   dependent  computation   large items.  shown  figure . .
table ., ect using . cores exceeds  eph scheme. performance  far. ect. simple construction process handles .  key-value items per second . minutes  total.,.
achieving . higher construction speed   best eph.
scheme.
ect demonstrated  memory efficiency  .
small items. ect required . less memory space .
eph. ect. index size  .  . bits.key., whereas.
eph required .  . bits.key.  excluding .
fixed-size lookup table  . mib,  .    lookup.
table . bits.key  total.
. conclusion.
entropy-coded tries .ect. provide  practical external.
hashing scheme  using  new trie-based indexing technique  hash-sorted items.  trie compression yields .
 compact hash function occupying . bits per key, .
fast lookup time .around . ., making ect suitable .
datasets stored  high-speed storage devices   flash.
drives. using sort   main data manipulation method.
substantially saves engineering effort,   enables ect.
 use .  multi-core cpus efficiently  index construction  incremental index updates.
acknowledgments.
 work  supported  national science foundation.
award ccf-., google, intel science  technology.
center  cloud computing,   parallel data lab.
member companies. hyeontaek lim  supported  .
facebook fellowship.   like  thank guy blelloch,.
danny sleator, michelle mazurek,  anonymous reviewers.
 alenex.   valuable feedback  fabiano .
botelho  providing  source code  eph.
</doc>
<doc title='1_ALENEX_03.txt'>
downloaded  knowledgecenter.siam.org.
efficient algorithms  dualizing large-scale hypergraphs.
keisuke murakami. takeaki uno.
abstract.
 hypergraph    set family defined  vertex set.
 .  dual     set  minimal subsets .
     .  . .    .  . .
computation   dual  equivalent  many problems,.
  minimal hitting set enumeration   subset family,.
minimal set cover enumeration,   enumeration .
hypergraph transversals.   paper,  introduce .
new set system induced   minimality condition .
 hitting sets,  enables   use efficient pruning.
methods.   propose  efficient algorithm .
checking  minimality,  enables   construct time.
efficient  polynomial space dualization algorithms. .
computational experiments show   algorithms .
quite fast even  large-scale input   existing.
algorithms   terminate  practical time.
. introduction.
 hypergraph    subset family defined   vertex.
set  ,  ,  element .called hyperedge.  .
   subset   .  subset     called .
vertex subset.  hitting set   subset    .
  .  . .   hyperedge  .  . .
hitting set  called minimal   includes  .
hitting set.  dual   hypergraph   set  .
minimal hitting sets.  dualization   hypergraph.
  construct  dual   given hypergraph. .
 . ., ., ., ., . ., ., ., ., ., ., ., ., ., .
  hitting set   minimal,  ., .   minimal.
hitting set. dual.  ., ., ., ., ., ., ., . .
 known   . dual.dual.   ,  . . .
satisfies  .  .
dualization   fundamental problem  computer.
science, especially  machine learning, data mining,.
 optimization, etc.   equivalent  . .
minimal hitting set enumeration   given subset.
family, . minimal set cover enumeration   given set.
family, . enumeration  minimal subsets   .
included     given set family, . generating.
cnf equivalent   given monotone dnf, etc. .
size  dual   exponential   input hypergraph,.
thus  polynomial time algorithm  dualization usually.
.aoyama gakuin university, japan.
.national institute  informatics, japan.
means  algorithm running  time polynomial  .
input size   output size. although fredman.
 khachiyan. developed  quasi-polynomial time.
algorithm  runs  .logn. time,  .
  input size plus output size,  existence  .
polynomial time algorithm  still open.
  importance  dualization   application areas,  lot  researches  aimed  algorithms.
 terminate  short time  real world data. reduction   search space  studied   way .
cope   problem ., ., ., ., ., . finding.
 minimal hitting set  easy. one removes vertices one.
 one unless    empty intersection  .
hyperedges. however, finding exactly  minimal hitting sets   easy.    check  great many.
vertex subsets.  past studies  succeeded  reducing  search space,   computational cost .
substantial, hence  current algorithms may take long.
time   size   dual  large. thus,  .
solve   input size  small,   output size.
 small. solving  dualization problem  short time.
   input   output sizes  large .
 open issue.
usually,  size  dual increases   average.
size  minimal hitting sets increases. thus, tractable.
real-world problems  minimal hitting sets  small.
sizes  average.  motivates   perform  hillclimbing search  find  minimal hitting sets, .
  use existing efficient pruning methods .
maximal element enumerations.   contrary,  .
consider  complements  hitting sets,  minimal.
hitting sets will  maximal sets.  enables   use .
existing pruning methods,  search space drastically.
increases.   one   difficulties   problem.
   hand,  incremental algorithms.
  proposed., .  add hyperedges one .
one  update  set  minimal hitting sets. .
algorithms  smaller search spaces,  may operate.
one solution many times.  existing algorithms .
based   breadth-first search  perform minimality.
check efficiently  using  smaller minimal hitting.
sets already found.  works,  consumes memory.
 algorithm  . uses  depth-first search, .
 minimality check takes long time  large scale.
problems.
. copyright . siam.
unauthorized reproduction   article  prohibited.
  paper,  propose  new approach  use.
 set system given   minimality condition  .
hitting sets.  propose  new concept called critical hyperedge.  sets system composed  vertex sets.
    vertex   critical hyperedge satisfies  monotone property,   minimal hitting.
set   maximal element   set system. hence, .
 use hill climbing search  existing efficient pruning methods.  critical hyperedge   computed.
 short time without using  minimal hitting sets already found, thus   reduce  time complexity .
 minimality check.  realizes  time efficient computation  small memory space. moreover,  developed several methods  adapting  sparsity  .
input,     skip unnecessary operations. .
drastically reduces  number  iterations, compared.
  existing algorithms.  computational experiments show  efficiency   methods   .
many problems  algorithms terminate  short time.
even   existing algorithms   terminate .
several hours.
  following,  proofs   results .
 computational experiments  omitted due  .
limited space.     appendix,   long.
version.
. preliminaries  preparations.
  hypergraph  . ., . . . , . defined  vertex.
set  , . denotes  number  hyperedges   , .
ism,  . denotes  sum   sizes  hyperedges.
  , respectively.  denotes  hypergraph composed.
 hyperedges ., . . . , .   .  ,  .  .
set  hyperedges    includes , ., . .
. . .  ,  . .  vertex subset   vertex ,.
 respectively denote  .   .   .  .
 . .
  vertex subset  .  , uncov. denotes .
set  hyperedges    intersect  .   .
hitting set     uncov. . .   vertex.
 . ,  hyperedge  .   said   critical   .
. . .  denote  set   critical hyperedges.
   crit., ., ., crit., . . . . .  ,  .  .
. suppose     hitting set.     critical.
hyperedge, every  .  includes  vertex   .
 , thus  .   also  hitting set. therefore, .
  following property.
property .  .    minimal hitting set iff.
uncov. . .,  crit., . . . holds    . .
 crit., . . .    . ,  say   satisfies  minimality condition.   consider  example  crit. suppose   . ., ., ., ., ., ., .,.
  hitting set   ., ., .   see .
crit., . . ., ., crit., . . ., crit., . . ., thus.
   minimal,    remove either .  .
 . . ., ., crit., . . ., ., crit., . .
., ., ., thus .   minimal hitting set.  algorithm updates crit  check  minimality condition.
quickly,  utilizing  following lemmas.
lemma .  vertex subset ,  .   . .
, crit.,  . . . crit., . . . particularly,.
crit.,  . . . crit., . holds.
lemma .   vertex subset   . . ,.
crit.,  . . . uncov. . .
 next two lemmas follow directly  .
.
lemma . ., .   vertex subset  satisfies .
minimality condition,    subsets also satisfy.
 minimality condition, .,  minimality condition.
satisfies  monotone property.
lemma . ., .   vertex subset    satisfy.
 minimality condition,    included  .
minimal hitting set.  particular,  minimal hitting.
set   maximal   set system composed  vertex.
subsets satisfying  minimality condition.
lemma .   vertex subset ,.
. .crit., . . .
. existing algorithms.
 section  devoted  explaining  framework.
  existing algorithms related   algorithms.
 algorithm,  algorithm,  mtminer.  algorithm proposed  dong  . iteratively computes.
dual.  dual.    . dual., either  . dual. holds,   .  . dual. holds.
 . .  . . note    . dual.  .
 dual.,  .   composed  exactly one vertex, since crit., . must  . however,  .
 . dual.,  . dual.   .  . . .
 .  . .,  .    .  may   dual.
bmr algorithm proposed  bailey, manoukian .
ramamohanarao.   improved version   algorithm.  algorithm re-orders  hyperedges .
reduces  vertex sets   ,  avoid generating.
unnecessary hitting sets.  algorithm  written .
follows.
algorithm  . . ., . . . , .
. . . .
.   . .  .
.  . .
.    . . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.   .  . .  insert   .
. else    .  .
.   . . . satisfies . .   . .  . .
 insert  .   .
. end .
. end .
. end .
 algorithm checks whether .   dual. .
  looking   hitting set  dual. included .
 . . thus,  need  perform  breadth-first search.
 needs basically .
. .dual. time   .
bottleneck computation   algorithm. kavvadias.
 stavropoulos. proposed  depth-first version .
 algorithm. according   hitting set generation.
rule,  hitting set    uniquely generated .
 hitting set  .  gives  depth-first search.
starting   hitting set  .  algorithm.
checks  minimality   .   checking whether.
 .  .    hitting set      . . .
check needs basically . time.  algorithm .
written  follows.
algorithm  ., .
.   .   output . return.
.   .  . .  call ., . .
. else    .  .
.    .  .
.   .  .    hitting set    .
. end .
. call . . , . .
. end .
 cost   minimality check increases .
.dual.,   algorithm,     .
  algorithm. thus,  algorithm will  faster.
  dual.  small, whereas  algorithm will.
 faster  .  small    small  average.
mtminer   kind  branch  bound algorithm.
 starts   emptyset,  chooses elements one .
one.   element ,  generates two recursive calls.
concerned   choice. add    current vertex.
subset,    add .   current vertex.
subset becomes  hitting set,  checks  minimality,.
 outputs   minimal.  speed   computation,.
 algorithm prunes branches   use   .
called galois condition.  galois condition   .
 .   .uncov. . .uncov.,    holds,.
.  never included   minimal hitting set, thus .
 terminate  recursive call  respect   . .
 galois condition  equivalent   minimality.
condition, since   equivalent  crit.,  . . . .
. galois condition  proposed  .,  crit .
proposed  ., .  term .minimality condition. first.
algorithm mtminer . . ., . . . , .
. . . . .  . .
.   . .
.    .  .
.  uncov. . .  output .
.    larger  maximum vertex   .
.   .  satisfies  galois condition .
insert   .
. end .
. end .
. end .
. new algorithms  minimality check.
lemmas .,.,. imply   set system composed.
 vertex subsets satisfying  minimality condition.
 anti-monotone. furthermore,  non-minimal hitting set   satisfy  condition   minimal hitting set satisfies  condition, hence  minimal hitting set   maximal element   set system.
 enables   use many efficient existing techniques.
 algorithms  maximal element enumeration. especially,    big advantage    use many.
pruning methods designed  maximal element enumeration.  minimal-to-maximal conversion search.
.mmcs  short. performs   depth-first search  .
set system  several pruning methods. mtminer also.
uses  minimality condition,  performs  breadthfirst search, thus   use  pruning methods.
  existing algorithms,  check  done .
looking  smaller minimal hitting sets already found,.
 scanning  hyperedges, thus took long time.  key.
  efficient search   minimality check algorithm.
 small computational cost.  propose  use.
crit  checking  minimality condition. based .
 lemmas .  .,   update crit  short.
time, thus  minimality check   done efficiently.
 algorithm keeps crit.  uncov  lists, .
represent crit., .  uncov.,   mark .
    mark        included .
crit.,  . . . .    included  uncov.,  .
. . . .    included  none  .  enables.
  find  list  includes   constant time.
 update   mark   also done  constant.
time,   insertion  deletion   list. .
 algorithm adds  vertex     generates .
recursive call,  updates crit.  uncov  crit.
 uncov . .,  removing   . . .
crit.    mark .  update operation takes.
.min., .uncov. . .crit., . time.
even though  operation  simple,   reduce .
appears  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
time complexity   iteration   algorithm .
. . . .  .
update crit uncov ., crit. crit., .,.
uncov. uncov.
.    . . .
.   . crit.   vertex  .  .
remove   crit.
.   . uncov .
uncov . uncov .  . crit. . crit. . .
. end .
. minimal-to-maximal conversion search.
 pruning  mmcs algorithm starts   .
.,  adds vertices   recursively unless  minimality condition  violated.  avoid duplication, .
use  list  vertices cand  represents  vertices.
   added   iteration.  vertices .
included  cand will   added, even   addition satisfies  minimality condition, .,  iteration.
given   cand enumerates  minimal hitting sets.
including   included   . cand  recursively.
generating calls.
suppose   iteration  given   cand,.
 without loss  generality cand . ., . . . , .
  first vertex .,  make  recursive call .
respect   . .,  cand . cand . ., .
enumerate  minimal hitting sets including  . .
  termination   recursive call,  generate.
 recursive call   . .  avoid finding  minimal.
hitting sets including .,  give cand . ., . .
 recursive call.   way,   vertex , .
generate  recursive call   .   cand .
., . . . , .  search strategy  common  many.
algorithms  enumerating members   monotone set.
system,  example clique enumeration .  means.
  correctness  already proved.
global variable. crit., uncov, .
basic mmcs ., cand.
.    . cand .
.  uncov . . . . .
output  .  . cand . cand . .
. else   .    satisfy minimality condition.
 cand . cand . .
. end .
.    . cand .
. call update crit uncov ., crit., uncov.
. call basic mmcs . . , cand . .
. recover crit.
. end .
next,   describe  pruning method coming .
 necessary condition    hitting set. suppose.
  iteration  given   cand,    .
 hyperedge  uncov.   see   minimal.
hitting set including    include  least one vertex.
  . thus,    generate recursive calls .
respect  vertices  cand .  ,     .
   vertices  cand .  .  condition holds.
   . uncov., thus  choose one minimizing.
. . cand.   pre-experiment,  time  .
choice  usually shorter   time saved  .
choice, thus   reduce  total computation time.
pruning method. suppose   .   .
satisfy  minimality condition.  lemma .,.
 observe  . .    satisfy  minimality.
condition   . .  means    never added.
  recursive call  respect  .  condition.
also holds   .    minimal hitting set, since .
superset   minimal hitting set satisfies  minimality.
condition.  call  vertex  satisfying one  .
conditions violating.  remove  violating vertices.
 cand  every iteration,   following way.
suppose   iteration  given   cand,.
  going  generate recursive calls  respect .
vertices ., . . . ,  . .cand. basically,  iteration.
makes recursive calls  respect  .  . . .
cand . ., .  . .  cand . ., ., .,.
 .  .   .   efficient computation.
 violating vertices,    recursive calls  .
reverse order,  .  . ,  first set cand.
 cand . ., . . . , .  check whether   .
violating vertex  ,  generate  recursive call .
 .      violating.   recursive call,.
 add   cand   process  .    .
violating vertex,    add   cand. , .
    .,   way,   generate .
recursive call  respect  ., cand  composed.
  non-violating vertices  ,  . .
global variable. crit. .initially .   .,.
uncov .initially ., cand .initially  .
algorithm mmcs .
.  uncov . .  output  . return.
. choose  hyperedge   uncov.
.  . cand .  . cand . cand . .
.    .  .
. call update crit uncov ., crit., uncov.
.  crit.,  . . . .    .  .
call mmcs. . . cand . cand . .
. recover  change  crit.  uncov done  .
. end .
theorem . algorithm mmcs enumerates  minimal hitting sets within . time   iteration.
 . memory.
note   time complexity  per iteration, thus.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 algorithm   output polynomial.
. reverse search algorithm  second algorithm  based   reverse search .  reduces.
 search space much ,    considered.
  irredundant version   algorithm.   .
. dual.,    set  vertex subsets  .
operated   algorithm.   denote  minimum.
    . crit., .  min crit., .,  .
minimum     . uncov.  min uncov.
min crit., . .resp., min uncov.  defined asm.
 crit., . .resp., uncov.  empty. using .
terms,  give  characterization  .
lemma .  . . belongs   iff min crit., . .
min uncov. holds    . .
  . ,  define max min crit.   minimum index       minimal hitting set  ,.
., max min crit. . maxv.min crit., . .
define  parent  .    .,     vertex.
 thatmin crit., . . max min crit. since .
  critical    one vertex, max min crit.
  parent  uniquely defined.  parent-child.
relation given   definition  acyclic, thus forms.
 tree spanning   vertex subsets    rooted.
  emptyset.  algorithm performs  depth-first.
search   tree starting   emptyset. .
kind  search strategy  called reverse search.
 search strategy  essentially equivalent .
 algorithm modified    skip  redundant.
iterations    add  vertex   current.
vertex subset.   straightforward implementation.
  algorithm,    iteratively compute .
intersection     current vertex subset  .
 meet      intersect  . .
uncov.    large,  takes long time. particularly,.
 uncov. . .,  may spend . time. .
contrary,  algorithm    maintain uncov.,.
  much lighter.
 depth-first search starts   emptyset.
  visits  vertex subset ,  finds  children.
  iteratively  generates  recursive call  .
child.   way,   perform  depth-first search.
  finding children   current vertex subset.
 way  find  children  shown   following.
lemma.
lemma .   .    . min uncov. .
vertex subset .   child   iff .  . ., . . .
.    . ,  . max min crit., . . .
holds   . . .
 algorithm  also use violating vertices .
pruning.  find  violating vertices  step . .
put marks  .   make recursive calls .
 non-violating vertices,  never add  violating.
vertices,   marked,   execution  .
recursive call.  marks put   iteration .
deleted   iteration ends.   implementation,.
 apply  pruning    vertices  , .
  computation time  pruning will never  .
bottleneck.
global variable. crit. .initially .   .,.
uncov .initially .
algorithm  .
.  uncov . .  output . return.
.  . min. . uncov.
.    . , put  mark    violating .similar  .
.    .  .
. call update crit uncov ., crit., uncov.
.  min. . crit. . .     .  .
call . . .
. recover  change  crit.  uncov done  .
. end  . delete marks put  step .
theorem . algorithm  enumerates  minimal.
hitting sets  . . time   iteration .
. space.
proof. since  parent-child relationship induces .
rooted tree spanning  vertex subsets  ,  algorithm certainly enumerates  vertex subsets  .
since  minimal hitting set  included  ,  minimal hitting sets  found   algorithm.  update.
 crit.  uncov  done  . . time, thus .
iteration   algorithm takes . time.  total,.
 algorithm takes . . . time.
 algorithm requires extra memory  storing.
crit.  uncov   memorizing  hyperedges.
removed  step . since crit.  uncov  pairwise.
disjoint,  total memory  crit  uncov  .
  hyperedge  removed   list,  will  .
removed    deeper levels   recursion,.
  monotonicity  crit. thus,  also needs .
memory.   memory   .   , .
takes . space.
theorem . algorithm  enumerates  minimal.
hitting sets  . . time   iteration .
. space.
. computational experiments.
  section,  practical efficiency   algorithms  evaluated   computational experiments.
 various instances.  algorithms ware implemented  , without  sophisticated library .
 binary tree. existing algorithms  implemented  .  using  vector class  stl.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
table . computation time  randomly generated instances.
probability . . . . .
begk . .    . .   bmr . . .  mtminer . . . .  . . .   . . . . .
mmcs . . . . .
crs . . . . cmmcs . . . . .vertices . . . . .
. . . . . .
. . . . . . .
.dual. . . . . .
. . . . . .
table . computation time  self-dual threshold.
graphs.
sdth . . . . .
begk . . . . .
 . . . . .
bmr . . . . .
mtminer      . . . . .
 . . . . .
mmcs . . . . .
.vertices . . . . .
. . . . . .
. . . . . . .
.dual. . . . . .
. . . . . .
table . computation time  self-dual.
fano-plane graphs.
sdfp . . . . .
begk . . .   . . .  bmr . . . . mtminer . . .   . . . .  . . . . .
mmcs . . . . .vertices . . . . .
. . . . . .
. . . . . . .
.dual. . . . . .
. . . . . .
 algorithm  fredman khachiyan algorithm.
.begk., .  given   authors   papers.
mtminer  given  franc.ois rioult,   available .
https.forge.greyc.projects.kdariane.wiki.mtminer.
 experiments  done   . ghz core.
.   linux operating system  .
 ram memory. note  none   implementations used multi-cores.  codes  .
instances  available   dualization repository.
.http.research.nii.dualization.html.
. problem instances  used almost  instances examined   existing studies  referred,.
 prepared several new instances.  first category.
consists  randomly generated instances.  hyperedge includes  vertex   probability . note .
 prepared one instance   parameter, thus .
results    average.  instances   second category  generated   dataset .connect-.
taken   uci machine learning repository .
connect-.   board game,   row   dataset.
corresponds   minimal winning.losing stage  .
first player,   minimal hitting set   set  winning stages   minimal way  disturb wining.losing.
plays   first player.  took  first  rows .
make problem instances  different sizes.
 third instances  generated   frequent.
itemset .pattern. mining problem.   new.
instances.  itemset   hyperedge   terminology.
  set family    support threshold ., .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
table . computation time  losing stage  connect-.
lose . . . . . . . .
begk . . . .     . . . .    bmr . . . . .   mtminer .        . . . . .    . . . . . . . .
mmcs . . . . . . . .
.vertices . . . . . . . .
. . . . . . . . .
. . . . . . . . . .
.dual. . . . . . . . .
. . . . . . . . .
itemset  called frequent    included   least.
. hyperedges,  infrequent otherwise.  frequent.
itemset included    frequent itemset  called.
 maximal frequent itemset,   infrequent itemset.
including   infrequent itemset  called aminimal.
infrequent itemset.  problem instances  generated.
 taking  complement   maximal itemsets .
 datasets .bms-webview-.  .accidents., taken.
  fimi repository .  minimal hitting sets.
correspond  minimal infrequent itemsets.
 fourth instances  used  previous studies.
., .
.matching graph .   graph   vertices . .
even.  . hyperedges forming  perfect matching,.
 , hyperedge   . . ., .  instance .
 hyperedges  . minimal hitting sets.
. dual matching graph .  dual.
. threshold graph .  hypergraph   vertices .  even.  hyperedge set ., . . . .  .  .
,   even.  instance   hyperedges .
  minimal hitting sets . . .
. self-dual threshold graph .sdth.  hyperedge set  sdth.  given  ., .
 .  . . .  . dual.
sdth.    number  minimal hitting sets.
  hyperedges, . . . . . .
. self-dual fano-plane graph .sdfp.   hyperedge set ., . . . .  . . . . . .
 . . dual.,     union  disjoint.
copies  ., ., ., ., ., ., ., ., ., ., ., ., ., ., .,.
., ., ., ., ., .
. results table .  . compare  computation.
times  seconds.   results  shown .
 appendix. .  .dual.   numbers.
 hyperedges  minimal hitting sets, respectively.
. .  .   average sizes  hyperedges .
minimal hitting sets, respectively. . means  .
computation time    .,. seconds, .
.fail. implies   computation   terminate.
normally    shortage  memory  .
errors.  algorithm   function  input .
hyperedges   complements,   case  .
hyperedges  large  average.  update time .
crit  uncov depends   size   complement.
 ., since crit.,  . . . crit., . . . .
crit., . . . thus,   average hyperedge.
size  close  . .,  computation time  short. .
computational time    written   rows .
.crs.  .cmmcs.
 observe  results  random instances,.
connect-., accidents,  bms.,    large sizes,.
  many solutions, .,  targets.  results.
   instances  shown  appendix  .
long version.  almost  cases,  algorithms .
 mmcs   best. especially,   problem.
size  large,  difference   computation time becomes larger. among  existing algorithms, mtminer.
 competitive  accidents,  faster   implementations  bms. according   results, mtminer seems   efficient  dense instances .
instances    size   solution  small. .
computation time    bmr depends  .dual.
 .,    ,   mmcs depends .
.  . .  particular,   mmcs  quite.
faster    algorithm  almost  instances.
 exceptions  matching graphs  dual matching graphs .see appendix.   extreme cases .
  small minimal hitting sets    easily found,    small hyperedges. begk  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
table . computation time   maximal frequent sets  .accidents.
accidents . . . . . . . .
begk . . . . . .   . . . . . . . bmr . . . . . . . .
mtminer . . . . . . . .
 fail fail fail fail fail fail fail fail.
 . . . . . . . .
mmcs . . . . . . . .
crs . . . . . . . .
cmmcs . . . . . . . .
.vertices . . . . . . . .
. . . . . . . . .
. . . . . . . . . .
.dual. . . . . . . . .
. . . . . . . . .
slowest   instances. algorithms  smaller complexity   always faster.  algorithm embodies.
 idea  unify  isomorphic vertices  one  reduce  number  iterations,   seems  .
   much efficient   experiments.   extra experiments,  isomorphic vertices exist  .
  iterations, thus  improvement brought .
 unifying    limited.
table . lists  average ratios  computation times.
relative   case without pruning.  value  .
average   instances   categories,  smaller.
values mean  improvement.   cases .
ratio  slightly larger  ., however basically .
pruning works well especially  .  reason .
 pruning    efficient  mmcs   mmcs.
already   pruning method, thus  improvement .
limited.
 evaluated  total memory usage   algorithm.      table .  .,  remainings   appendix.  memory usage  .
existing methods seems  mainly depend   number  minimal hitting sets,   input size.  .
 hand,  memory usage   algorithms  .
depends    input size.    big difference   breadth-first group   depth-first.
group.  difference inside  group  constant, .
mainly comes   memory used   standard.
template library.
. conclusion.
 proposed efficient algorithms  solving  dualization problem.  new depth-first search type algorithms  based  reverse search  branch .
bound   reduced search space.  also proposed.
 efficient minimality condition check method  exploits  new concept called .critical hyperedges. computational experiments showed   algorithms outperform  existing ones  almost  cases,  using.
less memory even  large-scale problems   .
millions  hyperedges. sometimes,  algorithms take.
long time   minimality check. shortening  time.
will  one   future tasks.  efficient pruning.
methods  also  interesting topic  future work.
acknowledgments. part   research .
supported   funding program  world-leading.
innovative .  science  technology, japan. .
thank khaled elbassioni  elias . stavropoulos, .
franc.ois rioult  giving  programs.
</doc>
<doc title='2_ALENEX_23.txt'>
downloaded  knowledgecenter.siam.org.
 min-edge cost flow framework  capacitated covering problems.
jessica chang. samir khuller.
abstract.
  work,  introduce  cov-mecf framework,.
 special case  minimum-edge cost flow   .
input graph  bipartite.  observe  several important covering . multi-covering. problems  captured   unifying model  introduce  new heuristic lpo   problem   framework.  essence.
 lpo harnesses   oracle  fractional solution .
deciding   greedily modify  partial solution.
 empirically establish   heuristic returns solutions   higher  quality    wolsey.
algorithm.  also apply  analogs  leskovec .
. . optimization  lpo  introduce  .
freezing optimization   algorithms.  observe.
  former optimization generally benefits lpo.
  wolsey. algorithm,    additional.
freezing step often corrects suboptimalities   reducing  number  subroutine calls.  tested.
 implementations  randomly generated testbeds,.
several instances   second dimacs implementation challenge   couple networks modeling realworld dynamics.
. introduction.
flow networks  played  pivotal role   design.
 algorithms,   impact spanning several areas .
computer science  operations research,  network.
design  computer vision  scheduling  routing.
.  particular, many important covering problems.
 special cases   fundamental minimum-edge cost.
flow problem .mecf. several    direct connections  applications outside  computer science.
 understanding glycoprotein formation .  identifying galaxies  quasars via spectroscopic data .,.
 effects  good algorithms  covering problems.
.dept.  computer science  engineering,.
university  washington, seattle  ., email.
jschang.washington.edu. research done  author.
 visiting  university  maryland, supported   nsf.
graduate research fellowship,  nsf advance grant .
nsf ccf-.
.dept.  computer science, university  maryland, college.
park  ., email. samir.umd.edu. research supported.
 nsf ccf-., nsf ccf-.   google research.
award.
 far-reaching.   work,  investigate  relationship  mecf  generalizations  wellstudied covering problems  well  batch scheduling.
models motivated  energy efficiency  data centers.
  process,  develop powerful heuristics  optimizations  empirically demonstrate  merits .
scheduling contexts   covering settings.
recall  minimum-edge cost flow problem.  .
 directed graph given   . .,.   specified.
source   sink .  arc    corresponding.
integral capacity .  price . given  target.
flow value .,  goal   find  flow function.
  realizing  least . units  flow    .
 minimum cost.  difficulty  mecf  .
 adheres   fixed cost model,   .
positive flow sent across arc  incurs  entire cost .
  arc.   words,  .   subset  arcs.
along  positive flow  sent,  total cost  .
flow .
.
. .
 study pertains   following framework .
mecf, henceforth denoted cov-mecf.  graph .
    . ., .   bipartite graph .,,., .
 arcs       arcs    . .
edges    oriented     .  addition, .
capacities .  unit   . .  arcs ., . also.
 costs .    .  .  prices    arcs.
 zero. see figure .  ease  notation,  will.
denote  capacities  edges     .   .
 capacities   .     .
several covering problems fit   framework,.
including  following canonical problem.  set.
cover,    ground set  . ., . . . , . .
elements   collection  . .  subsets ., . . . , .
 goal   find  minimum cardinality subset . . .
  . .  .  .log .-approximation.
exists  set cover ., ., .,  greedily selects.
 set  minimizes  cost  marginal benefit.
ratio   ground elements  covered. feige .
provides  matching lower bound. wolsey extended.
 .log .-approximation   larger class  covering.
problems    problems considered  belong.
.  connection  cov-mecf  .
natural generalization  set cover called capacitated.
set cover follows.
. copyright . siam.
unauthorized reproduction   article  prohibited.
.
.
.
.
., .
., . ., .
.  cov-mecf framework.
.
.
.
.
., .
.
.
.
.
., .
., .
.
. capacitated set cover.
figure .  edge  labeled   capacity, followed.
  fixed cost.
capacitated set cover.  capacitated set cover.
.capsc.,  set    capacity .  .
goal   find  smallest collection  sets, .
 additional requirement  set  covers  .
. elements.  problem   cast  .
cov-mecf framework  creating  following graph.
. .depicted  figure .    .element.
node.   every ground element  .  ,  well  .
.set node.   every set  . .  addition, .
  source    edge ., .  every ,  unit.
capacity  zero cost. create  sink ,  insert edge.
. , .  every  ,  capacity .  unit cost.
finally,    edge ., .     element.
   covered  set    original instance.
identifying  capacity-respecting set cover  minimum.
size amounts  finding  .  minimum edge-cost flow.
 value equal  .
  problem generalizes set cover,  lowerbounds   approximation guarantee apply. wolsey.
greedy algorithm   .log .-approximation .
 highlight  unlike  uncapacitated counterpart,.
computing  marginal benefit  adding  set   partial cover requires  flow computation.
despite  dire state  affairs   theoretical.
level,   real world,  remains  undeniable.
need  solve problems   set cover flavor. one.
.wolsey proved,  fact,    .log.maxj .approximation.
commonly implemented algorithm      fact.
wolsey. greedy algorithm. despite  tight .log .
guarantee, studies indicate   practice,  fares.
much better.  instance,   widely-cited result,.
kempe . . . examine  influence function.
 social networks, demonstrating    .
 exhibit submodularity, wolsey. greedy algorithm.
 fact returns solutions   much closer  .
optimal solution   worst-case bound  imply.
 approach  since  applied   plethora .
problems within  social networks literature, ranging.
 outbreak detection  networks .   spread.
 information via  blogosphere .
 primary disadvantage  wolsey. algorithm .
  iteration may involve computing  marginal.
benefit  many candidate sets, requiring  high number  subroutine flow calls.  large instances,  .
render wolsey. algorithm unacceptably slow, limiting.
 size   input      run.  issue.
   subject  considerable investigation within.
 last decade. leskovec . . . show   sets.
 considered   particular order, irrelevant computations   avoided, thereby reducing  total number.
 flow calls.  algorithm celf maintains  spirit.
 wolsey. greedy algorithm   recently improved.
 celf.  goyel . . .  concern  also.
 focus   study.
interest  variations   set cover problem extends   sloan digital sky survey project,  effort.
toward surveying  history  astronomy. lupton .
. . studied  special geometric case  capacitated.
set cover   context  collecting telescopic snapshots   universe.  telescope may  pointed.
  .disc.-shaped area   sky  capture  highresolution image  processing.  restriction  .
 number  galaxies per image    processed.
 exceed  given constant.  goal   process  object  interest via  smallest number.
 snapshots. finding good solutions   problem.
 implications   order  millions  dollars. .
  -hard problem, lupton . . propose  fast,.
greedy heuristic whose solutions   general .
. percent better   near-uniform counterparts.
 method  faster  standard  approaches .
 operations research literature   practice, yields.
solutions  impressive quality.
   problems  captured   covmecf framework. despite  wide array  applica. note  significant theoretical attention  .
given   special case  geometric set cover,   ground.
elements  points  sets  objects  euclidean space.
., ., ., ., ., . many   results generalize  multicovering.
variants,    different notion  capacitated sets.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
tions, mecf   general less understood compared .
 well-studied min-cost flow counterpart, even .
restricted   special case considered . mecf.
  classic  -hard problem, listed  . .
. krumke . . . showed  unless  .
dtime.log logn.,  exists  . . .  .approximation   constant . . . even . .
. established  unlessnp . dtime.npolylog.,.
   exist  .log.
. n-approximation,  .
constant . . .
despite  fact     special case  mecf,.
cov-mecf still subsumes many central problems. one.
benefit   formation    captures multiset multi-cover problems.   words, one .
demand  elements  covered multiple times. .
  imperative aspect  many scheduling problems,.
 particular,  jobs  non-unit length must .
scheduled.
 concrete contributions  two-fold.
.  introduce  lpo algorithm  problems.
within  cov-mecf framework.  wolsey.
approach builds  cover   empty set, lpo.
iteratively trims  sets   initial feasible.
cover  . .  essence  lpo harnesses .
fractional optimal solution  guide  selection.
  next set  remove.  apply  analogs.
 leskovec . . . optimizations  lpo.
 empirically compare  performance  .
 wolsey. greedy algorithm.  find  despite.
 lack  theoretical bounds,   overwhelming majority  instances, lpo returns solutions.
  closer  optimal  wolsey. algorithm.
 also discover   performance verdict .
largely dictated   specific covering problem.
 particular,  instances  capacitated vertex.
cover  active time scheduling .discussed ., lpo  faster  wolsey. algorithm. .
reverse  true  general capacitated set cover.
however  find    instances,  optimization  leskovec . . levels  performances rather evenly.
.   propose  additional .freezing. step.
 lpo .wolsey. algorithm, respectively. .
run,   relaxation   covering problem .
solved.  set variables  take  integral.
values   fractional solution  frozen  .
values .  ., typically. prior   invoking  .
algorithm proper.  experiments indicate .
 often  , freezing improves rather .
hurts  quality   solution.  importantly,.
freezing drastically reduces  number  flow.
calls, since  majority   variables attain.
integral values   fractional solution.
 note   smaller-sized input, directly solving.
  optimal integral solution may  faster  executing  heuristics mentioned , given  iterative nature. thanks   current technology  mixed.
integer program solvers,      instance size .
rather large   truly see  cost  computing .
optimal solution via exponential heuristics.  discussion  performance pertains  approaches  scale.
 thus focuses   comparison   polynomialtime heuristics   optimizations.
 rest   paper  outlined  follows. .
devote  remainder   section   delineation.
  covering problems considered   study. .
section .,  revisit wolsey. algorithm, define lpo.
 describe  optimizations applied. section .
addresses  implementation details  data sets.
results, interpretation  discussion follow  section .
covering problems. cov-mecf captures several important covering problems.  addition .
capacitated set cover,  consider two  problems.
  study,  first     well-known classic.
special case  capacitated set cover.  second.
application  motivated  data centers  .
growing need   algorithmic understanding .
energy-related issues .
capacitated vertex cover .capvc.   standard vertex cover problem,   given  graph.
 . .,.  weights .   vertices.  goal.
  find  subset  .   minimum weight  .
every edge  incident   vertex  .    special.
case  set cover   sense   element  .
covered   two sets.
  capacitated version, vertex   capacity.
., .  upperbound   number  edges .
  assigned  .  goal   find  minimize size.
cover  respects  capacities.   capacities.
 soft,  multiple copies   vertex  may .
selected.  copy  permitted  cover   .
edges,   cost .  incurred   copy  .
  vertex cover.  problem  np-hard. guha.
. . . give  primal-dual .-approximation  .
soft capacities case.   unweighted hard capacities.
version,  .-approximation  given  gandhi . .
., improving upon  initial bound  three given.
 chuzhoy  naor .  weighted case  set.
cover-hard. extensions  hypergraphs  made.
 khuller  saha .  far   know, .
  experimental research suggesting heuristics .
performance better  twice  optimal solution.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
active time scheduling .ats. classical scheduling theory  traditionally focused  objectives .
capture interests   scheduler . makespan.  .
individual jobs . max tardiness, flow time. however,    commonly,   monetarily.
expensive computations  executed  massive.
corpora residing  data centers.  facility.
maintenance, cooling requirements  powering.
hardware,  energy consumption   data center.
translates   budget   order  millions .
dollars. understanding  extent    cost.
. well   carbon footprint.   mitigated  .
area  ongoing research within  systems community.
 considerable bulk   power consumed  .
data center  shared  cooling components .
 energy requirements   memory storage units.
 power consumed   processors   data center.
accounts  less  two percent   total power.
cost . however, changes  scheduling policies .
 processor level .  dramatic impact  data.
center efficiency defined   amount  .useful work.
done,  performance delivered per watt consumed.
.  highlighted   following quote,  calls .
scheduling algorithms expressly tailored toward energy.
efficiency,  contrast   classical objectives studied.
  past.
.potential benefits include increased data.
center capacity  reduced capital expenditures  well  reduced power  cooling costs  power-aware job scheduling.
. . . however, current batch job scheduling algorithms  configurations  tuned .
 optimize performance. energy efficiency .
 ignored. .
  effort  address  concern,  following.
scheduling model  introduced  chang . .
. given   batch machine   work  .
  different jobs simultaneously  well   memory.
storage unit holding  data   job must access.
 job    set  time intervals  .
  processor may work  .    single.
interval corresponds   standard setting  .
 job   release time  deadline.   case,.
 denote  feasible region   release time .
deadline. . practice,   often  case  jobs.
 periodic  nature.    sizeable research.
effort  periodic scheduling. moreover,  job. feasible.
region may depend  irregular constraints, . .
availability   external resource   user. schedule.
 model proposed  general enough  capture jobs .
 nature.  processor must devote  slots  ,.
  time,  memory storage unit  .
.  active time   total time  memory .
.  notion  active time hinges   assumption.
 whenever  storage unit  ,  constant power.
cost  incurred, whether  processor  working  .
jobs   single job, .   power consumed .
 processor  negligible     storage unit, .
commonly observed  data centers ., .
 goal   find  schedule  minimizes.
active time subject   jobs  completed .
 deadlines   processor. batch capacity respected. within  scope   paper, jobs  .
single feasible interval .  release time  deadline.  preemption  allowed   integer time.
points.  call  problem active time scheduling.  graham. notational convention,  problem .
 . ,  ,  , pmtn.
.
.
 ,    . whenever memory storage unit    time unit ,  . otherwise.
 problem fits   cov-mecf framework  .
following way.  left side  .  consists  job nodes.
 must  .covered. multiple times, according .
 lengths.  right side  .    set  time.
slots,      assigned    jobs.
 parameter . .
.
 . notice  subgraph .,  .
 convex.
 general, classic scheduling algorithms, . earliest deadline first policies,   immediately minimize.
active time.  jobs  unit length   single.
release time  deadline, minimum active time  .
achieved via  .-pass linear time algorithm.  arbitrary feasible regions   . .,   also  exact algorithm based  identifying degree-constrained.
subgraphs.  arbitrary , minimizing active time.
becomes trivially  -complete via  reduction .
vertex cover.    hand,  complexity .
minimizing active time  arbitrary length jobs .
  single feasible interval .,  release time .
deadline. remains unclear.    problems fit.
within  cov-mecf framework.
demaine  zadimoghaddam . recently considered  different scheduling problem  minimizing cumulative energy consumption  unit-length jobs  multiple processors, demonstrating   coverage function  submodular, .   greedy algorithm yields.
 .log .-approximation.
  general scheduling model  considered .
khuller . . .,   jobs must  assigned.
 machines,  machine   associated cost .
capacity,  subject  staying within  budget, .
. bipartite graph .,  .  convex means    .
order ., ., . . .   elements       node  . ,.
   adjacent     ,    also adjacent    .
 . ., .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
goal   purchase  set  machines  assign jobs .
  minimize  maximum load   machine.
 problem  clearly set cover-hard. khuller .
. give  greedy algorithm achieving twice  optimal.
makespan,    permitted  violate  budget.
  factor  .lnn.
. algorithms  covering.
 begin  section   review  wolsey. greedy.
algorithm.   introduce  lpo heuristic.
finally,  describe  optimizations applied  .
algorithms. even though  simplicity. sake, .
discussion  given   context  capacitated set.
cover,  algorithms  optimizations   applied.
  covering problems within  framework.
. wolsey. algorithm wolsey. greedy algorithm begins   empty cover   iteratively.
adds sets     ground elements   covered.
  iteration,  selects  set  minimizes .
cost  marginal benefit ratio.  formally,  adds .
  set   minimizes ., ., .
., . .
.
. . . .
 . . .  unbounded otherwise, .
 .   cost    .   maximum.
number  elements    covered  .
. lpo  wolsey. algorithm starts  .
empty solution  greedily adds sets    .
becomes feasible,   oracle algorithm .lpo. begins.
  feasible solution . .   greedily removes.
sets  .   minimal cover, .   sets  .
removed without violating feasibility.
  heart  lpo    solver  provides.
.hints.    sets   closed.  .
course   algorithm, lpo maintains  cover .
 sets    yet  closed, . removed.
 iteration ,  determines  set   sets .
 . . .  . .  feasible .   words,  .
 sets   candidates   removed  .
lpo closes  set .  .
. . arg min.
.
.
 .   fractional cost   instance  .
 sets  .   open .even partially open. .
value .   interpreted   fractional cost.
 removing set   . intuitively, lpo performs.
well  . corresponds   effect  closing.
   integral solution. lpo repeats  steps.
     open sets    closed.
 intuition behind      oracle gives.
warning  closing  set might impose  heavy cost.
 later iterations.   sense,  gives  idea .
 sets   important  others.
  example, consider  following instance .
active time scheduling  unit jobs  batch parameter.
 . . .figure .    block  four rigid jobs,.
  length four,  must  scheduled  slots six.
 nine.  slots   room  one .
job unit.    rest   optimal solution.
look like.   last slot  open,  one  achieve.
 active time  . . .  general. however,  .
last slot  closed,   unit jobs  forced  occupy.
 remainder   otherwise rigid block,  will.
 force  long chain  . . .   scheduled.
earlier,   total active time  . . . . .  .
suboptimal,  lpo  detect  suboptimality. .
 feasibly close slots six  nine.   closes.
 last slot,  cost   scheduling will necessarily.
 .  fractional solution subject  slot . .
closed reflects .
 . .
.
.
.
.
.
.
.
.
.
.
.
.
.
 . . . . . . . . . . .
figure .  example  active time scheduling,.
highlighting  strength  lpo.
one  identify instances   lpo performs.
poorly. figure .    instance.  optimal.
cover  ., ., .    total cost  seven.
. covers ., ., ., . covers .,  . covers.
., . however, lpo  return  cover  cost.
eight.   first iteration,  computes  values.
. . ., ., ., .,.,  .   fractional cost.
subject   removal  set .   point, lpo .
 choice  removing sets ., .  . removal.
 set .  . will result   optimal solution.  .
 hand, removing set .   mistake, leading  .
cover ., ., .  cost eight. unfortunately, lpo.
 select  set   minimum . value, breaking ties.
arbitrarily.  example,    implementation, .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
. . ., .
. . ., .
. . ., .
. . ., .
. . ., .
.
.
figure .  example  capacitated set cover .
 lpo  perform suboptimally. sets  labeled.
  capacities, followed   costs.
may favor sets  lower index.  issue extends beyond.
tie-breaking conventions. even though lpo views sets.
., .  .  equally good candidates  removal, .
 .   achieved via integral assignments, .
  assignment exists  .   regard, .
values .  misguide lpo.    always good.
estimates   cost   integral solution. despite.
,  results empirically demonstrate  lpo.
performs  well  general, frequently beating .
wolsey. algorithm  often achieving optimality .
. optimizations  primary disadvantage.
 wolsey. algorithm     require .
computations  ., .,   quite costly. .
particular,  problems involving hard capacities, .
maximum flow computation  necessary  determine.
., .  may    elements    .
covered  sets already  ,   due  .
capacity constraints,  addition     .
still increase  total number  elements  .
 covered. lpo  plagued   similar .iction,.
    necessitate several computations .
., especially  instances     many.
feasible covers  small cardinality.  following.
optimizations  designed  reduce  number .
 flow computations without compromising solution.
quality.
optimization. ordering sets .  following observation  reduce wolsey. number .
computations, without affecting  cost   solution,   tiebreaking. due   submodularity   ,.
 value  ., .   given set    increase.
  grows. therefore one  delay recomputing.
., .  sets   already  high values .
previous iterations, since   guaranteed  .
 selected   current iteration.  formally,.
    partial cover   beginning   ith.
iteration. suppose  ., ., . . . ,    order.
   algorithm computes ., . given .
particular set  ,   denote  minimum ., .
value among  first  sets, .
 . min.
.,.,.
., .
,  set .   earlier iteration .
. . ,.
 . . , .,   follows   . ., .
 well, since . , . . ., . thus .
know  . will    next set added  ,.
    need  compute ., . explicitly.
 observation holds regardless   order  .
 algorithm iterates  sets. thus,   considers.
sets  increasing order    recently computed.
., . value,  number  computations  .
 decrease   solution cost remains .
 .,   tiebreaking.
 observed  ., applying  optimization .
wolsey. algorithm yields  significant improvement .
performance.  demonstrate  independently  .
results. since   spirit   original algorithm .
preserved,  .log . guarantee still holds. however,.
 ,  bound  somewhat irrelevant since, .
  naive implementation,  solution quality .
often much better.
one  apply  analogous optimization  lpo,.
since   set , .   increase  .
gets smaller   passing iteration.  omit .
details since    straightforward modification .
 optimization  applied  wolsey. algorithm.
optimization. freezing set variables. .
say  set  closed       cover  open.
otherwise. simply stated,  following preprocessing.
step  done prior   execution   .original.
 otherwise optimized. algorithm. first solve  .
relaxation .see appendix .  sets  values.
.  .   fractional optimal solution  frozen .
 closed  open, respectively.  run wolsey.
algorithm .lpo, respectively.   remaining unfrozen sets,   feasible solution  attained .
  unfrozen sets   closed, respectively.
note    optimization applied  wolsey.
algorithm,  theoretical bounds  longer hold. .
spite  ,  empirically demonstrate  wolsey.
 lpo   modifications return solutions.
  still quite close  optimal.  particular,.
    freezing optimization frequently.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
correct suboptimal solutions,  also severely reduces.
 number  flow evaluations    .
necessary otherwise.
. implementation.
 implementations  developed  java, invoking cplex .version . wherever  flow   call.
 needed. experiments  performed   shared.
machine  eight .ghz quad-core processors .
. ram,  unoptimized heuristics taking anywhere  several hours  days  compute  .
heavier data sets.
. data sets  generated several structured random instances  capsc  ats.  notational convenience,  describe capsc   context  jobs .
slots, rather  ground elements  sets. given parameters ., .,.,., ., instances   jobs .
. .  . . random   slots  . .  . .
random  created.   capsc instance, capacities.
bounded    independently  randomly chosen.
  slot,   job randomly selected  slots.
  cover .   instance    ats,.
 single capacity . .   randomly selected, .
 job randomly chose  release time,  deadline   release time,   job length    .
length   feasible window. infeasible instances .
dropped  replaced  feasible ones.
fifteen capsc instances  fifteen ats instances.
 generated  parameters ., ., ., ., .
 data sets  denoted .small. sets. .
.medium. data set consisted  five capsc instances.
 five ats instances, generated  parameters.
., ., ., ., .   capvc testbed  parameters ., ., ., .,  random graph ., . .
created    uniformly selected  random.
 ., .    similarly selected  .
range ., . , capacity .  computed .
. . ., . infeasible instances  dropped.
 replaced  feasible ones. twenty instances .
generated     following parameter vectors.
., ., ., .  ., ., ., .
 heuristics  also tested  modified graph.
instances taken   public testbed given  .
dimacs implementation challenge .  graphs.
 originally intended  test clique algorithms .
 quite dense. others  intended  test heuristics.
  k-coloring problem   less . finally,.
 evaluate  heuristics  two instances  model.
large-scale social interaction  connectivity structure,.
respectively. newman. netsci graph   collaboration.
graph  authors publishing  network science.
.  contains . vertices  .,. edges. .
also consider  network  peer-to-peer file sharing.
connections.  contains .,. vertices, one per gnutella.
host,  .,. edges denoting observed connection.
 two hosts .
 note   instances  . .,.  capvc,.
  side   cov-mecf framework  . . . .,.
   side  . . . . .  out-degree  .
node  .   two, since  edge   covered .
  two incident nodes.
. inducing capacities  dimacs graphs .
 real world graphs  instances  standard vertex.
cover.  aggressively imposed capacities   .
low  possible, without rendering  instance infeasible   following way.   given instance, assign .
vertex   capacity   selected independently .
uniformly   range ., .,  . .
 degree  vertex   . . . . .   constant.
 subsequent procedure  followed  ensure .
feasibility  maintained.   candidate ., assign capacities  feasibility  achieved   fifth.
attempt   made.   instance  infeasible,.
increase .  .  repeat.  process  guaranteed  return feasible capacity assignments  long .
 uncapacitated version  feasible.   case, . .
initialized  .
. additional perspective two  rounding algorithms,   ,  implemented  provide additional perspective   solution qualities returned .
lpo  wolsey. algorithm.   denote  value.
  indicator variable   set  corresponding.
  .    fractional solution.  adds   .
cover   .
.
. .   cover  still  feasible, .
greedily adds  remaining sets  decreasing order .
 .  adds  set    cover independently  probability  . min., .   cover.
 feasible,  returns. otherwise,  repeats.
. results  discussion.
  section,  discuss  results   various.
implementations  wolsey. algorithm  lpo. .
evaluate   solution quality  efficiency  computation perspectives.   latter,  primary metric considered   total number  flow . . evaluations made.  draw  conclusions based  timing constructs since  experiments  executed  .
.one instance failed  complete computation.  contribution  omitted   relevant statistics.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
num. inst. lpo lpo. lpo.oof wol wol. wol.oof  .
ats . . . . . . . . .
capvc . . . . . . . . .
capsc . . . . . . . . .
table . number  suboptimal instances   implementations  lpo  wolsey. algorithm  random.
testbeds.  total number  instances   testbed  also given   first column.
lpo lpo. lpo.oof wol wol. wol.oof  .
ats . . . . . . . .
capvc . . . . . . . .
capsc . . . . . . . .
table . average alg.opt ratio   implementations  lpo  wolsey. algorithms   random.
testbeds.
shared machine. however,  note  wolsey. algorithm involves max flow computations  lpo calls.
 relaxation  min-edge cost flow computations. .
   larger graphs,  vanilla implementations.
 wolsey  lpo   complete,   .
results   optimized versions  reported. .
 sake  notational convenience, alg. will refer   algorithm alg  optimization  order.
alg.oof refers  alg   optimization .
order  optimization via freezing.
. solution quality   scheduling instances.
.line .  table ., lpo,    returned optimal.
solutions every time.    hand, wolsey.
algorithm  suboptimal  several instances, even.
 intelligent ordering   sets.   cases,.
intelligent ordering even hurt wolsey. solution due .
 change  tie-breaking.   bright side, .
 wolsey. suboptimalities  corrected  freezing.
 capvc instances, lpo underperformed  one.
instance  wolsey. algorithm  suboptimal .
seven .six    corrected  freezing. .
  comparable   number  instances  .
    suboptimal, table . demonstrates .
wolsey. solutions   average significantly closer .
optimal      . wolsey. algorithm.
attained  average .-approximation . .
freezing.,       average within .
 .  optimal. lpo  wolsey. algorithms.
maintained similar performance   capsc testbed,.
though  freezing optimization  little  improve.
 solution.
  dimacs  real world graphs,  optimized version  lpo achieved optimality   .
one    wolsey. algorithm underachieved .
 least two graphs, failing  complete  one .
nevertheless,  performance  reasonable, relative .
 performance       graphs. see.
tables ., .  .  appendix   .
  clear  though  exist  worst-case.
guarantees  lpo,  returns optimal solutions significantly  often  wolsey. implementations. .
 implementations, whenever    implementations  suboptimal,   never   much. .
  stark contrast     solutions .see table .
  confirms   already  long accepted.
 practice. wolsey. algorithm   whole performs.
much better   theoretical bound  suggest.
 point    freezing optimization .
 hurt  quality  solution     random.
instances.  least  lpo,    surprising. .
lpo. subroutine involves solving   relaxation .
 problem.    exact  relaxation  .
freezing step solves,   variables   frozen .
zero   fact  sets  lpo   discarded.
first anyway.
. computational efficiency   ats,.
capvc  dimacs instances,  vanilla implementation  lpo required significantly fewer subroutine.
calls   wolsey counterpart.  reverse  true.
  capsc instances.     expected,.
since  design, lpo  wolsey. algorithm .
complementary   approaches.  instances.
  lpo. final solution consists   small.
number  sets, lpo will make many calls. similarly,.
 instances  feasible covers tend   large,.
wolsey. algorithm will involve many  iterations.
 multicover property   ats instances results.
 higher cardinality solutions.  sparsity  .
capvc instances, .   edge   covered.
   two vertices, leads   similar effect.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
see appendix   tables   actual average.
number  subroutines required   implementation.
  random testbed.  also contains statistics .
 dimacs graphs,  netsci graph   gnutella.
graph, specifically,  actual solution values acquired .
well   number  subroutine calls required  .
  implementations.
. optimization. ordering sets  particular optimization yields significant improvement .
 number  calls, though  extent   effect varies  testbed  testbed.  instances.
 wolsey. vanilla algorithm performed better .
lpo., intelligently ordering sets leveled  playing.
field.  reverse   true.  instances  vanilla.
lpo already involved fewer calls  vanilla wolsey,.
lpo. continued  excel.
table . contains  average percentage reduction per implemention, per generated testbed. .
ats instances, lpo enjoyed greater improvement .
wolsey.  example,   medium set,  optimization reduced lpo. average number  calls  .
 .,    reduced wolsey. average number.
 calls  .  .  point   wolsey.
vanilla implementation   finish  one instance .
 medium capvc set,   percentage reductions .
 reported.   capsc instances,  optimization.
  sense leveled  playing field  lpo. lpo.
observed  average . percent reduction   number  calls  wolsey witnessed   . percent.
reduction. however,  reduction  misleading.  .
  vanilla lpo involved  many  calls.
 vanilla wolsey.  example,   medium data.
set,  optimization reduced lpo. average number .
calls  . calls  . calls  wolsey.  .
calls  . see tables .  .  appendix   .
  dimacs instances    vanilla.
implementations completed,  number  calls invoked.
 lpo   least fifty percent less   number.
 calls made  wolsey. intelligently ordering .
sets yielded  average . percent reduction  lpo.
number  calls   . percent reduction  .
 wolsey.   edge   covered .
  two vertices,  final solution   lpo.
 wolsey tended    higher cardinality, relative.
  total number  vertices.  explains .
lpo  average made fewer calls  wolsey, even.
 optimizations applied.    hand, .
number  calls made  wolsey  significantly less .
 netsci graph    lpo,  least  .
optimized implementations.
. optimization. freezing set variables .
 large,  freezing optimization  improved.
 performance  lpo  wolsey, giving lpo .
edge  wolsey.  fact,     random.
testbeds, lpo.oof involved  average fewer subroutine calls  wolsey.oof .see tables .  .  appendix .  discussion  follows pertains  .
percentage reduction  number  calls.
  ats instance, freezing yielded  feasible.
integral solution, resulting  identical performances.
 lpo.oof  wolsey.oof. though  exist.
scheduling instances    fractional solution.
  integral,  examples may    number.
none    present   random testbed. .
 capvc testbed, freezing witnessed  additional.
. percent reduction  lpo. performance,  .
combined . percent reduction  tandem  .
ordering optimization. wolsey. algorithm saw  total.
. percent reduction   number  calls, . percent.
attributed   freezing optimization.   capsc.
instances,  freezing step  reduced lpo.
number  calls  . percent   vanilla lpo.
 intelligently ordering  sets reduced wolsey.
number  subroutine calls   . percent, .
freezing step additionally reduced   another .,.
  combined . percent reduction   number.
 calls.  suggests   impact  freezing.
 wolsey. algorithm, lack  theoretical guarantee.
notwithstanding,  comparable    imposing .
intelligent orders  sets,  least  capacitated set.
cover.
freezing  negligible effect     dimacs instances, since  fractional solutions  .
integral values. however,  opposite  true  .
 netsci graph   gnutella peer-to-peer network,  fraction solution   latter achieving integrality. thus, frozen implementations   lpo .
wolsey. algorithm  impressive,  contrast  .
less-optimized counterparts,    timed  .
several hours. see tables .  .  appendix .
. conclusions.
  work,  introduce  cov-mecf framework.
 study several important covering problems  .
context   model.  introduce  heuristic lpo,.
 queries  fractional solution  guide  iterative removal  sets   working cover.  empirically demonstrate  lpo returns solutions .
 closer  optimal    wolsey. algorithm,.
  required number  subroutine calls  largely.
dictated   nature   input. however, .
 freezing optimization, lpo almost unilaterally requires fewer subroutine calls  wolsey. algorithm,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
lpo. lpo.oof wol. wol.oof.
ats . . . .
capvc . . . .
capsc . . . .
table . average percentage reduction   number  subroutine calls.
though  latter still enjoys heavy benefits  freezing.  results solidly establish lpo   competitive .  superior. alternative  wolsey. greedy algorithm.  general,  find  freezing yields  significant reduction   number  calls,   rarely.
harming  quality   solution.
 remains   explore  value  lpo .
 freezing optimizations   covering problems,.
 example  unrelated machine activation problem.
introduced  khuller . . .   also unclear.
whether  contributions extend beyond covering.
problems, .  probabilistic models  exhibit.
similar graph structure  cov-mecf.
</doc>
<doc title='3_ALENEX_24.txt'>
downloaded  knowledgecenter.siam.org.
short  simple cycle separators  planar graphs.
eli fox-epstein. shay mozes . phitchaya mangpo phothilimthana .
christian sommer .
abstract.
 provide  implementation   algorithm ,.
given  triangulated planar graph   edges, returns.
 simple cycle    .balanced separator consisting   .
.
. edges.  efficient construction  .
short  balanced separator  forms  simple cycle.
 essential  numerous planar graph algorithms, .,.
 computing shortest paths, minimum cuts,  maximum flows.   best   knowledge,   .
first implementation    cycle separator algorithm.
  worst-case guarantee   cycle length.
 evaluate  performance   algorithm .
compare    planar separator algorithms recently.
studied  holzer  . .esa ., acm journal  experimental algorithms .    algorithms,.
  fundamental cycle separator .fcs. produces.
 simple cycle separator. however, fcs   provide  worst-case size guarantee.  demonstrate .
.  algorithm  competitive across  test cases .
terms  running time, balance  cycle length, . .
provides worst-case guarantees   cycle length, significantly outperforming fcs   instances, .
.iii.  scales  large graphs.
. introduction.
separators identify structure   graph  cleaving.
  two balanced parts  little mutual interference.  separator theorem typically provides worstcase guarantees   balance   parts   .
size   shared boundary. separators  .
studied extensively  separator theorems  .
found  planar graphs ., ., ., ., ., ., .,.
bounded-genus graphs ., ., ., minor-free graphs.
., ., ., ., ., .,  others.
efficient algorithms   graph classes often exploit  fact   input graph  small separators.  example, divide-and-conquer algorithms rely.
.tufts university, .tufts.edu.
.mit, shaym.mit.edu. part   work  conducted .
   brown university.
.mit, mangpo.csail.mit.edu.
.csom.csail.mit.edu.
 decomposing  problem  subproblems  little interference.  formally,  separator   graph.
 . .,.   subset  .   partitions  . .
 two sets , .   approximately equal size.
.say ., . . . .   edges   two.
parts . .  .  . .  smaller set  often implies.
faster algorithms providing solutions  various problems   exact shortest paths ., .  approximate vertex cover .,  many  ., ., ., .,.
., ., ., ., ., .  planar graphs,   known.
 . . . .  possible, even  worst-case instances .
separators  planar graphs  based  fundamental cycles.   spanning tree  ,  fundamental cycle.
cuv induced   edge  .    simple cycle.
formed     u-to-v path   . every fundamental cycle  separates  graph  two parts. .
subgraph enclosed     subgraph  enclosed.
 .  elementary argument shows ,   graph.
 triangulated,   always exists  edge  . .
     balanced separator  . namely,.
   two parts consists    . . vertices.
 key observation  , starting   breadth-first.
search tree,  size   fundamental cycle   .
one plus  diameter   graph. therefore,  .
diameter  small,  simple fundamental cycle separator algorithm works well. arbitrarily select  root .
 breadth-first search, compute  bfs tree,  .
return  best fundamental cycle .best may  defined.
 terms  balance, length,  . however,  .
diameter  large,  balanced fundamental cycle may.
 long, ,   consequence,  separator may .
large  well.
 order  provide separators  small worstcase sizes,  separator algorithms first reduce .
diameter   input graph   use  fundamental cycle separator algorithm   subroutine. .
seminal planar separator algorithm  lipton  tarjan . .henceforth referred   lipton-tarjan. finds .
.balanced separator  identifying two sets ., . .
. generally, one  define separators   balanced.
 respect   weight function   vertices, edges, ,.
 embedded graphs, faces.
. copyright . siam.
unauthorized reproduction   article  prohibited.
small size . , . . .
. ., whose removal yields.
 subgraph  diameter .
. .  large enough.
weight. one  interpret  diameter reduction .
shortcutting  fundamental cycle using  vertices  .
 .
 many planar graph algorithms   .
computing shortest paths ., ., ., ., ., minimum.
cuts ., ., maximum flows .,   crucial  .
separator  forms  .simple. cycle  . unfortunately,.
adding vertices   sets ., .  shortcut  fundamental cycle,    lipton-tarjan algorithm, results.
  separator    necessarily form  simple cycle. neither  lipton-tarjan algorithm . .
djidjev. algorithm . obtain simple cycles,  .
fcs algorithm   provide  worst-case guarantees   cycle length.
 algorithms  miller ., gazit  miller .,.
 djidjev  venkatesan . offer  guarantees.
  triangulated .connected planar graph,  .
compute  simple cycle separator  length .
. . .
linear time.   work,  focus  cycle separator.
algorithms  planar graphs.
. related experimental work.    large.
body  experimental work  graph partitioning,.
mostly implementing various heuristics.   work,.
 shall focus  algorithms  worst-case guarantees. theoretical results  separators suggest  .
  used  substantially speed  algorithms. consequently, lipton-tarjan separators  variants .
 implemented  evaluated experimentally ., .,.
.
farrag . implemented  algorithm  aleksandrov  djidjev ., , instead  separating  .
two sets ,,  number  pieces   specified.
 separator algorithm  used  load balancing .
parallel algorithms.  input graph  partitioned .
 pieces, distributing  work evenly among  processors.
aleksandrov, djidjev, guo,  maheshwari . implemented  three-phase algorithm,  . partitions.
 graph  levels, . partitions  graph  fundamental cycles,  .iii. combines  resulting components   right number  pieces .packing.
  recent experimental work,   one.
 relevant  compare   work   holzer,.
schulz, wagner, prasinos,  zaroliagis .,  implemented  lipton-tarjan algorithm .  djidjev. algorithm .,  provided  extensive experimental evaluation. one   main findings  .
study  , across  battery  test graphs, .
fcs algorithm performs  least  well   .
carefully engineered counterparts, despite  lack .
worst-case guarantees.
  best   knowledge, cycle separator.
algorithms  worst-case guarantees   cycle.
length    implemented  evaluated yet.
. contributions.  provide  implementation.
  cycle separator algorithm   worst-case guaranteed size .
.
. .  algorithm   variant .
 one recently described  .,   klein. forthcoming book .  experimentally evaluate  algorithm  compare    fundamental cycle separator .fcs. algorithm.  mentioned  section ., .
experimental results  holzer  . . suggest .
 fcs algorithm works well   inputs.  confirm  findings. however,  also identify classes.
 graphs    fcs algorithm returns arbitrarily long cycles.  demonstrate  .  algorithm  competitive  respect  fcs   graphs.
 ., .  provides worst-case guarantees   cycle length, significantly outperforming fcs   instances,  .iii.  scales  large graphs.
  hopeful   implementation will pave.
 way  implementing  many theoretically efficient.
algorithms  rely  simple cycle separators  planar.
graphs.
. preliminaries.
  tree    edge  .  ,   denote  subtree.
  rooted   leafward endpoint  .  breadthfirst search .bfs. yields  tree,    subgraph .
 input    vertices  exactly  edges.
traversed   search. one  seed  bfs  .
number  vertices  edges.   , imagine .
search started   super-vertex connected   .
 seeds.   may yield  forest instead   tree.
  rooted tree  ,   set   nodes   , .
leafmost node     node      property.
    lie   root-to-s. path    .
 node . . . similarly,  node   rootmost .
    node . .   lies   s-to-root.
path   .
  spanning tree      edge    .
  ,  fundamental cycle    respect    .
  simple cycle consisting     unique simple.
path     endpoints  .
 provide  brief review  basic definitions .
facts related  planar graphs, combinatorial embeddings  planar duality.  elaboration, see also .
.  hard instances  fcs,  length   cycle heavily.
depends   choice   root   bfs tree.   roots,.
 fundamental cycles  short,    roots  cycles.
  long.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. embeddings  planar graphs.   .
 finite set,  edge-set.  define  corresponding.
set  darts    . .   . ,  darts.
   .,.  .,.  think   darts  .
 oriented versions   .one   orientation. .
define  involution rev.  rev., . . .,. .
, rev.   dart    edge   opposite.
orientation.
 graph    defined    pair .,. .
   partition   darts. thus  element  .
  nonempty subset  darts.  refer   elements.
   vertices.  endpoints   edge   .
subsets , . .  containing  darts  .  head .
 dart    subset  .  containing ,   tail .
 head  rev.
 embedding  .,.   permutation   .
darts      set  orbits  . .
 orbit ,  restriction     orbit  .
permutation cycle.  permutation cycle   specifies.
  darts  head   arranged around   .
embedding ., say, counterclockwise order.  refer.
  pair .,.   embedded graph.
 . denote  permutation rev . ,  .
denotes functional composition.  ., .  another.
embedded graph,  dual  .,. .  context,.
 refer  .,.   primal.
 faces  .,.  defined    vertices.
 ., . since rev. .rev. . ,  dual   dual.
 .,.  .,. therefore  faces  ., . .
 vertices  .,. throughout  paper  denote.
 primal graph     dual  .
 define  embedded graph .,.   planar.
  . . . . .,     number  vertices,.
   number  edges, .   number  faces,.
 .   number  connected components. since.
taking  dual swaps vertices  faces  preserves.
 number  connected components,  dual  .
planar embedded graph  also planar.
note , according   notation,   use .
 refer   edge   primal   dual.
combinatorial embeddings  useful  practice.
 well.   implementation, embedded planar.
graphs  represented  permutations   darts.
darts  vertices  represented  integer values.
graphs  efficiently traversed  retaining lookup.
tables allowing one  walk around permutations .
find incident darts  vertices.   implementation,.
 graph takes . . . . . integers   primal.
 dual representations,   sufficiently compact.
  accommodate graphs  millions  vertices .
commodity hardware.
 provide  intuition  use geometric embeddings  planar graphs   figures   paper. .
 primal   dual graphs  embedded  .
 plane,   edges   one-to-one correspondence.  edges   dual graph   figures .
rotated  roughly . degrees clockwise  respect .
 primal counterparts.
 focus  undirected embedded planar graphs.
  self-loops  parallel edges.   graph , .
use  ., .,  .  denote  vertices, edges, .
faces  , respectively.
 use  following properties  planar graphs.
fact . .simple-cycle.simple-cut duality .
 set  edges forms  simple cycle   planar embedded.
graph  iff  forms  simple cut   dual .
since  simple cut   graph uniquely determines.
 bipartition   vertices   graph,  simple cycle.
  planar embedded graph  uniquely determines .
bipartition   faces.
definition . .encloses.     simple cycle .
 connected planar embedded graph .   edges.
  form  simple cut .   set   vertices.
 ., . faces  . thus  uniquely determines .
bipartition ., .   faces  .  .,   faces.
 .  say  encloses   respect  .  exactly.
one  , .   .   vertex.edge ,  say .
encloses  . respect  .   encloses  face.
incident   .encloses strictly   addition   .
part  .
fact . .   spanning tree   ,  set.
 edges      form  spanning tree  .
  spanning tree  ofg,  typically use  .  denote.
 spanning tree  . consisting   edges    .
. cycle separators  planar graphs.  define  .balanced separator    tripartition  .
vertices   graph  .,, .  .
separated.    edges   node   .
 node  .
balanced. .  .     . . .
small. . . .   .
typically,  well  throughout  paper, . .
.
.
.  . . .
    triangulated biconnected simple planar.
graph.  simple cycle    separates   .
interior   . subgraph enclosed  .  .
exterior   . subgraph  strictly enclosed  .,.
     edges  vertices strictly.
enclosed    vertices  enclosed  . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. .
.
figure .  triangulated graph  unit face weights.
  spanning tree .solid edges.    fundamental cycle  .balanced.   example  fundamental cycles  .balanced.  fact,  exemplifies  worst case.  ,  balance  .  always.
achievable, provided  single face accounts  .
 .  total weight.
call  simple cycle   small balanced cycle separator.
    separator defined   interior  ,.
 exterior  ,     .balanced .
. . .    .
 note  balance   defined   general.
terms  number  vertices.     function.
assigning real weights  vertices, edges,  faces  .
 cycle separator   balanced  respect  .
weight function    total weight  vertices, edges,.
 faces strictly enclosed .respectively,  enclosed.
     .  total weight  . general.
weights   handled  considering just face weights.
arbitrarily assign  weight   vertex  edge .
 incident face.  cycle separator   balanced.
 respect   new weight assignment  necessarily.
balanced  respect   original one. therefore,.
without loss  generality,   refer  face weights.
  paper.
 triangulated planar graphs  general face.
weights  may  exist  .balanced fundamental.
cycle separator, even   weight   single face.
   .  total weight.   illustrated .
figure .    difficult  see  one  always.
achieve  balance  . however,   weight  .
face  negligible  respect   total weight . .
 case  separating according  just  number.
 vertices   graph  many vertices.,   .
 problem   balance  almost .  achievable.
  sake  generality,  use  balance  . .
 proofs. experimentally, since  balance criterion.
 use   number  vertices,  always observe .
balance    .
  input graph   triangulated, one .
always add edges  triangulate .   case .
cycle separator   necessarily form  cycle  .
input graph. however, topologically,  separator .
form  cycle.   applications   topological.
separation suffices,   others   possible  retain.
 additional edges without affecting  application.
.  cycle separator algorithm.
  section  describe  simple cycle separator.
algorithm.  roughly follows  overall structure .
miller. algorithm .,   significantly different. .
algorithm  similar   one suggested recently  .,.
also described  klein. forthcoming book .
. levels  level components.  define.
levels  respect   arbitrarily chosen face .,.
  designate   infinite face.
definition .  level . .   face    minimum number  edges   .path   dual.
.  .  use lfi  denote  faces  level ,.
  use . denote  set  faces   level .
least .
definition .   integer  . .,  connected.
component   subgraph  . induced  .  called.
 level-i component, ,     want  specify , .
level component.  use .  denote  set  leveli components.  level-i component   said  .
level ,   denote  level  .  nonroot.
level component   level component whose level  .
zero.  set  vertices  . .faces  . belonging .
  denoted  .
note   use  . .  denote  level component even though    connected component  .
subgraph   planar dual.
fact .   nonroot level component,  subgraph  . consisting  faces    .  connected.
corollary .   nonroot level component ,.
 edges crossing  cut . ., . .  . ., .
set  edges  .  exactly one endpoint   .
form  simple cycle   primal .
 view  corollary .,   nonroot level.
component ,  use .  denote  simple cycle.
  primal  consisting   edges   cut.
. ., . . .  refer  .   level cycle.
bounding .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.  triangulated graph .blue vertices  edges.
along   dual bfs tree . red, faces  different.
bfs levels  indicated  different shapes. .
.primal. components .  indicated  shaded.
subgraphs.  deeper  level   component, .
darker  shade .
.  corresponding.
component tree . .
node   component.
tree corresponds  .
connected component.
 .
figure . illustration   component tree .
definition .  component tree    rooted tree.
whose nodes   level components,    .
  ancestor   .   faces   include  faces.
  .
 root   component tree   unique level-.
component consisting    . figure . illustrates.
 definition   component tree.
definition .  edge  .  .  level    .
level    .  level . .  write . .  .
level   .  use lei  denote  set  edges .
level .
note   every edge  .   level.
. description   algorithm. pseudocode .
 algorithm  given  algorithm .  overview .
 algorithm   follows.     sum  .
weights    faces.
 algorithm starts  computing  component.
tree . next,  algorithm finds  small range  levels,.
  short balanced cycle separator  guaranteed .
exist .see appendix.   done  identifying .
leafmost component  . whose weight   least half.
 total weight.  . denote  level  .
. .
algorithm finds two levels, .  .,    .
.
.
. edges,  bracket . .lines ., . .
  single component .  level .  contains  .
 denote  level-i. components contained  . .
.,., . . . .     subgraph   induced  .
faces  . .
.
. .  edges    level . .
  single face  .    bounding cycle .
  component .  level .  contains  .
similarly,  edges    level .    set  faces.
 correspond   bounding cycles . .
 components .   . happens  .
 good separator,   returned .line .
otherwise, roughly speaking,  algorithm finds.
 balanced fundamental cycle  .  shortcuts .
along one   cycles . care must  taken .
ensure   resulting cycle  simple.   ensured.
  appropriate choice  spanning tree,  .
appropriately defining   shortcut  fundamental.
cycle along .
 precisely,  algorithm initializes  forest .
   edges  . except  arbitrary one.
 iteratively adds   edges   cycles .
. . .    introduce cycles .line . .
line .   extends    spanning tree   .
 performing  breadth-first search starting  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
algorithm . cycle separator algorithm.
. triangulate   choose . arbitrarily.
. construct  component tree .
.   .   maximum-level component  weight  least .
.  .   level  .
.
.  .   maximum level  exceeding .   .lei. . .
.
.
.  .   component  level .  contains  .
.  .   minimum level  less  .   .lei. . .
.
.
.  .,., . . .   components  level . contained  .
.  . . . . .    . .  return .
. initialize  forest     edges  . except   arbitrary one.
. foreach cycle . . . . .
. foreach edge   . .
. add        introduce  cycle  .
. extend    spanning tree      breadth-first search, starting   component   .
contains  edges  .
.   .   spanning tree  . rooted  .  consists  edges   .
.  .    balanced edge separator   .
.   . . .
.
.  return  fundamental cycle   . .
.   . .     . .
.     subgraph   induced   faces  . .
.
.
.   . denote  set  faces   .  belong  .
.     boundary   .
.  ., ., . . . , .   decomposition    simple cycles.
.   denote  set  faces enclosed   . . .  . .
.  . .   . .  . .  return .
. else.
.      . . .
.
 .
.
.rhk.
.
. .
. return  boundary   .
.
.rhk.
component    contains  edges  . .
  mean   bfs  seeded   component.
    contains  edges  . whenever .
vertex   component  .    first visited  .
search,  .  added   ,    vertices   .
 marked  visited.  three-step construction .
 spanning tree   important  ensuring  .
cycle returned   procedure   simple cycle .see.
appendix.
 algorithm next computes  spanning tree  .
 ., consisting   edges    .  finds .
 balanced edge separator .   .   . ,.
  fundamental cycle   .   returned.
.line . otherwise, . .     . . . . .
since,  construction,  fundamental cycles  .
balanced.   . denote  subtree  .
. rooted  .
note   vertices   .  exactly  set  faces.
enclosed   fundamental cycle   .  .   .
  set  faces   .    belong   .
    bounding cycle   .  decomposes.
 one    simple cycles ., ., . . . , . .
    balanced separator,   returned .line .
otherwise,  must   prefix   . whose.
interior, together   faces  component   .
set  faces whose boundary   balanced simple cycle.
separator.
 prove   appendix  algorithm . always.
returns  .balanced simple cycle separator  .
.
.
. edges.  discussed  section .,  .
weight  defined   number  vertices  .
  replaced  . throughout  paper.
. experiments.
  section  evaluate  performance   algorithm  compare   prior results. one  .
striking findings   experiments  holzer  . .
   fundamental cycle separator algorithm .
usually  effective  finding small, balanced cycle.
separators.  goal   paper   establish .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 algorithm,   provide  worst-case guarantee   separator size  balance,  competitive.
 fcs   terms  runtime   average-case.
cycle size  balance.    directly compare .
results    algorithms presented  ., .,.
primarily     produce simple cycle separators,  also  fcs. performance  shown.
  dominant   cases.
 fcs algorithm . operates  follows. first,.
 computes  primal bfs tree  spanning  graph.
recall   edges    form  spanning tree  .
  dual graph.  primal edge  .    .
defines  fundamental cycle,  one formed   .
 unique path       . working  leafs.
  . towards  root,   efficiently compute .
weight enclosed   fundamental cycle   . .
algorithm returns one   cycles    balanced.
separator.
   trade-off  balance  cycle.
length.  one prefers short cycles,  makes sense .
return  shortest cycle amongst    .
least .balanced.    hand, one .
necessarily return   balanced cycle  length.
.
.
.,  fcs    cycle size guarantee.  .
case,   fcs   algorithm,  return  first.
balanced separator found. experimenting  different.
choices produced results  significantly different .
 reported .
 used two variants   algorithm  two.
variants  fcs  order  illustrate various issues .
arise   experiments. recall   algorithm.
may return  level cycle .line .  algorithm ., .
fundamental cycle .line .,   fundamental-and-levelcycle merger .lines ., .  first variant  .
algorithm implements  algorithm  presented .
section .  particular,  terminates  soon  .
encounters  cycle    .balanced separator. .
refer   variant  unoptimized.  second variant,.
  refer   optimized  balance, computes.
 candidate separators  returns   balanced.
candidate found.
similarly,  first variant  fcs   one .
terminates  soon   encounters  cycle   .
.balanced separator.  refer   variant .
unoptimized.  second variant,   refer  .
optimized  length, returns  shortest fundamental.
cycle among     .balanced.
. data sets  experimental setup.  effectively compare  algorithms,  draw extensively.
  graphs tested experimentally  ., . .
graph  triangulated  testing. note  .
  degree  freedom  triangulation .holzer.
 . . use  triangulation routines provided .
leda.   graphs  represented  permutations.
  darts .see .    representing embeddings.,  simply triangulate  walking  .
permutation describing  faces,    orbit .
larger  three,  insert  edge  produce  triangle  reduce  size   orbit  one.
   list   classes  graphs.
. grid  square grid graphs. rect  rectangular.
grid graphs. c-grid  two  graphs connected.
via . joining vertices  form  perfectly balanced.
cycle separator.
. sixgrid graphs  tessellated hexagons.
.  k-iteration tri graph starts   triangle, .
    iterations,  face except .  .
new vertex embedded within   connected .
 vertex   face. boundary.
. globe graphs approximate spheres,   implemented  wrapping  rect   cylinder .
adding  vertex  top  bottom connected .
 vertices   top  bottom rows, respectively.  call  skewed globes eggs.
. cylinder graphs  similar  globe graphs, .
 addition   extra vertex  every square.
bfs trees produced  cylinder  .triangulated. globe graphs differ substantially.
.  diameter-k  essentially  narrow, length-k.
strip, triangulated   way  maintains  diameter      small separator . figure .
 .
.  airfoil graph   finite-element mesh  realworld data .
.  graph col   usa-col road network used.
  . dimacs implementation challenge.
. shortest paths ., accessible online . .
repeatedly removed vertices  degree   .
,  interpreted  graph   coordinates.
  straight-line embedding   added vertices.
whenever two edges intersect geometrically.
 tests  run   machine  two intel xeon.
. processors  . gigabytes  ram.  code.
 compiled using gcc . targeting . . .
operating system  debian. runtime tests  run.
single-threaded   otherwise-idle machine. time .
measured  cpu clock ticks, using  clock function.
 . instances  sufficiently large   clock.
granularity  negligible.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
 .
 .
 .
 .
 .
 .
grid rect globe egg cylinder hex c-grid diameter.
.
 .
.
.
 .
.
.
graph type.
figure . running time . cpu clocks.   algorithm,  optimized  balance .blue.  unoptimized.
.teal.   fcs, optimized  length .red.  unoptimized .orange.
. results  interpretation. following holzer.
 . .,  use whisker plots .figures ., ., .
.  show  runtimes ,   balance .
separator size produced   algorithm  fcs .
various types  graphs.   graph,  tried .
large sample  possible faces  roots   component.
trees   algorithm,  possible vertices  roots.
  primal bfs trees  fcs.  box   plot.
corresponds   middle .  values obtained .
 choices  root vertices.  whiskers span  entire.
range  values observed.  . mark   plot.
indicates  mean  observed values.
. running time. figure . shows running times.
  two variants   algorithm   two variants.
 fcs  various graphs,   roughly .,.,.
vertices. specifically,  test   .  . grid,.
.  . rect, .  . globe, .  .
egg, .  . cylinder, . square hex, .  .
c-grid,   diameter-. graph.
  evident   algorithm  typically slower.
 fcs,     factor    two.   .
 expected since   algorithm  fcs compute.
 bfs tree  find  fundamental cycle separator, .
 algorithm also performs  dual bfs  compute .
component tree  level cycles.
 note    egg, cylinder,  diameter.
graphs,  well  occasionally,  grid, globe, .
hex,  unoptimized variant   algorithm  faster.
  variants  fcs.  explain  behavior,.
 examined  type  separator returned  .
unoptimized variant   algorithm.   shown.
 figure . .left. recall   unoptimized variant.
  algorithm terminates  soon   finds  .
balanced cycle.  graphs    variant  fast.
 exactly     typically returns  level.
cycle   separator.   graphs,  variant.
 computes  component tree  level cycles, .
  perform  primal bfs   search  .
fundamental cycle separator.  graphs  skewed.
aspect ratio,   egg,  cylinder, dual bfs levels.
 necessarily small, hence  exists  level cycle .
forms  short, balanced separator.
interestingly,   extremely rare   unoptimized algorithm resorts  shortcutting  fundmental.
cycle separator using cycle levels.  infrequent outcome accounts   disproportionate amount   algorithm. complexity .conceptually,    much .
lines  code.,   required  providing  worstcase guarantee.  implies  complementing .
fcs algorithm  computing level cycles ., computing  dual bfs.     useful  efficient.
simple cycle separator heuristic.
figure . .right. shows   balance-optimized.
variant   algorithm  shortcut fundamental.
cycles using level cycles   starting faces  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
 .
 .
 .
 .
 .
grid rect.
egg globe.
hex c-grid.
cylinder.
diameter.
.
.
.
.
.
graph type.
 .
 .
 .
 .
 .
 .
grid rect.
egg globe.
hex c-grid.
cylinder.
diameter.
.
.
.
.
.
graph type.
figure .  type  separator returned   algorithm . unoptimized .left.  optimized  balance .right.
  graphs used  figure . teal corresponds  fundamental cycles .line .  algorithm ., dark blue .
level cycles .line .,  purple   fundamental-and-level cycle merger .lines .
egg graph      globe graphs.  .
instances,  time spent  shortcutting  fcs  .
little less   time spent  finding  fcs.
figure . shows  running time   function .
 size  various square grids.  expected, .
fcs   algorithm appear  scale linearly  .
number  vertices.  change  minimum running.
time around . million vertices    likely.
attributed  caching effects. ,  see  ,.
 average,  algorithm takes    twice.
 long  fcs.  slopes   lines  best-fit.
.  .   algorithm  fcs, respectively.
suggest   algorithm tends   . times slower.
 fcs.  shown  figure ., one might .
 run fcs several times  locate  separator .
size  balance within  guarantees provided  .
algorithm. therefore,  consider  runtime  .
algorithm   competitive.
. separator balance  size. figures .
 . show results  balance  size, respectively.
 graph tested .except  colorado.  approximately .,. vertices   triangulated.  particular, grid  .  ., rect  .  ., egg  .
.  . globe, globe  .  ., hex  .  .,.
c-grid  .  ., tri  ten iterations, cylinder .
.  .,  diameter  diameter .
 figure .,  see  unoptimized fcs never.
produces significantly  balanced separators .
 unoptimized algorithm. however,   graphs.
egg, cylinder, tri,  diameter,  algorithm produces nearly perfectly balanced separators every time,.
whereas fcs tends  find separators   .
balanced. recall  figure .   discussion .
,   graphs,  algorithm typically returns.
 level cycle   separator. since candidate level cycles  searched  starting   median.balanced.
level .level .  section .,  since   graphs,.
bfs levels consist   edges,  algorithm finds small.
level cycles   nearly perfectly balanced.  .
verified  optimizing  algorithms  balance .
taking   balanced separator encountered. eliminates  differences. note, however,  optimizing.
fcs  balance   guaranteed  return  short separator.  fact,  cylinder graphs,   often .
case.
figure . shows    test cases, .
algorithm returns slightly longer separators  fcs,.
 still well  .
.
. guarantee. however,.
 egg  cylinder graphs, fcs often produces.
separators whose length  well   guarantee.
,  focus   classes  graphs   fcs.
performs poorly.
 understand  extent   fcs performs.
poorly  cylinder graphs,  compute  percentage.
 viable starting vertices . fcs.  faces . .
algorithm.   .  . cylinder. figure .  .
graph   cumulative frequency diagram  separator.
size.  results  shown   unoptimized variant.
  algorithm,   three variants  fcs. .
unoptimized  shortest.balanced versions previously.
described,   randomized version   shortest.
balanced heuristic.  randomize fcs,   level .
constructing  bfs tree,  shu.  order  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .
.
 .
.
.
 .
.
.
number  vertices .
figure . runtime . cpu clocks. versus number .
vertices  square grid graphs   algorithm .red.
 fcs .blue.
vertices  processed.  heuristic  one  .
studied  .
 algorithm reaches . well   guaranteed.
.
. size bound,   versions  fcs .
many poor choices  starting vertex.  implies .
one might need  try fcs several times  locating  viable separator. note , especially  .
shortest.balanced randomized version  fcs,  expected number  attempts  small .less  two.
. conclusions.
  paper  described  implementation   simple cycle balanced separator algorithm  planar graphs.
 proven worst-case guarantees   separator.
size.   best   knowledge,    algorithm    implemented  guarantees .
simple cycle separator   fundamental cycle separator algorithm. however, unlike  algorithm, fcs.
  provide worst-case size guarantees.
 experiments show   running time  .
algorithm  comparable    fcs   instances.
 demonstrate families  graphs    algorithm finds extremely small separators,  fcs often finds separators   much larger  even .
worst-case guarantee   algorithm. however, .
fcs  optimized  returning  shortest balanced fcs,.
 employs randomization   construction  .
bfs tree,  finds  small separator  high probability. note  using heuristics diminishes  attractiveness   fcs algorithm,  stems   simplicity, whereas  algorithm performs well without .
optimizations  heuristics.  interesting conjecture .
 context   fcs works well  constant prob .
 .
 .
 .
 .
 .
sqrt. .  .  .  .
.
.
.
.
.
separator size.
figure . x-axis. separator size. y-axis. percentage  starting vertices achieving  separator   .
 size. comparing  algorithm .teal., shortest.
balanced randomized fcs .red., shortest.balanced deterministic fcs .green.,  unoptimized deterministic.
fcs .dark blue.
ability   input graph,   probability  .
 choices  bfs trees .choice  root  well  choice.
 order   nodes  visited.
  observe   algorithm seldom requires  somewhat complicated last phase,  combines  long fundamental cycle  short level cycles.
 produce  short separator.  almost  test instances,  algorithm returns either  level cycle  .
fundamental cycle   short separator.  implies.
 complementing  fcs algorithm  computing level cycles ., computing   primal .
dual bfs.     useful  efficient simple cycle separator algorithm .albeit without  theoretical.
worst-case guarantee.
 conclude   algorithm   viable alternative  fcs  outperforms   certain cases.  believe  optimizations    studied  holzer.
 .   enhance  performance.
 interesting direction  future work  implementing  separator algorithm  .,   quite.
similar   algorithm discussed   current paper.  implementation   algorithm  .  .
used  compute .divisions  asymptotic linear time.
   interesting  see  well  algorithm.
actually performs  practice.
acknowledgements.
 work originated  mit course .  .algorithms  planar graphs  beyond.  authors.
 like  thank erik demaine  philip klein .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
 .
 .
 .
 .
grid.
rect.
globe.
egg.
cylinder.
hex.
c-grid.
diam.
eter.
tri colorado.
.
.
.
.
 .
.
.
.
graph type.
. separator balance .number  vertices  smaller part.
divided   total number  vertices.   unoptimized.
algorithm .red.  unoptimized fcs .green.
sqrt.
 .
 .
 .
 .
 .
 .
 .
grid.
rect.
globe.
egg.
cylinder.
hex.
c-grid.
diam.
eter.
tri colorado.
.
.
.
.
 .
ize.
graph type.
. separator size divided .
.
   unoptimized algorithm .red., unoptimized fcs .green.,  shortest.balanced.
fcs .blue.
figure . separator balance  size  various graphs.
fruitful discussions. additionally,  thank philip klein.
  team  providing    planar graph.
library.
  partially supported   swiss national.
science foundation. work  conducted   .
 mit.   partially supported  national science.
foundation grants ccf-.  ccf-.
</doc>
<doc title='4_ALENEX_30.txt'>
downloaded  knowledgecenter.siam.org.
polynomial-time construction  contraction hierarchies.
 multi-criteria objectives.
stefan funke . sabine storandt.
abstract.
 consider multicriteria shortest path problems .
show  contraction hierarchies .   powerful.
speed-up technique originally developed  standard.
shortest path queries  . .   constructed efficiently   case  arbitrary conic combinations.
  edge costs.  extends previous results .
.  considered   bicriteria case  discrete weights   objective functions.   theory.
side  prove  polynomial time bound  determining.
whether  path   part   lower envelope  .
pareto-optimal paths via  polyhedral arguments.
experiments complement  results  showing .
practicability   approach.
. introduction.
 many routing applications  objective  .
described sufficiently    single weight  .
edges.  example,  driver  certainly keen .
reaching  destination  quickly  possible, .
 might  also interested  keeping  fuel costs.
low .see figure .   illustration. similarly, .
planning  bicycle trip one    interested  .
length   trip  also wants  avoid steep climbs.
   time   conflicting objectives,  ,.
minimizing  values . travel time  fuel costs,.
 distance  positive height difference.   .
time  impossible. therefore one either aims   fair.
trade-off   values  searches   path .
minimizes one   values    exceed  given.
bound   .
  first case  typically ask   minimum.
cost path   conic combination   edge costs,.
. given  .graph .,.  edge weights ., . .
 . .  optimal path  . , . . . ,   given.
., . . .   one minimizing .
 call  problem  conic combination shortest path.
.ccsp. problem.   coefficients ., .  known.
beforehand,  problem reduces   single edge.
.fmi, universita. stuttgart, . stuttgart, germany,.
stefan.funke.fmi.uni-stuttgart.
.institut . informatik, albert-ludwigs-universita. freiburg,.
. freiburg, germany, storandt.informatik.uni-freiburg.
figure . alternative paths   saarland graph. .
purple path  optimal  terms  travel time .min.,.
   highest fuel costs . .  black path.
 minimal fuel costs . .,  needs time .min.
 red path   fair trade-off  costs  .  .
travel time  .min.
weight case   available algorithms  speedup techniques   scenario apply  well.  .
conic combination  revealed  query time , still.
dijkstra. algorithm   applied   straightforward.
manner.  larger .street. graphs plain dijkstra  .
slow   applications, though. hence . like .
conventional shortest path computations . developing.
preprocessing techniques  speed  query times seems.
worthwhile.  conic combinations  edge costs .
 considered first  .  present  variant .
 speed-up technique contraction hierarchies .
 accelerate query processing.  approach .
 limitations, though.    compute paths.
optimal .
.
. . .  integral .  .
prespecified interval ., .  course, choosing .
interval large enough  restriction  discrete values.
appears neglectable.  interval size influences .
runtime   preprocessing, though, hence especially.
 large street networks     small  allow .
reasonable preprocessing times. moreover  authors.
combine    approaches like landmarks .
. copyright . siam.
unauthorized reproduction   article  prohibited.
 achieve  reported overall speed-up.   unclear.
  choice     influences  performance.
  combined algorithm.  far,   consider.
 combination  two edge weights.
  second case . minimizing one metric .
putting  limit    .   faced   instance   constrained shortest path .csp. problem,.
  np-hard  general.  adaption   .
 scenario  presented  .   shown .
 query time  space consumption   significantly reduced  employing  variant  . .
 turns   even  street graphs  millions.
 nodes  edges,  optimal solution   computed within reasonable time .  seconds.,  query.
times  still far   millisecond range   .
achieved  ordinary shortest path queries. hence  .
worthwhile  aim   approximate solution, . .
applying binary search . ,  sequence  ccsp.
queries  varying conic combinations quickly lead .
good approximate solutions   csp problem. .
speeding  ccsp queries provides  automatically.
 faster algorithms  obtaining approximate csp.
solutions.
. related work     query variants.
  solved  constructing  set  pareto-optimal.
paths . path  pareto-optimal,    paths .
worse according   least one   objectives.
one approach  compute  set  presented .
.  authors call  method pareto-sharc, .
   combination  shortcut insertion .one  .
crucial ingredients   construction.  arc-flags.
. unfortunately,  approach   practically.
feasible   moderate number  pareto-optimal paths.
 source  target.  general, exploring .
complete set  pareto-optimal paths seems  really.
practical.
 notions  flexibility  considered .  .
context  computing alternative routes .  taking.
 account edge restrictions .like avoiding interstates.,.
.  seem somewhat orthogonal   view taken.
  paper.  exist various speed-up techniques.
besides    conventional shortest path problem.
. like transit nodes .  reach . .  might .
useful  accelerate query processing.  shown .
.  ., even  considering   one.
metric street networks maintain  certain hierarchical.
structure. hence   good reason  hope .
improved query times  adapting one   speedup approaches also   multicriteria case.
. contribution  contributions   paper.
  following.  refine  enhance  adaptation    preprocessing techniques   .
 bicriteria objectives,  also multicriteria objectives  arbitrary weight coefficients  .  .
considered.    theoretical side  prove via.
 polyhedral considerations  deciding whether.
 shortcut  necessary   decided  polynomial.
time.    obvious   number  paths .
 boundary   convex hull   pareto-optimal.
solutions might  exponential  general.  results.
 complemented  experimental results  show.
  approaches work well also  real-world data.
. preliminaries.
 constrained shortest path problem .csp.  two.
dimensions.metrics  characterized  follows.  .
given  .graph .,. . . . , . . .,  cost.
function  .  . .   resource consumption.
function  .  . .   edges.  query  specified.
 source  target nodes ,  .   well   resource.
bound  . .  goal   determine  minimum.
cost path     whose resource consumption .
 exceed .   path  always pareto-optimal,.
.,   path . exists  lower costs  lower.
resource consumption.  set   pareto-optimal.
paths   source   target node equals .
set   optimal csp solutions . different resource.
bounds.
exact algorithms like label setting . explore  set.
 pareto optimal paths  search   best path.
satisfying  resource constraint .   time- .
space-intensive procedure.   application context,.
one  often satisfied   approximate solution .
  found  quickly.  common idea  .
 consider   subset   pareto-optimal paths,.
namely  ones forming   called lower envelope.
 lower envelope   illustrated  follows. .
 path   .   respective costs  .
 resource value.  tuple ., .  .
represented   line segment.
. . . ., . . ., .
 s-t-path  lies   lower envelope,   exists .
. . ., .   .  minimal among.
 s-t-paths .see figure . paths   lower envelope.
  advantage   easily computable  fixed.
.   simple dijkstra run  .,.  edge costs.
. . . . . . refer   respective graph.
also  . note    conic combination .
parameters ., . .   exists  value  .  leads.
   minimum cost path, namely . . .
  paths   lower envelope  exactly .
ones   interested   answering ccsp queries.
another common view    problem    r-c.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
.
. .
figure .  lower envelope .dashed red.  formed.
  three black line segments.  blue line also.
represents  pareto-optimal path    part  .
hull.  path corresponding   green line  .
pareto-optimal.
plane   path  represented   point  .
.according   resource  cost values.   paths.
  lower envelope  exactly  ones  lie .
 lower left boundary   convex hull   paths.
 binary search algorithm provides approximate csp.
solutions  iterating   slopes  paths  .
lower envelope. ,  edge cost values must .
positive, discrete  bounded   constant  .
 shown  .  provides  lower bound  .
  difference   two distinct slopes. hence .
binary search algorithm .see alg. . terminates .
.log. rounds   polynomial   input.
algorithm . binary search.
. . .
. . .
 . . . . . .
. .
compute optimal path   edge costs . .  . .
 . .  .
break.
end .
 . .  .
. . .
else.
. . .
end .
end .
 csp problem   generalized  higher.
dimensions  assigning multiple resource values  .
edges  revealing bounds      query.
time. details   scenario will  given along .
 respective  construction  section .
.,. .,.
.,.
.,.
.,. .,.
.,.
.,.
.,.
.,.
.,.
figure . node contraction step.  removing .
red node,  paths      remaining.
nodes    preserved.   upper example .
reference path .black.  pareto-optimal,    .
   blue   green path form together  witness. hence  respective shortcut   omitted. .
 lower image  reference path must  shortcutted.
.realized   purple edge.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
contraction hierarchies .  speed-up technique  shortest path computations  introduced .
.   based   augmentation   graph .
shortcuts  allow  disregard  lot  edges  query.
time.
  end,   preprocessing phase nodes  sorted.
according   notion  importance. afterwards .
nodes  removed.contracted one  one   order,.
 preserving  shortest path distances   remaining graph  inserting additional edges . called.
shortcuts.  precisely,  contracting  node .
 every path uvw  distance     must remain   even  contraction  . hence .
edge  . .,.    added    shortest path.
     uvw.  cost   equals  chained.
costs   edges ., .  ., .   exists  path.
 cost less   cost  uvw .   called witness.
path .  shortcut   omitted.   witness path.
 typically found via  dijkstra run    . .
 nodes   removed,  new graph .  created.
consisting   nodes  edges   original graph.
  shortcuts.  edge  . ., . .original  shortcut.  called upwards   importance    smaller.
     downwards otherwise.  .  every pair  nodes     exists  shortest path.
       subdivided   upward .
 downward path .  order. therefore s-t-queries.
  answered bidirectionally,   forward run.
.starting  . considering  upward outgoing edges.
  backward run .starting  . considering exclusively downward incoming edges.
note   contraction process    .
 completed   end  ensure correctness. instead.
  abort  process   point  time .
assign  importance value  .   uncontracted.
nodes. declaring  edges   uncontracted.
nodes  up-  downwards maintains  upwardsdownwards characteristic  optimal paths  allows.
  application  bidirectional dijkstra   chgraph. incomplete contraction  often used  limit.
 total number  inserted shortcuts  will come .
handy   application  real-world data later .
  scenario  conic combinations  .
metrics,    make sure    contraction process  paths   lower envelope  preserved .see figure .  two small examples.  .
following  will provide efficient witness search procedures   . .   denoting  number  edge.
weights  consider.
.  .-dimensional case.
  section  present   construction scheme.
 allows  answering ccsp queries  two metrics   edge.  particular  means   reference path  . , ,   costs .  resource.
value .    preserved .  shortcut.,  .
exists  .-value  ., .     minimal costs.
 . therefore   way  omit  shortcut .
identifying  set  alternative  . w-paths ., . . . , .
  lower envelope   .  naive way.
 search    family  witnesses  selecting .
set  .-values . randomly  equally distributed.
 ., . ., . . . , ., compute  respective optimal.
paths .  .
. via  single dijkstra run   check.
  resulting collection  paths expells   .
lower envelope.   easy  implement,  approach suffers  several disadvantages.  one hand.
many . support values might lead    path,.
hence spending time  redundant computations. .
  hand .  much  severe .   lower.
envelope  ., . . . ,     ,  . know.
whether  shortcut  necessary    omitted. .
guarantee exact query results  essential shortcut .
 left , hence   case  shortcut    inserted  additional .-values    tested. adding.
 many .superfluous. shortcuts slows   preprocessing time  query processing later , hence.
  avoided  possible. requesting new .-paths.
 long   result  inconclusive might become .
time intensive.  now describe  approach,  overcomes    disadvantages.  fact  witness.
search procedure also relies  choosing  suitable .
values,   will describe  way  select  values.
carefully  .
. every new .-value leads   discovery   new.
path   lower envelope,.
.  termination   certify whether  shortcut  needed  ,.
.  overall runtime  polynomial   input size.
. witness search  basic idea   approach.
 somewhat similar   binary search algorithm, .
 every step  will  least halve  interval  .
relevant parameter. however  contrast  conventional.
binary search,  . want  compute  certain path.
  lower envelope .  want  check  .
reference path  . , ,   part     .
  end  start  . . .  compute .
respective optimal path .   . .  know .
  contained     therefore  shortcut.
 necessary.  instead . dominates ,  found .
witness consisting   single path. hence  shortcut.
  omitted  sure.     cases .
witness search  already conclusive    done.
 neither   cases applies,  must exist .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
intersection point   line segments representing .
 .   . . ., . accordingly   split.
 interval  . ., .  two continuous subintervals.
., .  . representing  .-values   .
segment  . lies   one    vice versa.
 .   . . .  already know   will .
  minimum cost path,  . dominates   .
interval. hence   sufficient  continue  witness.
search  . . observe  .  cover .
  half  ,   . . .  path . .
   sure. now   repeat  procedure.
 selecting  new . support point   center .
 interval ., see  pseudocode  algorithm . .
 procedure always maintains  interval   .
reference path  still .alive., .    previously.
identified paths.   interval runs empty  shortcut.
  necessary     part   . .
 .,  search will     find  . value .
reveals  .see figure .   example. therefore .
search procedure always provides  conclusive result.
algorithm . witness search.
input.  . , ,  reference path.
output. true  false.
.insert shortcut .,.  .
low . .
upp. .
 true .
. .upp. low.
get optimal . path . . , . . . , .
via  dijkstra run  .
  . . .
return true.
end .
   dominated  . .
return false.
end .
. . . .
. . . . .
 . . .low, upp. .
return false.
end .
 . . . .
low . .
else.
upp. .
end .
end .
 remains  show   witness search algorithm terminates   polynomial number  iterations.
  purpose  prove  two distinct corner.
points    . intersection points  paths .
figure . example   witness search procedure.
 reference path   given  blue.  green.
box indicates  remaining interval    blue.
segment might still  part   lower envelope .
 brown cross denotes  path    .
optimal   actual .-value .red dashed line. .
purple cross represents  intersection point   .
therefore  new interval boundary.   last image.
 blue path  identified  optimal  therefore.
proven     .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .   certain minimal distance. therefore .
 abort  process . insert  shortcut.  soon.
  interval covers  range smaller  twice .
distance. like   binary search algorithm,  assume   cost. resource values  positive integers.
 bounded   . maxe. max., .   .
 path     ., . two  paths   .
  form corner points  .  line .segment. representing  . analogue  ., .  .
described .
. . . . . .
accordingly  .-values   intersection points .
given .
. .
. .
. . . . .
.similar  .   .  cost   resource.
value must differ   least ., . . .   values.
corresponding  . .   integers.,  difference.
  two . values   expressed .
. . . . . .
. . . . . . .
.
. . . . . . .
clearly  numerator must  . .,   denominator  bounded  .   represents .
maximal possible cost .resource consumption   path.
hence  difference   .-values   two.
corners  bounded  .
.
.
.
.
.   interval .
  reference path   .alive. gets  least halved.
 every iteration,  will reach  lower bound  .
logarithmic number  rounds.   round requires.
 computational effort   dijkstra run,  end .
  total runtime  .log. log .
.  bicriteria  multicriteria shortest.
paths.
  general, multicriteria constrained shortest path.
.csp. problem  edge  bears  cost   resource consumptions . , .
.
 , . . . , .
.
 .  csp problem   find  given source  target ,   path.
 . . . . .   . .    .   edges.
 . ., .  minimizes  cost.
.
. cei .
 path  satisfying . . resource constraints.
.
.
rjei . .
 ,  added resource consumptions   jth.
resource along  path   exceed  .
 csp problem  known   np-hard .
general,  known exact solutions .like  standard.
dynamic programming approach. essentially optimize.
  pareto-optimal paths.  surprisingly, .
pseudo-polynomial bounds  known   number.
 pareto-optimal paths  need   examined.
  reason  drop  hard resource constraints  instead optimize  conic combination .
cost  resource consumptions.  boils  .
optimizing   subset   pareto-optimal solutions.
. namely  solutions   boundary   convex.
hull   solutions .    path  represented   cost  resource consumptions.  path.
 . ., ., . . .     boundary   convex hull.
  pareto-optimal solutions   exist ., . . . .
.
.
. . .  .
.
cost. .
.
.
cost.
   paths . .
cost. . .
.
.
. .
.
.
.
.
.
represents  aggregated weight   edge costs .
resource consumptions   conic combination given.
  . intuitively speaking,  path   .
 boundary   convex hull   pareto-optimal.
paths   exist .     optimal .
 aggregated weighting  edge cost  resource.
consumption.
  respective dual view,  path   cost cpi.
 respective resource consumptions ripi,  . ., . . . , .
. corresponds   hyperplane.
hpi .  . .
.
.cpi .
.
.
.
.
 .  example   . .  path   cost cpi .
resource consumptions ., .
.
 determines  plane.
hpi .  . . . . .cpi . . . .
 .    path  lie   boundary.
  convex hull   pareto-optimal solutions.
consider  possible paths      .
respective hyperplanes.  path  lies   boundary.
  convex hull   pareto-optimal solutions iff.
 respective plane bounds  lower envelope  .
hyperplanes . fact  two view considered  .
dual   .
  following  will device  method  decide .
polynomial time whether  hyperplane corresponding.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
  given path  bounds  lower envelope  .
hyperplanes   paths. note   seems nontrivial   general superpolynomially many paths.
might appear   boundary   lower envelope.
 high-level idea   proof   follows.  first.
show  vertices   arrangement  hyperplanes.
  certain minimum pairwise distance.  .
 used  derive  lower bound   hypervolume .
facets   lower envelope.   algorithm decreases.
 hypervolume   facet corresponding   path.
   lower convex hull   constant factor .
 round, polynomially many rounds suffice  decide.
whether  bounds  lower envelope.
. bounding facet hypervolumes   arrangement  hyperplanes   assume  .
cost   well  resource consumptions .
.
   edge.
 integers   range ., . . . , .
 first want  show  vertices . points .
intersection  .  hyperplanes.   arrangement.
 hyperplanes   certain minimum distance. .
vertex   solution   system  .    linear.
equations corresponding   respective hyperplanes.
 i-th coordinate    vertex   computed.
according  cramer. rule   .
det.
det.  .
 formed  replacing  i-th column vector  .
 .   assumption  costs  resource.
consumptions  bounded     edge, .
respective costs.consumptions   given path .
bounded   . hence,  two vertices differ  .
i-th coordinate,  differ   least .
.
.
.
.
.
 non-degenerate,  . . dimensional facet .
 lower envelope hence   hypervolume .
.
.
.
. .
.
.  goal   check whether .
 . .-dimensional hyperplane corresponding   path.
 supports  facet   lower envelope.  facet.
hpi corresponding     hypervolume  .
. .ignoring   paths.hyperplanes.  .
.  restricted  ., .     guarantee.
  hypervolume   facet hpi decreases  .
constant factor .   round   algorithm,.
.log.
. . . . log.nmd. rounds suffice.  will exhibit   decrease  hypervolume.
  respective facet   constant factor   following.
. cutting facets    large pieces.
given  facet fpi corresponding  path    lower.
envelope   subset   paths,  want  certify.
 either . fpi appears   lower envelope even.
   paths  considered  . find  path.
. whose corresponding hyperplane cuts   least .
constant fraction  fpi. hypervolume. certifying . .
naturally achieved  exhibiting .  make  .
optimal path   respective aggregated weight.
certifying .   example achieved  choosing.
appropriate .    hyperplane   path.
corresponding   choice   . cuts fpi  two.
pieces  comparable size.
  following  will work towards  goal .
several steps. first  show    . . dimensional.
facet contains  simplex  comparable hypervolume.
  choose .    hyperplane  .
optimum path   . divides  inscribed simplex.
 two pieces, none     small.
.
.
.
.
.
.
.
figure . illustration  theorem .   . . .
 image ,    corner points   convex.
polygon   maximum pairwise distance.  point.
   corner point  .    maximum.
orthogonal distance towards pipj .  gray rectangle.
 contains  ,  triangle   area exactly .  .
 hence also  least .   area   . combined.
 theorem .   guarantee   half-plane.
  centroid   triangle .orange dot.  .
boundary contains  least  third   triangle. area.
 .   area   .
. inscribing  simplex   polytope given.
 .-dimensional polytope  . ., . . . , ,  aim .
inscribing  simplex    hypervolume   least.
 constant fraction   hypervolume   .  .
end  construct    simplex  .   also .
.-orthotope . higher dimensional rectangular box.
    .    . . . . .
implies   . . . . .   following.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
greedy approach.
 ., .   two vertices    maximum pairwise distance.  define  .-dimensional simplex .
 two walls   namely  hyperplanes orthogonal.
 . clearly,   contained   two hyperplanes.   next step  construct .  selecting .   corner    maximum distance  .
affine hull  .  .   point   affine.
hull  .   .  orthogonal   affine hull.
 .  next two walls     one side  hyperplane  . orthogonal .
.    .
side   hyperplane mirrored   affine hull .
. ,   clearly contained   two.
walls .  continue  process  finally construct.
 . .   collected  . walls  .
. .-orthotope  .see figure .   example  three.
dimensions.
obviously,  holds .
. .  . .
 furthermore.
 . .
 .
. .
 .    . .-orthotope     .
dimensions halved.  also .
 . .
.
.
 .
theorem . follows immediately.
theorem .     .-dimensional polytope.
  . ., . . . , .  inscribed  . .-simplex derived   algorithm described .   .
 . .  . .
. . .
. cutting  simplex  .,  median   triangle   segment connecting  corner   midpoint.
  opposing side.  three medians   triangle.
intersect   common point,  centroid.   .
centroid   d-simplex   intersection point  .
segments connecting  corner    centroid  .
opposite,  . .-dimensional face.  following simple.
theorem will prove useful   later .
theorem .     d-simplex,   centroid .
  arbitrary . dimensional hyperplane containing.
.   subdivides   two d-dimensional polytopes       hypervolume   least.
 .
.
.
proof.   look   .-dimensional case first. ,.
 medians , ,  intersect   centroid  ,.
.
.
.
 .
.
figure . medians  centroid   triangle  .
, ,    midpoints   respective edges, .
medians ,, intersect   centroid. ,,.
  divided   centroid  two pieces  ratio.
. . .
furthermore    medians  split    ratio.
. . . hence,  areas   triangles .abm .
.abc also behave like . . .   triangle formed.
  edge   triangle   centroid  exactly.
.   area   whole triangle. see figure . .
 illustration. note   medians also partition.
 triangle  . triangles  equal size. now consider.
 hyperplane  .line.  . passing   .  must.
  least .   . triangles  either side, hence.
 subdivdes  triangle  two pieces,   .
 area  least .   whole triangle.
  dimensions,  centroid    d-simplex.
. divides  medians   ratio . . .   ddimensional simplex   formed   face  . .
   hypervolume  .   total hypervolume.
  original d-simplex. consider  opposing.
. .-dimensional face   corner    d-simplex.
 centroid partitions    many . . .-simplices.
 equal hypervolume.    together .
 centroid    original d-simplex forms  small.
d-simplex  hypervolume exactly .   original.
d-simplex.  hyperplane   must  .
least one corner  .  either side.  claim  .
hyperplane    intersect  interior.
   small d-simplices . hypervolume . .
adjacent   corner  . assume  opposite, .
 hyperplane must properly intersect  interior.
 segment   contradicts  fact  .
hyperplane passes   .  theorem follows.
   theorem help  decreasing .
hypervolume   facet fpi corresponding   path .
 choose  .    hyperplane  .
optimal path .   choice   . intersects .
centroid   inscribed simplex  fpi  lies .
 shortest path computation   weights either.
certifies   appears   facet   lower envelope.
 another path .  exhibited  cuts   least.
.   simplex  inscribed  fpi  hence  least.
.   facet fpi.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. algorithm   summarize  algorithm .
larger,  fixed dimension    following.  .
given  path   cost cpi  resource consumptions .
.
.
  interested whether   choice   .
 hyperplane corresponding      boundary .
 lower envelope   paths.  consider  path .
  d-dimensional space spanned  ., . . . , . .
 aggregated weight. since  .  non-negative.
 restricted  sum   .  ,  relevant facet.
fpi   lower envelope   explicitly computed. .
 proceed  follows.
. construct  inscribed simplex sfpi  fpi.
. construct  centroid  sfpi.
. use  first  . . coordinates   centroid .
determine . values.
. compute  optimal . t-path .  edge costs.
weighted according   .
.  . .  report    part   lower envelope.boundary   convex hull   paretooptimal solutions  exit.
. otherwise intersect  facet fpi   halfspace.
  hyperplane hpi. corresponding  .
. .
obtain  new facet fpi.
.  fpi disappears, report     part  .
convex hull   pareto-optimal solutions  exit,.
otherwise   step .
 figure .  initial steps   . .   . . .
illustrated  comparison.
according   discussion,  hypervolume .
 initial facet  bounded  decreased   constant factor   round, hence  total number .
iterations  . log.nmd.  . . . . .
 therefore polynomially bounded . constant .
 runtime   single iteration step  determined.
  dijkstra run  compute  optimal plane  .
given . .vector.   computation   corners.
  new facet    reference plane  still.
.alive.     number  hyperplanes identified  far .including  one corresponding  . .
naive way  perform  computation   construct.
.
.
.
.
.
corners   arrangement   hyperplanes.
 hyperplane hpi corresponding   ist still part .
 lower envelope iff  corner involving hpi lies .
    hyperplanes.  corners  facet fpi.
 exactly  corners involving hpi   .
    hyperplanes.  corner   computed via gaussian elimination  .   realram.
hence  rough bound   overall runtime  given .
. log.nmd. log. . . logd.nmd.
. robustness.
  concrete implementation,   assume exact.
arithmetic  real numbers hence one    careful   compromise correctness   implementation based  floating point arithmetic.   case,.
though,   easily ensure correctness  employing  interval version  gauss elimination.  corners   coordinate intervals   .
test   take  interval boundaries  account,.
 ,   claim  facet fpi    part  .
lower envelope,   corners involving hpi   .
 constraints even  terms   interval representation.  moderate dimensions,  coordinate.
intervals  typically still  acceptable size.   . log.nmd. iterations  facet   disappeared,  simply construct  shortcut  hence.
never compromise correctness   procedure.
.  generalizable binary search approach.
 far,  developed  construction scheme  .
 allows  answer ccsp queries   resulting.
graph.   outlined ,   also like  answer csp queries  least   approximative manner.
  . .
note,  obtaining   solution via  binary search.
like algorithm    simple    . .  .
exists  feasible solution   bicriteria problem .
 path  exceeding  resource bound.,   always also  least one path    fulfilling  criterion, namely  one  minimal resource consumption.  path   easily identified via  single dijkstra run considering resource values .   . .
 observation   longer true.  feasible solution.
might        . t-paths without.
    feasible  well.  nothing  .
guaranteed  restricting  path search   ones.
  . nevertheless  will propose  algorithm.
 searches systematically   feasible path  .
.   procedure  adapt  idea   witness.
search algorithm.  fact  will use .imaginary. reference paths  check    part   .
 start   plane  described   .
., ., ., . . . , . clearly,  feasible solution must.
dominate  plane.   run  witness search routine    reference. three possible outcomes must.
 considered. first,  reference plane  part  .
.  means   exists  feasible solution .
     abort  search. secondly,  reference plane might  dominated   single  plane.
  case  found  initial feasible solution. third,.
 explored part    might dominate   none.
  single planes.   result  inconclusive  .
now.  proceed   second  third case  reset. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . .
. .
.
. .
.
.
.
. .
.
.
.
figure . binary search   lower convex hull  . .left.  . .right.  reference path   represented.
  blue line.triangle.  gray dot indicates  initial .-vector.  leads   detection   new.
path  .represented   green line.triangle.  intersection point.line     determines  new facet.
    considered.  projection .brown. implies  new reduced search space,   next . support.
point .red.  chosen.
ting  costs   imaginary plane  halving .
now  apply   witness search procedure. .
 imaginary plane  matched exactly   real one,.
  abort  search.   identify  new reference.
plane  part   ,  know    smaller.
cost value  plane will also    . hence .
   consider larger cost values   remaining.
search.     hand  plane  dominated .
 ,   must  true   larger cost values. choosing  next cost value always   mean.
  remaining interval boundaries,   halve .
interval  every step.   possible cost values.
 integers,  provides    maximal number .
log. iterations  therefore  overall polynomial.
runtime .  proved    witness check runs.
 polynomial time.  output   algorithm  .
feasible plane  minimal costs   found .
 witness search .    plane  identified  .
 illustration   algorithm  two dimensions .
 found  figure .
. experimental results.
 implemented   construction scheme  two.
 three edge weights .  . .   . .  evaluated   real-world data.  used test graphs .
 saarland,   hessen,   baden-wu.rttembeg .
cal  california.  based  openstreetmap data.
 implementation  written  ., timings .
taken   single core   intel core . cpu.
 .ghz  .  ram.
. metrics  considered  metrics euclidean.
distance ., travel time ., fuel costs .  .quietness.
.  euclidean distance  obtained  considering.
 latitude  longitude   nodes,   connected via  road segment.  estimating travel times.
 used  street tags provided   openstreetmap.
data  assigned  typical speed   road type.
 explicit speed profile along   distribution .
 road types   test graphs   found  table.
. fuel costs  calculated  suggested  . using .
gas price   . per liter.  measuring .quietness.
 assigned penalties  streets   high maximum.
speed,  particular roads   estimated speed .
 . . received  penalty  .,  .  .
.  penalty  .   .motorways.  penalty.
 . per metre.   following  will present results.
  features   created ch-graphs  compare.
query times   without applying   several.
metric combinations.
. bicriteria paths . . .   bicriteria.
case,  first used  metric combination travel time.
.  fuel costs .   test graphs.  respective experimental results  computing   .
 metrics   found  table . note  .
 contracted  .   nodes  .
shortcut creation  amongst  remaining nodes .
  large number  pareto-optimal paths,   complete contraction   added   large number  shortcuts . slowing   preprocessing .
query processing.  first two columns show  number  nodes  edges   used test graphs .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
road type speed edge ratio.
.    cal.
motorway . . . . .
motorway-link, primary.-link. . . . . .
secondary.-link., tertiary.-link., trunk.-link. . . . . .
unclassified, residential, road . . . . .
living street, service, path . . . . .
table . considered road types .extracted  openstreetmap. along   estimated speed  .
distribution   types   test graphs.
. nodes edges dijkstra  preprocessing  query.
polls time. time. edges polls time. speed-up.
 . . . . . . . . . .
 . . . . . . . . . .
 . . . . . . . . . .
cal . . . . . . . . . .
table . characteristics   used test graphs along  experimental results  speeding  queries  .
query times   poll numbers  averaged  . random queries   weight parameter . .
chosen .  ., .   query.
applying .  next two columns show  plain dijkstra performs   graphs, exhibiting query times.
 two seconds  california.    construction  provide  preprocessing time,  naturally.
increases   graph size   resulting number  pareto-optimal paths. note   maximal.
number  iterations   single search step   .
 california.  number  shortcuts added    number  original edges, hence  resulting.
ch-graph    twice  size   original.
one.   last columns  present  number  poll.
operations  query times using bidirectional dijkstra.
  augmented ch-graph.    values decrease dramatically compared  plain dijkstra, leading.
 query times    milliseconds   speed-up .
two orders  magnitude.  speed-up  bicriteria.
paths reported  .  comparable  even better .
,     pure   applied  also.
 adaption  landmarks  top. moreover  used.
weight parameters  integer values  .chosen .
 predefined interval.   preprocessing times .
longer.
 figure .  differences  several metric.
combinations  noticeable. metrics   somewhat similar . like euclidean distance  travel time .
produce less shortcuts  therefore better query times.
 contrast  ,  .quiet. metric considered  .
  lead   different paths  comparison.
  shortest  quickest one,   edges.
 low speed limit  preferred.   result .
number  ch-edges   . million . . higher.
 query times   ch-graph increase   factor.
. bin. search  bin. search.
time. time. speed-up.
 . . .
 . . .
 . . .
cal . . .
table . experimental results  running binary search.
  original   preprocessed graph  minimizing travel time limiting  distance.  resource.
bound   chosen  . times  minimum possible distance .computed   conventional dijkstra run.
query times  averaged  . random queries.
 .  .  .,   run times.
  conventional dijkstra algorithm  relatively.
unaffected   choice   metrics. still  yields.
 speed-up  factor .   combination  travel.
time  quiet metric   ch-graph . . .
.
table . shows  query times   respective.
speed-ups   ch-graph   classical binary.
search algorithm  obtain  approximation  csp.
 travel time  distance metrics.  surprisingly,  speed-ups  similar   ones reported .
table .,   number  issued ccsp queries within.
 binary search procedure remains unaffected  .
application  . ,  difference  terms .
 query times  quite considerable. without making.
use  bicriteria , several seconds  required .
computing  approximate csp solution even  .
small test graphs,    ch-graph   .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
 .
.
 .
 .
 .
 .
 .
figure . illustration   generalizable binary search.
procedure   . .  .temporary. imaginary.
reference path  indicated   dashed line. .
 line segments correspond  .real. paths.  .
reference   part     respective witness.
path. . coloured blue.  green box shows .
remaining cost interval,   halved   step.
  covers  one unit .bottom image. .
solution returned   algorithm  indicated  .
red line.
achieved   order  centiseconds even  california.
. tricriteria paths . . .   threedimensional case  considered  metric combination.
euclidean distance, travel time  fuel costs .
  decided   incomplete contraction .
order  keep  total number  edges .original .
shortcut. small.  used  contraction bound .
.   nodes,  slightly   one  .
two dimensional case,   number  paths.
  lower envelope  therefore  number .
necessary shortcuts  expected  increase significantly.
 every additional metric considered. like  .
two-dimensional scenario  present query times .
.
.
.
.
.
.
.
.
.
. . . . . .
 .
 .
 .
 .
 .
.
.
 .
.
 .
.
.
.
hed.
.
.
ch-edges.
dijkstra.
ch-dijkstra.
figure .  features    graph   variety .
metric combinations. runtime  presented  logscale.
plain dijkstra   ch-dijkstra   constructed.
graph,  correspond  answering single ccsp.
queries. moreover  will evaluate  proposed binary.
search variant  retrieving approximate csp solutions.
 higher dimensions   . ., measuring query times.
 quality   found solutions.
 experimental results  ccsp queries  three.
dimensions  collected  table .  observe .
 query time  plain dijkstra   increase.
significantly compared   two dimensional case.
applying ,  see   number  edges .
 resulting graph  similar   slightly  .
one   . ch-graph, although  stopped .
contraction process earlier.  resulting speed-up.
   large    . .  every additional.
metric considered weakens  hierarchical structure .
 graph. nevertheless query times decrease  two.
orders  magnitudes      range  .
  milliseconds  hence allow   answering .
ccsp queries  real-time.
 table .  query times   generalized.
binary search procedure   found,  allows .
 compute approximate solutions   np-hard csp.
problem.  used csp queries ask   path .
minimal length  takes   . longer  .
fastest path  bears   . increased fuel costs.
compared   respective minimum . bounds.
 computed  dijkstra runs. also computing .
approximate csp solution   performed .
two orders  magnitudes faster, reducing  runtime.
 california  several minutes    second.
moreover,  observe   obtained approximate.
solutions     close   optimal ones,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. dijkstra  ch-dijkstra.
time. time. edges time. speed-up.
 . . . . .
 . . . . .
 . . . . .
cal . . . . .
table . speeding  flexible queries  three dimensions. query times  averaged  . random queries,.
  three customizable weights  chosen .  ., .   query.
. apx-csp apx-csp . .
time. time. speed-up quality fail.
 . . . . . .
 . . . . . .
 . . . . . .
cal . . . . . .
table . computing approximate csp solutions  three dimensions   without acceleration  . query.
times  averaged  . random queries. , .quality. denotes  averaged ratio   cost returned  .
algorithm .  path respecting  resource bounds.   cost   shortest path .without considering.
resource bounds. hence  provides  upper bound   approximation quality   solutions.  value.
 brackets   maximum ratio  occurred. .fail. reports  percentage  queries     given.
constraints  feasible path  found .either    path exists    algorithm  .
find   solution.
  average  distance  close   respective shortest path distance.   lower bound .
 optimal solution  resource bounds  neglected.
.  number  queries    feasible path.
 found .see  last column.  pretty small, hence.
  assume   procedure finds   cases.
 good approximation   lower envelope .  .
solution exists  .
. . . . .
. . . . .
. . . .
. . . . .
. . . .
. . . . .
. . . .
. . . . .
. . . .
table . run times  approximate csp solutions.
 varying constraints    graph. queries.
demand  shortest path    travel time .
longer  . times  fastest respective path  fuel.
costs  exceeding . times  minimal possible costs.
  cell  lower number denotes  query time .
.   . search sped   ,  upper number.
gives  runtime without acceleration .also  . .
timings  averaged  . random queries.
 running times   variety  different constraint combinations  presented  table .  .
speed-up   naturally remains almost unchanged.
. .,  query times increase significantly .
larger resource bounds. nevertheless  even larger.
bounds  queries become .trivial.,   shortest path already fulfilled  constraints   .
  cases right away. therefore  query times decrease  significantly    find  optimal solution   plain .accelerated. dijkstra run.
     witness search procedure   .
used  construct  ch-graph efficiently  also .
enable approximate csp query answering   three.
dimensional case.
. conclusions.
  paper  considered  multicriteria shortest.
path problem  presented  polynomial-time procedure  decide whether  given path  appears  .
facet   lower envelope   pareto-optimal solutions.  procedure   instrumented  build contraction hierarchies   multicriteria shortest path.
problem   paths optimizing  conic combination   edge weights   found orders  magnitudes faster  using ordinary dijkstra.  optimizing  conic combinations   bicriteria case.
  established  powerful tool  obtain approximate solutions   bicriteria constrained shortest.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
path problem,  procedure also proved useful  obtaining good heuristic solutions   tri-  multicriteria case.  polynomial time bound  obtained.
via polyhedral arguments   hypervolume  .
facet   lower envelope corresponding  .
. acknowledgement.
 work  partially supported   google focused grant program  mathematical optimization.
 combinatorial optimization  europe.
</doc>
<doc title='5_ALENEX_48_1.txt'>
downloaded  knowledgecenter.siam.org.
engineering java . dual pivot quicksort using malijan.
adventures  just-in-time compilation.
sebastian wild. markus nebel. raphael reitzig. ulrich laube.
abstract.
recent results  java . dual pivot quicksort  revealed.
 highly asymmetric nature.  insights suggest .
asymmetric pivot choices  preferable  symmetric ones.
  quicksort variant.   theoretical point  view,.
  allow   improve   current implementation  oracle. java . runtime library.   paper, .
use  new tool malijan  con.  asymptotically.
 combinatorial cost measures    total number .
executed instructions. however,  observed running times.
show converse behavior.   support  data provided.
 malijan   able  identify  pro.ling capabilities.
 oracle. just-in-time compiler   responsible  .
unexpected outcome.
. introduction.
 .,  new quicksort variant due  vladimir.
yaroslavskiy  chosen  standard sorting method.
 oracle. java . runtime library. according  .
java core library mailing list .,  decision  .
change  based  empirical studies showing .
 average,  new algorithm  faster   formerly used classic quicksort. surprisingly,  improvement  achieved  using  dual pivot approach, .
idea     considered promising .
 theoretical studies ., ., .   remained .
open problem  theory  practice   match.
 yaroslavskiy. algorithm, even though quicksort .
 assumed   well understood.  recent closer.
look   algorithm  revealed   new partitioning scheme  able  take advantage  certain.
asymmetries   outcomes  key comparisons. .
average, yaroslavskiy. algorithm needs . less comparisons  classic quicksort  sort  random permutation .
 order  make  theoretical study feasible,.
  based   simplistic version   algorithm.
  paper,  adopt  perspective   library.
designer  wants  investigate whether  alleged.
. research  supported  dfg grant  .
.computer science department, university  kaiserslautern,.
email. .wild,nebel,.reitzi,laube.uni-kl.
bene.   proposed modi.cation carries  .
practice.  involves assessing  quality  .
 tricks   trade developed  decades .
experience  practical implementations  classic.
quicksort.
 contribution   paper  .  propose .
possible improvement   implementation  java .
library  use    example  show .  .
tool malijan   put  good use  automatically.
assessing  impact  small variation   performance.
 motivation   modi.cation   aforementioned asymmetry uncovered  . whereas .
jre. implementation chooses tertiles-of-.  pivots.
. natural extension   tried  tested medianof-three strategy  classic quicksort.  asymmetric.
nature   algorithm suggests   symmetric.
choice may  suboptimal  yaroslavskiy. quicksort.
therefore,  investigate  asymmetric strategy .
pivot selection.
 .   asymmetric variant  indeed slightly reduce  expected number  executed.
java bytecode instructions asymptotically.  present.
closed-form estimates   .ect. interestingly,.
running-time measurements clearly disagree.  identify oracle. just-in-time .jit. compiler  cause .
 seeming paradox.  inputs used  gathering.
pro.ling information dominate actual running time .
details   experimental setup decide  sorting.
method  faster.
 examination  driven  maximum likelihood.
analysis ., implemented  malijan,  .
propose   general-purpose experimental methodology.
 investigating  impact small modi.cations .
 algorithm   running time.   based .
decomposiing  algorithm  hand along  control.  access  individual frequencies  key.
instructions  proven instrumental  identifying .
reason   strength  yaroslavskiy. quicksort.
simply counting  overall number  key comparisons.
.   horrible  put  new code   library, .
  someone else come along  speed    another.
.  using standard techniques. .jon bentley  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
  shown    fewer comparisons .
yaroslavskiy. algorithm   classic quicksort, .
 .
. related work.     .rst time .
asymmetries prove useful  connection  quicksort.
  classic algorithm,  number  comparisons .
minimized  using  median instead   random.
pivot  partitioning.  ., however, kaligosi .
sanders  shown   skewed pivot   used.
 speed  classic quicksort  hardware  slow.
rollback  cpu instruction pipelines  case  branch.
mispredictions. even    biased choice  .
pivot makes  impossible  achieve  optimal number  comparisons,  outcome  key comparisons becomes less random  thus makes  prediction easier.
similarly, mart.nez  roura pointed   skewed.
pivots   bene.cial  applications  swaps .
much  expensive  comparisons .  fact,.
 number  swaps  maximized  choosing .
median  pivot,   costs  outweighed  comparisons  classic quicksort.
  following,  .rst present  results .
optimizing  pivot sampling used  java . dual.
pivot quicksort. ,  describe  setup  .
experiments  explain  methodology  malijan.
used  obtain  results.
. java . dual pivot quicksort.
 ., oracle changed  default sorting method .
 java runtime library. since version .,  highly-tuned.
implementation  yaroslavskiy. dual pivot quicksort.
 used  sorting arrays  primitive types ., . .
comparison   plain version  yaroslavskiy. algorithm considered  algorithm .  . .see appendix .,  following optimizations found  way.
  library implementation.  assume  .
sort  array   length .
. pivot sampling.  two pivot elements .
chosen   tertiles   sample  . elements.
  end, . positions ., . . . , .   list .
selected    divide  list  regions.
 relative lengths  follows.
 . . . . . . . . . . . .
 . elements . . ., . . . , . . .
 sorted using insertionsort. denote  sorted.
elements  . . . . . . . ,  choose .
tertiles   sample, . . .  .,  pivots .
 , respectively.    natural generalization.
  median-of-three scheme used  one-pivot.
quicksort.
. . .
 . .
. . .
 . .
 . .
. . .
 . .
. . .
. . .
. . .
. . . . .
. . .
. . .
. . .
 . .
. . .
 .  .
. . .
. . .
. . .
. . .
. . .
. . . . .
. . .
. . .
. . .
. . .
 .  .
. . .
 .  . .
.
yes.
.
yes.
.
yes yes.
yes.
.
.
yes .
figure . control . graph   main partitioning.
loop  jre. .lines . . .  listing .  page .
 blocks    ones   executed .
linearithmic number  times,   determine .
leading term  costs.   upper right corner  .
block,  number  bytecode instructions  given.
backward arcs  highlighted.
. short sublists.  .sub-.lists   shorter.
  certain threshold, insertionsort  used instead  quicksort.
. equal elements. two optimizations aim  improving  handling  list  many equal elements. first  ,   sample  pivot selection.
contains two equal elements,  fall back  .
one-pivot quicksort implementation  ., .
 known   optimal  many duplicates .
  dual pivot case, elements equal   resp.
  collected   middle partition .
 additional scan.moved   .nal positions.
  respective borders, thus excluding  .
recursive calls.  additional step  skipped .
 middle partition  relatively short.
. almost sorted inputs.  quicksort .
called,  number  runs, . . sorted subarrays,.
  input  determined.   number  runs.
falls   certain threshold, mergesort  used.
instead  quicksort,     .cient .
 highly-structured arrays.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
  paper,  will  consider arrays  distinct.
elements,    highly-structured,   last two.
optimizations   .active.  focus   .rst.
optimization, pivot sampling   use insertionsort.
 sublists  size . .  accordingly simpli. jre.
implementation   found  appendix   page .
. engineering asymmetry.
choosing  tertiles   sample  done   original.
jre. implementation yields   symmetric pivots.
  infer   sample. however,  asymmetries found  yaroslavskiy. algorithm . suggest .
 asymmetric choice  pivots might  better. .
 kind  asymmetric choice really helps.
asymmetric pivot choices trade lower costs  .
current partitioning step  less balanced recursion.
trees.      priori clear   .  optimal.
trade-o.,  consider  general pattern behind .
tertiles-of-. strategy. first,  select  sort  sample  . elements   list. ,  choose .
pivots     certain order statistics .  .
 . .  .  . . denote  jre.,.  modi.
jre. quicksort implementation  ., . pivot sampling.  original implementation   jre.,.
. continue calling  original implementation jre.
instead  jre.,.  short.
 order  .  good choice    ,  take.
 look   control . graph  jre.  malijan.
 based   decomposition   program along .
control .,  constructs  graph automatically. .
also correctly identi.  hot spots   algorithm,.
. .  basic blocks   executed asymptotically.
 often.   shown  figure .   preceding.
page. execution   loop  terminated  pointers.
    crossed .exit condition  block . thus,.
 number  iterations  depends   length .
 current sublist.
accordingly,  overall number  loop iterations.
 depends   balanced  recursion tree globally ,     direction  asymmetry, . .
whether pivots  larger  smaller  exact tertiles.
 expectation.  direction  asymmetry  however .uence  paths  figure .  iterations take.  ranks   chosen pivots determine.
 odds   comparisons   branching blocks.
 total,   . .erent cycles  figure .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . .
. . . . . . . .
 now assign  cycle  costs  number .
executed java bytecodes   path. ,  .
automatically determined  malijan.
. . ., . . ., . . .,.
. . .  . . . .
   take  account  .  . actually.
count  two iterations, since    move two steps.
closer      paths. ordering  cycles.
 costs implies  following preference. . . . .
. . . . .
  now use  branching information .
 control . graph  make  iterations choose.
cheap cycles.  get many executions  ., .
need . .   hold  many indices,  small.
values    preferable. moreover,  pays .
avoid expensive .,   prefer . .   hold.
  indices.  also means    chosen.
smaller  jre. .    time,  .
 choose extremely skewed pivots  order  get.
 reasonably balanced recursion tree. together, .
makes jre.,.  promising candidate  challenge.
symmetric jre.,.
however,    rely  guesswork,  .
  exhaustive search among  . possible choices.
 order statistics ., .  measure  running time.
needed  jre.,.  sort  list  . integers, averaged  . . random permutations.  setup .
  yaroslavskiy. benchmark . first,  algorithm sorts  .xed random list . . times without.
measurement  allow  just-in-time compiler  optimize code. see section .   discussion. ,.
 algorithm  run  . . random permutations .
 average running time  reported.
 running times  inherently machinedependent,  also look   number  executed.
bytecodes.  inputs,  consider almost sorted lists.
using  random model  brodal  . . .described.
 detail  section . presorted inputs amplify .
.erences  pivot sampling.   sample positions.
 spread throughout  array,  presorted list implies.
  sample. order statistics   close  .
  whole list.  . random lists  length.
.,  algorithms execute  number  bytecodes.
shown  table .  second experiment  done.
entirely  malijan. counting executed bytecodes .
considerably  .ort  done  hoc compared .
running-time measurements,   feel malijan .
 put  good use .
 asymmetric jre.,.  consistently best .
 experiments, see table .   rest  .
paper,  therefore focus   comparison  jre.,.
 jre.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
order statistics ., . ., . ., . ., . ., . ., . ., . ., . ., . ., . ., .
running time . . . . . . . . . . .
number  bytecodes . . . . . . . . . . .
table . running times  random permutation  length .  numbers  executed java bytecodes  almost.
sorted lists  length .   jre.,. variants.
 jre.,.,  count   determined   caused stack .ows.  algorithm experiences quadratic worst.
case behavior  already sorted lists,      suitable candidate  library sort.
. jre.  jre.,.
  section,  quantitatively study  .ciency.
  proposed asymmetric pivot sampling strategy.
  authors. knowledge,    established.
benchmark input sets  sorting algorithms,   con.   arti.cial input distributions. among.
, random permutations   natural choice .
 also well-understood   theoretical viewpoint.
additionally,  consider almost sorted inputs.  argued ,  inputs intensify  impact  pivot.
sampling, thus providing  clearer distinction.  use.
 random model  almost sorted inputs  brodal  . .  generate  input,  element .
. . ., . . . ,  . .  chosen uniformly  random .
. . , . . . ,  . ., ensuring    .erent .
 previous elements. finally, elements  relabeled.
 ., . . . , .  preserving  relative order. .
choose  . . independently    order  obtain.
rather strongly presorted lists.   expected number  runs   lists   high,  jre. sorting.
method will indeed invoke quicksort.
note  equal elements  dealt    specialized partitioning method  jre.,   .
make use  two pivots.   inputs,  variant.
behaves identically   jre. implementation. thus,.
 exclude  case  equal elements   present.
discussion.
  input distributions,  consider combinatorial cost measures  actual running times. whereas.
abstract combinatorial measures   misleading since.
 hide technical details, measured running times .
machine-speci.  highly sensitive   experimental setup .see section .  combining ,  .
hope  . general trends  abstract measures .
 con.rmed  running time experiments.
. combinatorial measures. combinatorial.
measures comprise  algorithmic cost measures .
  depend  details   actual machine .
  counted deterministically   given algorithm.
 input.  sorting algorithms,   prominent.
examples   number  swaps  key comparisons.
however,  measures  often  abstract .
.
.
. .
.
. .
.
.
.
.
. .
.
.
.
.
.
. .
.
.
.
.
. .
. . . . . . . . . . . . . . .
.
.
.
.
figure . predicted growth function   number .
executed bytecodes  random permutations  jre.
.gray dashed line  squares.  jre.,. .blue solid.
line  circles., normalized    .  logarithmic.
horizontal axis depicts  input size.  model .
trained  sizes   .  nicely .  larger data,.
 well.
ranking algorithms  .ciency. therefore,  consider.
also  number  executed java bytecode instructions.
.   given java bytecode implementation .
 algorithm   given input, bccan  determined.
exactly.malijan     fully automatically.
malijan    count  desired measures.
 given inputs  also computes closed-form asymptotic extrapolations  basic-block-wise counters .
described  section .  corresponding results .
shown  tables .  .
random permutations. table .   facing.
page shows  asymptotics   random permutation input model.   number  swaps .
comparisons, analytically proven results  available.
 compare  empirical ones .  terms.
given  malijan   good accordance  .
 jre.,  correct expected number  comparisons  . lnn . . .malijan. . lnn.
  number  swaps  . lnn . .
.malijan. . lnn.   asymmetric variant.
jre.,.,  likewise  . lnn . . .  obtained  combining results  .  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
algorithm .comparisons .swaps .bytecodes.
jre. .    . . .    . . .    . .
jre.,. .    . . .    . . .    . .
yaroslavskiy .    . . .    . . .    . .
classic .    . . .    . . .    . .
table . expected cost measures  .erent quicksort algorithms   random permutation input model. .
algorithms   jre. quicksort implementation,  asymmetric variant jre.,. thereof, yaroslavskiy. basic.
algorithm .algorithm .  .  classic quicksort  studied  . results   two jre. variants  obtained.
using malijan.  formul.  classic quicksort  yaroslavskiy. algorithm    found  . resp. .
algorithm .comparisons .swaps .bytecodes.
jre. .    . . .    . . .    . .
jre.,. .    . . .    . . .    . .
table . expected cost measures  jre. quicksort implementation   asymmetric variant jre.,. .
almost sorted input data . .ned  section .  results  obtained using malijan.
.
.
.
.
.
. .
.
.
. . .
.
.
.
.
.
. .
.
.
. . .
. . . . . . . . . . . . .
.
.
.
.
.
.
figure . predicted growth function   number .
executed bytecodes  almost sorted arrays  jre.
.gray dashed line  squares.  jre.,. .blue solid.
line  circles., normalized    .  logarithmic.
horizontal axis depicts  input size.  model .
trained  sizes   .  .  larger data, .
well.
lijan. . lnn. comparisons  expectation .
. lnn . . .malijan. . lnn. swaps.
   results  obtained    .
trained stochastic model,   con.dence  malijan. results   number  executed bytecodes .
well.
 addition,  validate  asymptotics  comparing   measurements  large inputs .
  used  training  model. figure .  .
preceding page shows   closed forms accurately.
predict  expected number  bytecodes  lists .fty.
times larger   training data.
almost sorted inputs.  closed form estimates   combinatorial cost measures  given .
table .   authors. knowledge,  analytic results  known   input distribution. , .
check  closed form asymptotic  larger measurements. see figure .
  input models,  symmetric pivot choice.
implies less comparisons   swaps  .
asymmetric variant.    line  corresponding.
results  classic quicksort. moreover,  expected.
number  bytecodes needed  jre.,.  sort .
array  asymptotically less   jre.  .
input distributions.  shows   asymmetric.
pivot sampling choice   potential  increase.
quicksort. .ciency.
finally,   like  stress  well malijan. asymptotic model .  measurements  inputs.
.fty times larger   training set.  distinctly.
.erent behavior. .  almost sorted inputs.
 certainly rely  malijan. predictions.
. running time.  aiming  practical applicability  results,  looking   number  executed bytecodes   misleading.  example, table . shows  classic quicksort uses much less bytecodes  yaroslavskiy. basic algorithm. however,.
running time comparisons show converse behavior .
therefore,  section complements  combinatorial.
measures  actual running times.
 measured runtimes  shown  figure . .right.
exhibit  strange feature.  seem   two classes.
 inputs.  run signi.cantly faster  others,.
  two types  clearly separated.  clearly.
visible  random permutations,  .ect  even .
pronounced  almost sorted data. see figure . .
bifurcation    found     combinatorial.
measures, see  instance figure . .left.   number.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . . . .
.
.
.
.
.
.
. . . . . . . . . . . . . . . . .
.
.
.
.
.
.
.
figure . violin plots   observed number  executed bytecodes .left. resp. runtimes  random permutations.
 jre. .light gray.  jre.,. .dark blue., normalized    .  horizontal axis depicts  input size.
. . . . . . . . . .
.
.
.
. . . . . . . . . . .
.
.
.
.
.
.
.
.
.
figure . violin plots   observed number  executed bytecodes .left. resp. runtimes .right.  almost sorted.
data  jre. .light gray.  jre.,. .dark blue., normalized    .  horizontal axis depicts  input size.
 executed bytecodes. therefore,  runtime .ect.
  jvm    responsible.
 fact,  split vanishes completely.  .
input distributions.   prohibit  just-in-time.
compiler .jit.  pro.ling  running code., . .
force   compile  bytecode  hand  .
program start.  essence,  prevent data-dependent.
compiler optimisation. see figure .   resulting.
distribution  runtimes.  curiosity warrants .
investigation.
 far,   measured runtimes  isolation. .
 input,  start  new jvm  run  algorithm.
 .xed number  times  .  implies   jit.
collects pro.ling data    input  algorithm.
 ever run  .  jvm instance.  happens .
 force  jit  pro.   .xed input instead. .
  yaroslavskiy. benchmark . ,  .
interestingly, jre.,. shows slight improvements .
jre.   considered input types, whereas .
  exhibit worse running times .see appendix .
 data  figure .  figure .   support.
.  possible  passing -xcomp   jvm.
. maybe  behaviour  jit  responsible  .
seemingly bad runtime performance  jre.,.
  therefore chosen two .xed inputs, namely.
  performed best .xed min. resp. worst.
.xed max.   model without explicity warmup .
 given input size.,  repeat  whole runtime study.
    two,    .erence  .
 jit  .warmed .   respective input .
measuring runtimes.  experiments fail  reproduce  bifurcation. see figures .  ., respectively.
also,  average runtimes  warmup  .xed min.
 .xed max   nearly  far apart    nonwarmup study.  fact,  choices   warmup input.
lead  similar average runtimes .veri.   .xed input size.  conclude  runtime distributions .
even averages depend heavily   optimisation jit.
performs.   unclear  warmup model   realistic,    control resp. guide jit towards .
optimsation   good  expectation.
furthermore,  note  without explicit warmup.
 without jit pro.ling, jre. seems  outperform.
jre.,.  average,   .xed warmup studies.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . . . .
.
.
.
.
.
. . . . . . . . . . .
.
.
.
.
.
.
.
.
figure . violin plots   observed runtimes  random permutations .left. resp. almost sorted data .right. .
jre. .light gray.  jre.,. .dark blue. without jit pro.ling, normalized    .  horizontal axis depicts.
 input size.
. . . . . . . . . .
.
.
.
.
.
. . . . . . . . . . .
.
.
.
.
.
.
.
figure . violin plots   observed runtimes  random permutations .left. resp. almost sorted data .right. .
jre. .light gray.  jre.,. .dark blue.  jit-warmup  .xed min, normalized    .  horizontal.
axis depicts  input size.
. . . . . . . . . .
.
.
.
.
. . . . . . . . . . .
.
.
.
.
.
.
.
figure . violin plots   observed runtimes  random permutations .left. resp. almost sorted data .right. .
jre. .light gray.  jre.,. .dark blue.  jit-warmup  .xed max, normalized    .  horizontal.
axis depicts  input size.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
jre. random perms.
jre. presorted.
jre.,. random perms.
jre.,. presorted.
. . . . . . . . . . . .
figure . relative basic block running times  .
blocks  executed . log . times.  numbers.
correspond   blocks ids used  figure .  .
clearly visible   running time contribution .
 basic blocks  heavily .uenced   pivot.
choice.
seem  favor  asymmetric pivot choice.
. asymptotic running times. section . describes  experimental methodology  assign .
basic block  contribution  overall running time.
thereby,   combine malijan. reliable asymptotic extrapolations  combinatorial cost measures .
actual running times   asymptotic running time extrapolation. corresponding results  shown  table .
note   asymptotics    plain.
extrapolations  measured running times.  extrapolating  done  block frequency counters  .
 determined without noise.   constants .
terms  multiplied   determined  running.
time experiments.
quite surprisingly.except   -xcomp mode.
 asymptotic running times favor  symmetric.
quicksort implementation.  disagrees  .
.ndings   number  executed bytecodes. consequently,  running times  individual basic blocks.
must behave .erently   numbers  bytecodes.
  blocks.
. comparing block times.   computation  asymptotic running times, malijan determines  running time contribution   basic block,.
 allows  closer examination   mentioned.
mismatch.  better comparability,    use .
additional running time measurement described  section . instead,  use . . bifi  block time esti.   observed   noise  indeed hide  true.
asymptotic behavior.    extrapolation heuristic .
found  correct linearithmic growth  frequency counters.
attested linear growth   noisy running times.
. .
. . .
 jre.  warmup jre. xcomp jre. .xed-min jre.,. .xed-min.
figure . relative costs   . cycles ., . . . , .
 figure . introduced   .erent cost measures,.
namely  number  bytecodes  block running.
times  .erent algorithms  jit modes.
mate. note  . . . .      average.
sampling interval,  will  close  constant, .
 subject  noise.
figure . shows      blocks .
 executed   linear number  times,  .
 essentially independent   pivot choice. .
 asymptotically dominating basic blocks. . . .
  linearithmic number  executions.surprisingly,.
 picture changes,  shown  figure .
 carries    costs   . cycles.
., . . . , . identi.   control . graph  .
partitioning method. see figure .  closer inspection   .gure explains  jre.,. performs worse.
 expected based   number  executed bytecodes.  jre. block times, .   cheapest cycle.
 far, whereas .  rather expensive. however, .
block times  jre.,. show exactly  opposite behavior.  short . cycle. jre.,. executes.
exceptionally often  design .suddenly becomes .
least favorable iteration path.
 makes  plausible   algorithm modi.cation optimizing  number  executed bytecodes .
still  inferior  another one. even though  fail .
provide  explanation    happens,  least.
 identi.    code  .erence  located might help future investigations.
. method.
. malijan   maximum likelihood.
analysis.   section,  brie. review  purely.
analytical study  algorithms    imitate  .
 tool malijan.    interested   practical.
.ciency  algorithms,   consider average case.
analyses.  gold standard   .eld   analysis.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
jre.  jre.,.  jre. brodal jre.,. brodal.
-xcomp .    . .  .    . .   computed  computed.
 warmup .    . .  .    . .  .    . .  .    . . .
.xed min warmup .    . .  .    . .  .    . .  .    . . .
.xed max warmup .    . .  .    . .  .    . .  .    . . .
table . asymptotic running time models   two quicksort variants   random permutation . .
almost sorted .brodal. input distribution. basic block running times  determined  block sampling . described.
 section . using .erent jit modes.
jre. random perms.
jre. presorted.
jre.,. random perms.
jre.,. presorted.
figure . relative basic block running times   blocks  executed . times.  .erent algorithms .
input distributions   seem  .uence block times much.
  style  knuth. . art  computer programming.,   based   following assumption.
assumption .  instruction   code listing.
  program adds   constant contribution .
overall costs  time   executed.  particular,.
 contribution   depend   context .
execution.
knuth computes  expected running time   given.
program . . .  given input distribution  analyzing.
 often every single line   code  executed .
average. assume  instructions   program .
labelled  line numbers ., . . . , . denote   .
expected execution frequency  instruction   .
.  cost contribution.   total expected cost.
 given .
.
.
. .  .
 hard part   analysis   determine  expected frequencies .   tool malijan,  .
deduced  experiments via  maximum likelihood.
principle  certain extrapolation techniques. however,  corresponding technical details  correctness proofs  omitted . complete presentation.
  theory already appeared  .
malijan allows studying algorithms  .erent.
levels  abstraction.   abstract measure like counting elementary operations .ces  assess  impact.
  code variation,    need separate experiments  .erent hardware environments. elementary.
operation counts  platform-independent.  .
.ects    observable   abstract model.
. . running time due  cache misses  branch mispredictions. methodology isolates  minimizes .
part   experiment  requires runtime measurements .see section .
  cases  tool   just provide simple counts  measurements  also estimates  .
asymptotic growths rates  functions   symbolic.
input size .  notably,  growth rates  always based  combinatorial counts,    determined without noise.  contrast, direct extrapolation.
 runtime measurements inevitably includes noise .
 fact,   observed  noise  fool  tool. extrapolation heuristic  total runtimes,   .
heuristic found  correct asymptotic growth rate .
combinatorial counts    runs.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 detail,  consider  program  java bytecode.
 label  instructions  line numbers ., . . . , .
  given execution   program   input, .
call  sequence  visited line numbers  trace  .
execution. ,  trace  formally  word  ., . . . , .
 given set  inputs thus induces  language .
., . . . , . similarly,  probability distribution .
inputs induces  probability distribution  traces.
traces  used  .  notion  algorithmic.
cost measure. speci.cally,  cost measure   characterized   cost contribution . . ., ., ., . . . .  .
line number  . ., . . . , .  .  cost .  .
trace  . . . . .   summation   elements. costs,.
. . . . . . .   interested   expected cost  .   trace  randomly chosen according.
  input distribution.  method inherently supports   additive cost measures.,  instance.
 total number  comparisons. non-additive measures   maximum memory usage elude . .
restriction   formal version  assumption . .
thus also applies  knuthian analysis.
towards  automated approach,  note .
 program. control . graph.viewed  nondeterministic .nite automaton. induces  regular overapproximation  said language  traces. essentially,.
 control . graph ignores dependencies .
branch conditions.  equipped  transition.
probabilities ., . . . , .,  control . graph becomes.
 probabilistic .nite automaton, . .  markov chain accepting words. denote   . ., . . . , .  expected costs   random terminating run   markov.
chain.    computed exactly  symbolically .
 unknown probabilities ., . . . , . .see . . ., chapter .  standard computer algebra systems. even.
though  markov chain accepts sequences  .
 traces   program,   shown  . .
 .  .  suitable branch probabilities ., . . . , .
 remains  obtain  suitable transition probabilities.  probabilities   interpreted   free.
parameters   probability model,    compute estimates.   end,  randomly sample inputs.
 record  actual traces. taking relative transition frequencies   traces indeed gives  maximum.
likelihood estimator   parameters . . .  given.
traces.
  done separately   observed input sizes,.
   get one transition probability estimate per.
. code may  generated  java source   java.
compiler     programming language   .
compiled  bytecode.
. essence,     rely   linearity  .
expectation  split   .    instruction. cost .
independent   context   trace.
size. finally,  extend    function   via.
extrapolation.  general,    heuristic step, .
 fact   part   method   sacri.
provable correctness.  many algorithms, however,.
 set  occurring functions  rather limited  .
  still hope  good results. moreover, malijan uses established statistics  empirically assess .
quality  extrapolations.   probability model.
 trained   treated  given.  accordance  .
scienti. method,  accept  inherent simpli.cations.
made  building  model  use  nevertheless.
 make predictions. malijan also .ers basic support.
 validating  model.
finally,  thus obtained transition probability.
functions .  inserted   unknowns  .
precise expected costs .
.
., . . . , .
.
.  ., theorem .   shown , assuming perfect extrapolation,  probabilities  indeed suitable   .
sense.  thus obtain  closed function    .
expected costs.   function  results .
knuthian analysis.
.  counting  running time.   library designer, one  focused   actual running.
time  algorithms. therefore,  desired cost measure.
 assigns  every line number   time . needed .
execute  instruction.  seemingly simple task .
determine  times . turns    quite challenging.   running times  single instructions .
  range   nanoseconds, direct measurement.
    question.  .,  authors nicely argue.
 determining  . via .tting  measured total running times  known execution frequencies .
  .ective, either.  authors present  better.
method using .equivalent code fragments.,   requires manual work.
 propose  fully automatic approach called .basic.
block sampling.  divide  program  basic.
blocks, . . maximal blocks  sequential instructions.
,  inject instructions   beginning  .
block  store  identifying number   block .
 global variable.  introduces  systematic error.
  basic block becomes   instructions longer,.
  will  fairly small compared   techniques.
 runtime measurement. ,   periodic basis,.
 concurrently read  global variable  store .
block number. note   periodic job  done.
 parallel  hence   .uence  running.
time   algorithm , . .    add  .
systematic error.  repeating  run .ciently often,.
. example   study  .,  extrapolation heuristic.
 reproduce  expected costs  bubblesort  quicksort.
known   literature.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 relative frequencies   observed block numbers.
approach  relative running time contribution  .
blocks .see appendix    quantitative discussion.
 ,  get  vector  . ., . . . , . .
observed block frequencies, . . block    seen.
 times  total.  separate runs,  also count .
exactly, .  often block   executed  total, .
 measure  total running time   yet another run.
,  use.
. . .
.
. .
.
. ,   .
.
.
.
  estimate   block running times.
note   implicitly presumed assumption . .
practice, .erent running times  two executions .
  instruction  occur, . .   cache.
misses.  will nevertheless use assumption . .
try  detect violations  testing  created runtime.
model   end.
. malijan. malijan   integrated java implementation   method outlined   previous.
section.    graphical user interface  uses mathematica  symbolic calculations. executables .
 instructions   obtained   website.
http.wwwagak.uni-kl.malijan.html.
. conclusion . future work.
  paper,  used  tool malijan  study.
 jre. implementation  yaroslavskiy. dual-pivot.
quicksort   asymmetric variant  .  showed.
  variant  asymptotically better . . . .
number  executed java bytecode instructions, .
 random permutations  presorted arrays.
 closer look   optimized algorithm shows .
 use  asymmetric pivots changes  partitioning.
step   way  favors cycles    small number  bytecodes. surprisingly,  using skewed pivots,  running time   corresponding blocks increases heavily    optimization seems  fail.
however,   original benchmark used   java.
core library developers  assess  quality  optimizations,  asymmetric pivot choice achieves slight improvements   input types, without getting signi.cantly worse    input. given  large.
.orts put   highly-tuned library implementation, even  small improvements  remarkable .
 authors. opinion.
.ciency  practice heavily depends  details .
 jit compiler con.guration   investigated.
variants.  particular, intriguing clustering  running.
times  consistently observed   jit  use pro.ling information   current input  compiling.
 algorithm.  experiments  shown .
.erent setups   jit warumup   lead .
 clustering.
. acknowledgements.
 thank florian furbach, michael holzhauser .
vasil tenev   part  developing malijan, .
started    masters project. furthermore,  .
grateful  mathematica stack exchange user kguler.
 showing    customize distribution charts.
finally,  thank  anonymous referees  .
helpful comments  suggestions incorporated  .
.nal version.
</doc>
<doc title='6_ALENEX_35.txt'>
downloaded  knowledgecenter.siam.org.
. kinetic alpha complexes   implementation .
michael kerber.  herbert edelsbrunner.
abstract.
motivated   application  cell biology,  describe .
extension   kinetic data structures framework  delaunay triangulations  fixed-radius alpha complexes. .
algorithm  implemented using cgal, following  exact.
geometric computation paradigm.  report  several techniques  accelerate  computation  turn  implementation applicable   underlying biological problem.
keywords. computational geometry, delaunay triangulations,.
alpha complexes, kinetic data structures, spatial sorting, exact.
geometric computation, implementation, software experiments.
. introduction.
consider  finite set  particles  points  ., moving.
 time along continuous trajectories. interpreting .
points   centers  moving objects,   interested.
  topological changes  configuration undergoes. .
interest   problem originates   sorting process .
segregates cells  zebrafish development,  studied .
heisenberg  krens .  sorting process operates .
intermixed configurations  cells   different types.
 different physical properties. one example   mix.
 two cell types,    cells   first type .
 strong preference  neighboring cells    type.
  strong dislike  exposed boundary,   cells .
 second type  milder preferences  dislikes. .
typical outcome    cells   first type form  balllike shape   engulfed   spherical shell consisting .
cells   second type .compare figure .
  effort  formalize  sorting process   make.
 amenable  detailed  objective measurements, heisenberg, krens,   authors   paper introduced  restricted voronoi medusa   mathematical representation. .
. research  partially supported  nsf  grant dbi-.,.
 esf   research network programme,    russian.
government  mega project .
.ist austria .institute  science  technology austria.,.
klosterneuburg, austria. max-planck-center  visual computing.
 communication .mpc-vcc., saarbru.cken, germany. stanford.
university, stanford, california.
.ist austria .institute  science  technology austria., klosterneuburg, austria. departments  computer science   mathematics,.
duke university, durham, north carolina. delaunay lab  discrete .
computational geometry, yaroslavl. state university, russia. geomagic,.
research triangle park, north carolina.
  geometric body  .-dimensional space-time obtained .
stacking  restricted voronoi regions  . .   moment  time,  voronoi region   particle  intersected.
  ball,   resulting bodies  glued together .
form  .-dimensional structure. applying persistent homology   time function   structure yields finegrained information   sorting process   difficult.
 observe directly.
results.   moment  time,  dual   restricted voronoi tessellation   alpha shape  fixed radius.  evolution  continuous motion   objects.
gives rise   combinatorial representation   medusa.
 carries    topological information .see . .
make two contributions   context.
.  describe  algorithm  maintains  fixed-radius.
alpha complex  points moving  piecewise algebraic trajectories  .  algorithm supports insertions  deletions  points  allows  piecewise.
algebraic trajectories.
.  convert  kinetic algorithm  robust  efficient software. basing  implementation   cgal.
package  kinetic data structures  daniel russel.
.,  achieves correctness   exact geometric computation paradigm.
contribution . extends previous work  computing kinetic.
delaunay triangulations.  believe  extension  find.
applications beyond  original problem.  requirement.
 correctly comparing algebraic numbers, without tolerance.
 inaccuracy  approximation  contribution . seriously.
slows   software, even  piecewise-linear trajectories.  counteract,  introduce techniques  speed-up.
 computations without sacrificing  correctness. .
evaluate  effectivity   techniques experimentally.
 point   due  space limitations,  extended.
abstract omits  algorithm  construct  medusa .
  kinetic alpha shape.  steps   algorithm.
 straight-forward. special care  needed, however, .
inserting  deleting trajectories   process.  refer.
 .    extended version   results.
outline. section . explains background  computational geometry  topology. section . describes  kinetic algorithm  fixed-radius alpha complexes. section .
. copyright . siam.
unauthorized reproduction   article  prohibited.
describes techniques  speed   computations. section.
. concludes  paper.
. background.
 review  fundamental geometric data structures  .
required   work. voronoi tessellations  delaunay triangulations  treated   computational geometry textbooks, including ., .,  alpha complexes  described.
 ., .    part,  discussion focuses  .
.-dimensional case.  definitions  properties extend.
 higher dimensions  well    plane.
simplicial complexes.  recall   k-simplex  .
convex hull   affinely independent set   . . points.
  euclidean space.  face   simplex defined .
 subset    . . points.   proper   subset .
different   set. reversing  direction,  call  ksimplex  coface   face.  define  simplicial complex.
  finite collection  simplices   closed   face.
relation,   additional property   two simplices.
  collection  either disjoint   intersection  .
face  .  boundary   k-simplex   collection.
  . . .-faces.  simplices  dimension ., ., ., .
.  referred   vertices, edges, triangles,  tetrahedra.
 star   k-simplex   set  simplices  contain.
 k-simplex   face. noting   star   general .
closed   face relation,  define  closed star .
 set   simplices   star    faces  .
simplices.    smallest simplicial complex  contains.
 star. finally,  .   k-simplex     point  .
 lie   k-plane   simplex,   join, denoted.
  . .,   . . .-simplex    convex hull  .
  vertices  .
  convenient  also introduce  abstract counterpart.
   geometric concept   simplicial complex.
specifically,  abstract simplicial complex consists  .
finite set  .abstract. elements   collection  subsets.
  closed   subset relation.  may map.
 element   point   euclidean space,  .
subset   convex hull   points  correspond  .
elements.   dimension   space  sufficiently high.
  points  well chosen,    simplicial complex,.
  refer    geometric realization   abstract.
simplicial complex.    example   construction.
consider  finite set,  ,  possibly overlapping bodies,.
 define  nerve   collection  subsets   .
non-empty common intersection.  note   nerve.
  abstract simplicial complex. indeed,  bodies .
 elements,    .    set   nerve, .
every subset    also   nerve.  useful result .
 nerve theorem .,  states    bodies .
  convex  every geometric realization   nerve.
   homotopy type   union   bodies.
intuitively,  means  one   transformed  .
  continuous transformations like bending, shrinking,.
 expanding,  without gluing  cutting.
voronoi tessellations  delaunay complexes. consider now  finite set  points,  ,  .  voronoi region.
  point      set  points  . .    .
 closest point   .
vor. . . . . . . . . . ., . . .
note  vor.  convex.  voronoi tessellation  .
  set  voronoi regions   points.   points .
   general position,    mean   four.
lie   common plane   five lie   common sphere,.
  voronoi regions intersect   rather predictable.
pattern. specifically,  intersection   two  either.
empty   .-dimensional. polygon,  intersection  .
three  either empty   .-dimensional. edge,  .
intersection  four  either empty   .-dimensional.
point. furthermore,  intersection  five   voronoi.
regions  necessarily empty.
 get  dual delaunay complex   replace .
non-empty intersection  voronoi regions   convex hull.
  points  generate  voronoi regions containing .
intersection.  complex equals  nerve   voronoi.
tessellation, geometrically realized   canonical way.
equivalently,  may define  delaunay complex  .
set  convex hulls  subsets  points    empty.
sphere property. specifically,  means   exists .
sphere  passes   points   subset  .
 points   lie strictly outside  sphere.  note .
 center   sphere belongs   intersection  .
corresponding voronoi regions. assuming general position,.
 delaunay complex   simplicial complex,  .
generally referred    delaunay triangulation.   .
geometric realization   nerve   voronoi tessellation.
restricted voronoi tessellations  alpha complexes. fixing  positive radius, .,  define  restriction   voronoi region    intersection   closed.
ball  radius . centered   generating point.
res. . . . vor. . . . . .
,  usually drop    notation.  restricted.
voronoi tessellation     set  restricted voronoi.
regions   points.  contrast   unrestricted case, .
restricted voronoi region  bounded,   tessellation.
covers   union  balls    entire space.
 ,  assume general position    dualize  geometrically realizing  nerve.  resulting simplicial complex  called  alpha complex. since res. .
vor.,   point    ,  alpha complex   subcomplex   delaunay triangulation. next,  derive .
equivalent condition   delaunay simplex  lie   alpha complex    suitable  computations. .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
k-simplex   delaunay triangulation   unique circumscribed . . .-sphere   supporting k-plane. .
call  center  circumcenter,  radius  circumradius,.
 ball  .   center   radius  circumball,.
  sphere  bounds  circumball  circumsphere.
  k-simplex. note   circumsphere   smallest.
sphere  passes   vertices   k-simplex. .
call  k-simplex short   circumradius  smaller .
 equal  . finally,  call  k-simplex gabriel  .
circumball   point     interior.  following.
lemma gives  alternative definition  alpha complex. .
detailed proof  omitted.
lemma . .short.gabriel lemma.  simplex .
 delaunay triangulation   belongs   alpha complex,  radius .,       short  gabriel, .
   face  another delaunay simplex   short .
gabriel.
 face   short simplex  necessarily short,   face.
  gabriel simplex   necessarily gabriel.  follows.
  simplices   alpha complex  short,   .
simplices need   gabriel. also note   tetrahedron.
   delaunay triangulation iff   gabriel. therefore,.
    alpha complex iff   short.   application,.
 use  restricted voronoi tessellation  model  set .
biological cells    positions   nuclei .
known. indeed,  cell tends  minimize  surface area .
usually   grow larger   certain size. therefore, .
restricted voronoi region appears    good approximation.
  actual cell shape   still simple enough  .
computational purposes.
. kinetic alpha complexes.
  section,  describe  algorithm  maintains .
alpha complex   fixed radius . . .  pay particular.
attention   certificates  govern  sequence .
operations needed  preserve  correctness   structure.
  times.
 kinetic framework.  input   algorithm .
 finite set  trajectories,   continuous map  . ., . .
.
.  . .  .  . .  simplicity,  assume   .
piecewise linear,   . . . . . . . . .  .   .
  points  ,  . .   . . . . tbj.
  .  . .   words,   write . .
., ., .      .,   .
 polynomial  degree .  call ., ., . . . ,   bending.
events   trajectory. furthermore,  assume  .
trajectories   meet  ,  , . . . .
 , . .        trajectories  defined.
 task   maintain  data structure  goes  .
initial configuration,  time  . .,   final configuration,.
 time  . .  ,  data structure  constructed .
time  . .,  maintained   sequence  update.
operations   final configuration  reached.  .
assumed   number  updates  finite,   call.
 time   update  event. events  detected .
defining suitable certificate functions, also referred  .
certificates.   moment  different   event, .
  collection  active certificates,   non-zero .
. importantly,  guarantee   long   certificate.
changes  sign,  data structure remains structurally.
unchanged.  detect  next event,  algorithm  finds.
 smallest root   active certificate   greater .
.  handles  event  updating  data structure  .
collection  active certificates. throughout  paper, .
make  simplifying assumption   events  distinct,.
 ,  two events happen    moment  time.
see also section .
maintaining  delaunay triangulation. since .
need  later,  begin  reviewing  kinetic algorithm.
 .-dimensional delaunay triangulations described  .
besides changes brought   insertions  deletions.
 points,  switches  new trajectory segments,  .
 two configurations  trigger  structural change  .
triangulation.
. five points   lie   common sphere,   open.
ball bounded   sphere contains  points   .
. four points   lie   common plane,  one .
 open half-spaces bounded   plane contains .
points   .
 call   configuration  degeneracy. consistent.
   assumption  distinct events,  assume .
 every moment  time    one degeneracy, .
  degeneracy lasts    single moment.  .
words,   find  small open interval  time  .
 given degeneracy exists   single point  time,  .
   degeneracy  occurs   interval. .
 therefore study  effect   degeneracy  considering  non-degenerate local configurations right  .
right   degeneracy. consider  example  degeneracy   first type,  involves five points. right .
 degeneracy,  five points span two delaunay tetrahedra.
  common triangle,  right   degeneracy .
span three tetrahedra    pair shares  triangle .
 three share  edge.  course,   also   .
way round. importantly,   transform one configuration.
    flipping.   particular case,  substitute.
three  two  two  three tetrahedra, calling  operation  .-flip. see figure .  avoid  case analysis, .
represent  triangulation using  vertex  infinity  .
joined  every simplex   boundary   convex hull.
  . effectively,  embed  triangulation   .-sphere.
 way,   add  point  infinity   set  four.
points forming  degeneracy   second type, thus getting.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
figure . illustration   .-flip  alters  triangulation  .
triangular double pyramid.   left,  five points span two.
tetrahedra meeting   triangle.   flip,  triangle .
replaced   edge   three incident triangles  connect.
 edge   remaining three points.
 degeneracy   first type,   handled   .-flip,.
 described .
flip events.  transition   delaunay triangulation across degenerate configurations  controlled  two.
certificate functions.  ., ., ., ., .   five trajectories   points  span two tetrahedra sharing  triangle  three tetrahedra sharing  common edge,   figure.
.  one   trajectories belongs   infinite vertex.
  reorder     trajectory  . .
.
. . . ., .
.
., .
.
.   coordinate functions .
 finite points,  recall   squared norm   point.
  sum   squares   three coordinates.   five.
points  finite,  create  certificate.
det.
.
.
. . . .
.
. . .
.
. . .
.
.
. . . .
.
. . .
.
. . .
.
.
. . . .
.
. . .
.
. . .
.
.
. . . .
.
. . .
.
. . .
.
.
. . . .
.
. . .
.
. . .
.
.
.
.
,.
   univariate polynomial     zero iff  five.
points  co-spherical. assuming  coordinate functions.
 linear,  degree   polynomial  .   fifth point.
  infinity,  create  certificate.
det.
.
.
. . . .
.
. . .
.
. .
. . . .
.
. . .
.
. .
. . . .
.
. . .
.
. .
. . . .
.
. . .
.
. .
.
. ,.
  zero iff  four point  coplanar.  call .
polynomials  .,. flip certificates   roots flip.
events.
  constructed  initial certificates,  time.
 . .,  algorithm finds  first positive flip event. .
 performs  .-flip, creating certificates   .new.
simplices inside  double pyramid,  updating  certificates   simplices   boundary   double pyramid.
 updating  necessary   star   boundary.
simplex changes   flip.   steps,  data.
structure  certificates   valid,   iteration.
continues   next flip event.
radius events. next,  extend  kinetic algorithm.
 delaunay triangulations  alpha complexes.  ,  use  fixed radius . . .  represent  alpha.
complex  equipping  delaunay simplex   flag.
 indicates whether    simplex belongs   alpha complex.  construct  flags  time  . ., .
check every delaunay simplex   short   .
gabriel. following  short.gabriel lemma  section .,.
 add  delaunay simplices   short  gabriel,.
 well    faces,   alpha complex.  maintain  flags,  construct  certificate   edge, triangle,  tetrahedron whose roots   times  .
circumradius   simplex equals .  simplify  discussion,  assume  generic case    circumradius changes  strictly smaller  strictly larger  .,.
 vice versa.  call  functions radius certificates .
 roots radius events. whenever  delaunay simplex .
inserted  deleted,  algorithm also creates  removes .
corresponding radius certificate.  certificate   edge.
compares  length  .,  taking squares,  get .
polynomial  degree .  radius certificates   triangle.
  tetrahedron   complicated,    derived.
 suitable minors   matrix  defines  circumsphere   simplex. see .   formula   tetrahedral case.  will discuss  triangle case  section .
 initializing  alpha complex   certificates,.
 algorithm looks   next event.     flip event,.
 proceed  described .  addition,  update .
flags  identify  alpha complex   subcomplex  .
delaunay triangulation.   tetrahedra involved .
 .-flip    circumsphere,   either .
short   non-short.    short,  new delaunay.
simplices  added   alpha complex,  otherwise,.
none    added   alpha complex. second, consider  case    next event   radius event.  .
  corresponding delaunay simplex.  . goes  nonshort  short,   proper cofaces  necessarily nonshort.  check whether .  also gabriel, noting  .
 always  case  .   tetrahedron.  , .  added .
 alpha complex together will   faces.   .
hand,  . goes  short  non-short,   proper faces.
 necessarily short.  remove .   alpha complex,.
unless      complex even   event.  .
event causes  deletion  .   alpha complex, .
 may  consequences   faces.  particular,  .
  last proper coface  .   alpha complex,  .
  gabriel,  .  also deleted   alpha complex.
afterwards,  algorithm continues   next event.
redundancy  gabriel events. perhaps surprisingly,.
flip  radius events suffice  maintain  alpha complex. flip certificates monitor  tetrahedra become non. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
delaunay,  radius events monitor  simplices become.
short  non-short.    need certificates  monitor.
 simplices become gabriel  non-gabriel.  understand   certificates   necessary,  call  time.
 g-critical   simplex .,    time, . changes .
gabriel  non-gabriel,  vice versa.
lemma . .g-criticality lemma.     gcritical time   short delaunay edge  triangle. .
 edge  triangle   proper coface     alpha.
complex  time .
proof. denote  edge  triangle  .  consider .
circumball, .,  time .  point   lies   interior.
 .,     point    bounding sphere  .
  vertex  .  join  . .  another simplex  .
delaunay triangulation,     proper coface  .  .
  circumball  .,  implies   . .  short.
 gabriel  therefore belongs   alpha complex .
time .
 lemma implies    short edge  triangle.
changes  gabriel status,    face   simplex  .
alpha complex.  status change  therefore  impact.
  membership   alpha complex.
 events.  briefly mention  remaining types.
 events supported   algorithm. first,  consider .
bending event,    trajectory starts  new segment.
  event leaves  alpha complex unchanged,  .
flip  radius certificates  involve  coordinates .
 corresponding vertex  recomputed.   .
certificates associated   simplices   closed star .
 vertex.
second,  allow  insertions  deletions  points.
 two operations  mostly symmetric,   .
discuss  insertion   point .  add    delaunay.
triangulation  identifying  tetrahedra whose circumballs.
contain , referring   union   conflict region .
. since  tetrahedra  longer satisfy  empty sphere.
criterion,  remove    delaunay triangulation,.
together   faces   interior   conflict region.
next,  add   connect    simplices   boundary.
  conflict region.   operation,  simplices.
form  boundary   closed star  . finally, .
simplices   closed star  checked     alpha.
complex,   certificates  created  updated.
. implementation  experiments.
  section,  turn  implementation issues.  particular,  discuss   implement  algorithm   robust manner,  study  effect  practical choices,  .
present experimental results obtained   software.
robust computation. recall  basic structure   kinetic data structure  explained  section .  consists .
certificate functions,   polynomials  ,  .
step advances  state   smallest root larger  .
current time.  maintain  certificates   advance .
 next event,  algorithm computes  compares real.
roots  univariate polynomials.  roots  algebraic.
numbers . irrational  general .  makes  computations non-trivial.  naive solution  approximating.
 roots  inexact floating-point numbers   unpredictable effects.    true   outcome  just.
slightly wrong, .  switching  order  events  happen almost simultaneously,   incorrect order  lead .
inconsistent configurations, causing program crashes, nontermination,  non-sensical results.  problem  wellknown  geometric contexts .  several approaches.
  proposed.  follow  exact geometric computation .egc. paradigm, popularized  chee yap . .
suggests   basic primitives  mathematically correct,.
   algorithm using  primitives    position.
 compute provably correct results. translated   situation,  require   events   process  handled .
 mathematically correct order.  price  pay  .
interpretation  robustness   burden  compute .
algebraic numbers.
 implement  algorithm using  cgal library.,.
  designed   spirit   egc paradigm. another aspect  cgal   generic programming approach.
algorithms access underlying data structures  primitives.
  well-defined interface,    layers .
 easily replaced  alternative implementations. .
specifically,  make use   kinetic data structures package .,  provides  egc implementation  kinetic.
delaunay triangulations  two  three dimensions. internally,  package contains  algebraic kernel, providing.
 low-level functionality needed  handle roots  polynomials,   combinatorial layer, maintaining  data structure   certificates  time.  mentioned earlier, .
 extended  combinatorial layer  maintaining  alpha complex.
experimental set-up.  use datasets obtained .
 compucell. software.,  allows   simulation   .-dimensional cell segregation process using.
 monte-carlo algorithm  energy minimization. see .
companion paper .   details.  focus  simulated  opposed  observed data   offer  better.
control   input size   direct accessibility  .
cell trajectories.   particular example,  cells  colored blue  red,  color  probability one half, .
 parameters   simulation  chosen    blue.
cells eventually engulf  red ones. see figure .   illustration.  created datasets  several input sizes.  .
.computational geometry algorithms library, www.cgal.org.
.www.compucell.org.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
figure .  restricted voronoi tessellation  four moments .
time.   beginning,  cells form  cubical grid .upper-left.
 cells move toward  center   available space,  .
blue cells begin  engulf  red cells .upper-right  lower-left.,.
allowing  satellites   happens. finally,  blue cells.
form  sphere surrounding  ball  red cells .lower-right.
cases,  trajectory represents  path   cell nucleus.
 exists throughout  entire process. hence,  new.
cells  ever inserted   start   process,   old.
cells  deleted   end   process.  trajectories follow  global rhythm    trajectory starts .
new segment   value   common sequence  bending events.   two bending events,  trajectory.
 linear.  experiments  performed   intel core .
dual cpu clocked  . ghz ,  .   cache.
size,  .   total memory.  code runs  debian.
squeeze, compiled  gcc-.  cgal version .
  first test,  compare  running times  maintaining  delaunay triangulation   alpha complex,.
see table . comparing  third  fourth columns  .
table,  see   radius events slow   algorithm.
    magnitude,  spite   fact   number   much larger   number  flip events.  .
remainder   section,  explain improvements  .
algorithm aimed  reducing  performance gap .
delaunay  alpha complexes.
number  certificates.  bottleneck   construction  radius certificates   computation   real.
roots. recall    original formulation,  maintain.
 radius certificate   edge, triangle,  tetrahedron.
 first optimization  based   observation  many.
  certificates   necessary.   simplex  short,.
   faces  short,    simplex  non-short, .
  cofaces  non-short.
input . time  sec .events.
traj bends del alpha flips rad.
. . . . . .
. . . .,. .,. .,.
. . . .,. .,. .,.
. . . .,. .,. .,.
. . . . . .
. . . .,. .,. .,.
. . . .,. .,. .,.
. . . .,. .,. .,.
. . . .,. .,. .,.
table . columns  left  right.  number  trajectories .
bending events per trajectory,  time  maintain  delaunay.
triangulation   alpha complex,   number  flip .
radius events.
input . time  sec .certificates.
traj bends    .
. . . . .,. .,.
. . .,. . .,. .,.
. . .,. .,. .,. .,.
. . .,. .,. .,. .,.
. . . . .,. .,.
. . .,. . .,. .,.
. . .,. .,. .,. .,.
. . .,. .,. .,. .,.
. . .,. .,. .,. .,.
table . third  fourth columns.  time  maintain .
alpha complex    optimization . fifth  sixth.
columns.  number  radius certificates   .
optimization .
optimization . whenever  triangle  tetrahedron becomes short,  remove  radius certificates   proper.
faces,    edge  triangle becomes non-short, .
remove  radius certificates   proper cofaces.
 course,  implies   sometimes   construct.
certificates   otherwise still exist.  example, .
construct  certificate   triangle   time  third edge.
becomes short.    hand,  avoid unnecessary.
certificates,  instance  certificates   boundary.
edges   triangle  stays short   whole simulation.
  see  table .,  strategy saves time   scenario.
 observe   constructions  radius certificates .
 running time  decrease roughly   factor  two.
degree.  turn   computation  certificates.
assuming piecewise-linear trajectories,  radius certificate.
  edge   polynomial  degree . compare  section.
.    standard construction   radius certificate .
 tetrahedron,    polynomial  degree . see .
 interest lies   remaining triangle case.  current.
cgal implementation computes  squared circumradius.
  triangle .  .   expression   form.
. .
num. . num.
.
 . num.
.
.
.den.
,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
input . time  sec.
traj bends deg . deg .
. . . .
. . . .
. . .,. .
. . .,. .,.
. . . .
. . . .
. . .,. .
. . .,. .,.
. . .,. .,.
table . timings  maintaining  alpha complex using .
degree . versus  degree . certificate function  monitoring.
 circumradii  triangles.
input . time  sec.
traj bends kds   filter cache.
. . . . . .
. . . . . .
. . . . . .
. . .,. . . .
. . . . . .
. . . . . .
. . . . . .
. . .,. .,. .,. .
. . .,. .,. .,. .,.
table . timings  maintaining  alpha complex using.
 kds kernel,    kernel,  latter  descartes.
filtering,   addition  enabled cache.
 den   determinant   matrix  ., .
numx, numy , numz  expressions formed  minors .
 matrix.  corresponding certificate,.
num. . num.
.
 . num.
.
 . .
.
.den.
.,.
  polynomial whose degree  .,   higher  .
degree   tetrahedron.  replace .   simpler.
expression. writing , ,    three vertices  .
triangle,  circumradius  also  written .
. .
. . . . . . . . .
. . . . .
,.
 formula   straightforward  derive using elementary.
matrix calculus. see also wikipedia .
optimization . monitor  radius   triangle using.
 following certificate function.
. .
.
. .
.
. . .
.
. . . .
.
 degree   certificate  .  see  effect  .
improvement  table .  running time improves  .
  factor  two.
algebraic kernel.  already mentioned,  cgal.
package  kinetic data structures contains  internal algebraic kernel, , among  things,  used  isolate .
roots  polynomials  sort    event queue. .
 generic design   package,  combinatorial layer.
communicates   kernel via  small  well-defined.
interface,  makes  possible  replace  algebraic.
kernel   different implementation.
 recent years,  mature  generic algebraic kernel .
geometric computations   developed .   .
integrated  cgal   available since version . .
 name algebraic kernel .  refer    .
  kernel.   internal kds     kernels use.
subdivision methods  root isolation,   differ  .
strategy  detecting empty intervals  isolating intervals.
 kds kernel uses sturm theory ., .,    .
kernel  based  descartes. rule  sign .,  leads.
  better performance  practice. see .   comparison.
 various root solvers.  difference   third .
fourth columns  table . shows  exchanging  kernel.
yields another improvement  roughly  factor  two.
filter  cache.  get  optimizations  exploiting  special structure   experimental setup. .
 certificate,    interested   roots .
 current time   next bending event,   certificate becomes invalid. many certificates    roots .
 interval,  may  roots outside.  current implementation first computes  real roots  thereafter discards.
 ones  lie outside  mentioned interval.
optimization .  use descartes. rule  sign  certify.
 non-existence  roots   interval   next.
bending event,   successful,  skip  root isolation.
algorithm.
 fifth column  table . shows  improvement. .
 ninety percent   certificates     .
root   next bending event  filtered .  .
final improvement,  avoid isolating  roots   .
polynomial multiple times.
optimization .  store polynomials together  .
real roots   cache.  cache  cleared   next bending.
event.
 see   sixth column  table .   cache yields.
another substantial speed-up,  suggests  certificates.
 frequently devalidated  revalidated   runtime.
  algorithm.  remark  also  kds kernel.
 benefit  caching. comparing  running times.
 maintaining  alpha complex    .
four steps  optimization,  see   performance.
improves  roughly  factor  . moreover, compared.
 maintaining  delaunay triangulation,  optimized.
algorithm  slower   factor   .    surprise.
  extension  alpha complexes  expensive. .
,  requires additional radius certificates,  .
higher degrees   flip certificates needed  maintain.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 delaunay triangulation.   demonstrated  .
 algorithmic engineering,  overhead needed  alpha.
complexes   kept within  moderate bound.
. discussion.
 main contributions   paper   kinetic algorithm.
 alpha complexes   implementation  exact arithmetic.    theoretical obstacle  generalizing .
algorithm   implementation   weighted case, .
 different voronoi regions  restricted  within different size balls.   challenging problem   extension  bodies different  balls, . arbitrarily oriented.
ellipsoids.
 took  considerable effort  accelerate  implementation   kinetic alpha complex algorithm, since .
 necessary  compute examples  reasonable size  acceptable time.  instances computed  .  took .
. hours   best configuration. nevertheless,  .
opportunities   speed   software,  particular.
  level   algebraic kernel.  example,  .
 desirable  restrict  root isolation method  within .
given interval, without wasting  time  roots outside .
interval.  believe  kinetic data structures   important tool   topological analysis  time-varying shapes.
 hope   work  cell segregation initiates .
work   data.  facilitate  research,   .
useful   extension  cgal. package  kinetic data.
structures  transformed   experimental branch  .
redesign   package.   desirable    redesign.
solves  problem  degeneracies   implementation .
kinetic delaunay triangulations  alpha complexes. except   special cases,  current versions   algorithms   guaranteed  work correctly  two .
 events happen  exactly   time.
acknowledgments  authors thank viktoriia sharmanska .
discussions  help   .-dimensional prototype   implementation.
</doc>
<doc title='7_ALENEX_39.txt'>
downloaded  knowledgecenter.siam.org.
computational topology  normal surfaces.
theoretical  experimental complexity bounds.
benjamin . burton. joa. paixa. jonathan spreer.
abstract.
 three-dimensional computational topology,  theory .
normal surfaces   tool  great theoretical  practical.
significance. although  theory typically leads  exponential time algorithms,  little  known  .
 algorithms perform  .typical. scenarios,   far.
 best known theoretical bounds    real worstcase scenarios.   study  combinatorial  algebraic complexity  normal surfaces    theoretical  experimental viewpoints. theoretically,  obtain.
new exponential lower bounds   worst-case complexities   variety  settings   important  practical computation. experimentally,  study  worst-case.
 average-case complexities   comprehensive body.
 roughly three billion input triangulations. many  .
lower bounds   first known exponential lower bounds.
  settings,  experimental evidence suggests .
many   theoretical lower bounds  worst-case growth.
rates may indeed  asymptotically tight.
. introduction.
 three-dimensional computational topology, many important problems  solved  exponential-time algorithms. key examples include haken. algorithm .
recognising  unknot .,  breaking   triangulated .-manifold   prime decomposition ., .
   contrast  two dimensions   many.
problems  solved  polynomial time,  higher dimensions   important topological problems .
become undecidable ., .
 common feature  many  three-dimensional.
. first author  grateful   australian research council.
  support   discovery projects funding scheme.
.projects .  .  work  done.
  second author  visiting  university  queensland.
   thankful   funding  faperj   visit.
computational resources used   work  provided  .
queensland cyber infrastructure foundation.
.school  mathematics  physics,  university .
queensland, brisbane, australia. bab.maths.edu.
.department  mathematics, pontif.cia universidade.
cato.lica, rio  janeiro, brazil, jpaixao.mat.puc-rio.
.school  mathematics  physics,  university .
queensland, brisbane, australia. .spreer.edu.
algorithms,   source    solvability .
 exponential running times,   use  normal.
surfaces.  essence, normal surfaces  embedded .dimensional surfaces  intersect  surrounding .dimensional triangulation   simple fashion. .
importantly,  describe topological features using.
combinatorial data,   thereby well-suited .
algorithmic enumeration  analysis.
amongst   important normal surfaces .
 vertex normal surfaces.  correspond  .
vertices   high-dimensional polytope .called  projective solution space.,  together  generate .
space   possible normal surfaces within  input triangulation. many topological algorithms begin  enumerating  vertex normal surfaces   input triangulation,   many problems .  unknot recognition  prime decomposition.  enumeration  .
fact  main bottleneck   entire algorithm.
one remarkable feature  many algorithms .
three-dimensional computational topology  , although   extremely large theoretical worst-case.
complexity bounds,  appear   much easier .
solve  practice   bounds suggest.  example.
.  ., thurston asked   weber-seifert dodecahedral space  haken . precise meaning  .
  important . .  long-standing question became  symbolic benchmark  computational topology,    resolved  computer.
proof  . years .   heart   proof.
  enumeration   vertex normal surfaces.
   . .-tetrahedron triangulation. despite .
prohibitive . . poly.-time enumeration algorithm . best available   time.   best.
known bound  . vertex normal surfaces.
.,  enumeration ran  just . . hours  .
. vertex normal surfaces  total.
.  problem  unknot recognition   particular.
interest. modern derivatives  haken. original algorithm .   exponential time complexity.
.,     growing discussion   whether.
 faster algorithm might exist ., . certainly.
unknot recognition lies   .,  also . copyright . siam.
unauthorized reproduction   article  prohibited.
   assume  generalised riemann hypothesis . moreover, recent algorithmic developments.
based  linear programming now exhibit  experimental polynomial-time behaviour . deciding whether unknot recognition   worst-case.
polynomial-time solution  now  major open problem  computational topology.
 severe gap  theory  practice .
still poorly understood.  appear   two.
causes. .  best theoretical complexity bounds .
far  tight. . .pathological. inputs  exhibit.
high-complexity behaviour  rare,  .typical. inputs often far easier  work .
proving  claims mathematically remains extremely elusive. obtaining tight complexity bounds requires  deep interaction  topology, normal surfaces  polytope theory,    difficult  avoid.
making  loose estimates   least one  .
areas. understanding .typical. behaviour . .
average-  generic-case complexity.  hampered  .
 limited understanding  random .-manifold triangulations. even  simple task  generating  random .-manifold triangulation   tetrahedra  .
known sub-exponential-time solution .   setting, experimental work plays  crucial role  understanding  realistic performance  algorithms,  well.
  innate difficulty   problems   aim .
solve.
  paper  focus  attention   problem.
 enumerating  vertex normal surfaces within .
given n-tetrahedron input triangulation.  mentioned.
earlier,    central component. often  main.
bottleneck. many algorithms  computational .manifold topology. enumeration algorithms  still.
evolving ., .,    often hand-tailored .
 particular topological problem  interest.  .
reason    focus   complexity   specific.
algorithm,  instead  study two aspects  normal.
surface theory  affect  constrain   .
algorithms.
. combinatorial complexity.  study  total.
number  vertex normal surfaces within  input.
triangulation  ,   denote  . .  .
 main quantity  interest.  yields  immediate lower bound   time complexity  .
enumeration algorithm, since  determines  output size. moreover, . . also factors  upper.
bounds, since modern enumeration algorithms .
.specifically, since  vertex normal surface   described.
 . space .,  output size  . . .
designed  run faster  situations  . . .
small .
. algebraic complexity.  detailed  section .,.
 normal surface  described   non-negative.
integer vector  . .   settings, .
 investigate  maximum coordinate  .
vector   vertex normal surface within .
input triangulation  ,   denote  . .
 quantity  important   implementation.
 enumeration algorithms, since  affects whether.
  work  fast native machine integer types.
 whether  must fall back  significantly .
expensive arbitrary-precision integer arithmetic .
moreover, . . features  algorithms  extend.
 even avoid  enumeration problem.
.  algorithms,   recognising small.
seifert fibred spaces ., require  complete.
enumeration   just vertex normal surfaces.
  much larger .lattice.  normal surfaces.
whose size   function  . .
.  algorithms,   determining .
crosscap number   knot ., avoid vertex enumeration entirely  solving  integer program instead.   bounds  . .
feature  coefficients   integer program,.
 directly affect whether  program .
 solved using off-the-shelf integer programming software.
 summary,  focusing  attention  .
quantities . .  . .,  learn    .
behaviour  current enumeration algorithms,  also.
  intrinsic limits  behaviour   problem.
  seek  solve.
 approach  combinatorial  algebraic.
quantities . .  . .   theory  experiment. theoretically,  construct infinite .pathological. families  triangulations  section .  establish exponential lower bounds   worst-case scenario   . .  . . experimentally,  examine   worst case  average case behaviour.
  quantities  section ., using  comprehensive.
census  billions  input triangulations.
 results  highly important  practitioners.
 three-dimensional computational topology, particularly given  exponential nature  many key algorithms. despite , just one preliminary study  .
type appears   literature .  scarcity  results  two causes.
. tree traversal enumeration algorithm . current state.
  art.  running time . . poly.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.  lack  large, comprehensive censuses  .
.typical.  .atypical. triangulations.
  many censuses  .-manifold triangulations   literature,   typically focus  well-structured triangulations  special.
properties .  minimal triangulations,  irreducible manifolds.  triangulations  often.
easy  work  .,  offer little insight .
 algorithm. worst-case . even average-case.
behaviour.
   recently  large, comprehensive bodies.
 census data   developed  study .
triangulations   given input size ., .  using.
 censuses   experimental data,  ensure.
  identify pathological cases,  also gain.
 clear understanding   common  rare .
.
.  intense computation required  study normal.
surfaces   large bodies  data.
normal surface enumeration algorithms  enjoyed significant advances  recent years, .
modern algorithms now run many orders  magnitude faster   earlier counterparts ., .
 experimental work   paper required several years  combined cpu time,  without recent algorithmic advances ., ., .  work .
   possible.
 preliminary study  . examines  .
combinatorial complexity . .,  works   data.
set  roughly . million triangulations  closed .manifolds.  study   paper  significantly.
richer,   scope  detail.
.  examine  algebraic complexity . .  addition   combinatorial complexity . .
.  work   comprehensive data set  almost.
three billion triangulations, spanning  closed.
manifolds .  important  algorithms .
 prime decomposition.  bounded manifolds.
.  important  knot algorithms.
.  also examine  quantities  .optimised.
settings  arise  practical computation.
particular, one vertex triangulations . common.
optimisation used  many topological algorithms.,.
  restricted problem  enumerating  vertex normal discs .  important  unknot.
recognition,  testing surfaces  incompressibility.
 pathological families yield  first known explicit exponential lower bounds  worst-case complexity   computationally important settings .
bounded triangulations, closed .-vertex triangulations,.
 normal discs.  many settings  pathological.
families match  experimental worst-case growth rates.
precisely,   conjecture   resulting exponential bounds   fact exact.
 related note   result  hass  . ., .
establish  exponential lower bound   worst-case.
complexity   triangulated disc spanned   unknot.
 . .  particular relevance   complexity.
 unknot recognition.  result operates .
stricter geometric constraints,     yet known.
  translates    flexible setting  normal.
surfaces.
 emphasise    experimental data sets.
use exhaustive censuses   possible input triangulations   given size.  paper introduces  first.
 census  bounded .-manifold triangulations  .
literature, totalling  . billion triangulations  size.
 . .
 use exhaustive censuses    .
known efficient algorithm  randomly sampling large.
triangulations ., .,  although   .
methods  generating random .-manifolds ., .,.
nothing  known   bias   resulting sample.
 triangulations.   result, although  census .
large,  triangulations  contains   relatively.
small. nevertheless,   strong reasons  believe.
  experimental results  indicative  behaviour.
 larger inputs.  discuss    section .
. preliminaries.
  triangulation  ,  mean  collection   abstract.
tetrahedra . . ., . .  . ,     whose.
faces  affinely identified  .glued together.  pairs.
 . refers   four vertices  tetrahedron.
.   consequence   face gluings, many.
tetrahedron edges may become identified together. .
refer   result   single edge   triangulation,.
 likewise  vertices.  gluings must  .
 way   edge  identified    reverse.
  result. moreover,  tetrahedron face must .
identified  one   one partner . call .
internal faces.,   nothing   . call .
boundary faces.  set  boundary faces  called .
boundary   triangulation  denoted  . . .
. . .    called  closed triangulation, otherwise.
  said   bounded.   triangulations .closed.
 bounded. represent .-manifolds. however, unless.
otherwise specified,   true   triangulations.
presented   paper.
throughout  article,  gluings   triangles.
 given   bijection   vertices .abc. . .def.
  symbol .abc. denotes triangle .abc. .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
figure . normal triangles  quadrilaterals within  tetrahedron.
tetrahedron    order   vertices determines.
 gluing.  triangulation  defined   sometimes referred   generalised triangulation.  .
 general  flexible  simplicial complexes. .
important case   .-vertex triangulation,   .
tetrahedron vertices become identified together.
 face pairing graph   triangulation  .
 multigraph whose nodes represent tetrahedra, .
whose arcs represent pairs  tetrahedron faces .
 glued together.  face pairing graph may contain.
loops . two faces    tetrahedron  glued.
together., . multiple edges . two tetrahedra .
joined together along   one face. see figure.
.  examples.
 properly embedded surface     surface  .
   self-intersections,  whose boundary lies.
entirely within . .  normal surface     properly.
embedded surface  meets  tetrahedron .  .
  disjoint collection  triangles  quadrilaterals,.
 running  distinct edges  .,  illustrated.
 figure .   four triangle types  three.
quadrilateral types  . according   edges .
meet. within  tetrahedron  may  several.
triangles  quadrilaterals   given type. collectively.
  referred   normal pieces.  intersection.
  normal piece   tetrahedron  one  .
faces  called normal arc.  face  three arc types.
according   two edges   face  arc meets.
counting  number  pieces   type  .
normal surface  gives rise   .-tuple per tetrahedron.
   hence  .n-tuple  non-negative integers.
describing    point  ., called  normal.
coordinates.   point must satisfy  set  linear.
homogeneous matching equations .one   arc type.
  internal face.  equations  necessary .
 sufficient.  normal coordinates must also satisfy .
set  combinatorial constraints called  quadrilateral.
constraints,   discuss    journal.
version   paper.
 solution set   matching equations  .
  polyhedral cone . cross-section polytope  .
cone  also known   projective solution space. .
vertex normal surface  one whose normal coordinates.
lie   extremal ray   polyhedral cone ,.
 addition,  normal coordinates  minimal .
 integer points   ray. thus,   .
finitely many  vertex normal surfaces. every normal.
surface    expressed   positive rational.
linear combination   surfaces just like every.
point   polyhedral cone   positive rational linear.
combination  points   extremal rays.   ,.
 enumerating normal surfaces   triangulation,.
 typically just consider  finite set  vertex normal.
surfaces.
. theoretical lower bounds.
  establish lower bounds   worst-case values.
 . .  . ., .,  maximum possible . .
 . .   n-tetrahedron triangulation  . recall.
 . . measures  combinatorial complexity, .,.
 number  vertex normal surfaces within  , .
 . . measures  algebraic complexity, ., .
maximum coordinate   vertex normal surface .
 .
  results  known.    explicit.
lower bounds   worst-case . .   literature,.
   explicit lower bound   worst-case.
. .  given   family  closed triangulations .
. . . . . . .   section,  give.
new exponential lower bounds  . .  . .  .
variety  settings  hold particular relevance  key.
algorithms  computational geometry  topology.
 sketch  main constructions  results . see.
 journal version  detailed proofs.
. closed triangulations  many normal.
surfaces important .-manifold algorithms  .
prime decomposition often begin  converting  input triangulation   .-vertex triangulation, whereupon  subsequent processing becomes significantly.
easier .  . family  .    .
type . triangulation  . vertices.,  raises.
 question    bounds behave   .-vertex.
setting.
theorem .    family ,  . .,  closed.
.-vertex triangulations   tetrahedra  . .
. vertex normal surfaces.
 call  triangulations binomial triangulations,   precisely  .
.
.
.
.
vertex normal surfaces  genus     . ., . . . ,  .whereby.
. .
.
.
.
. .  construct    .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. .
.
.
.
.
.
. .
. . . .
. . . .
.
. . . . . .
.
. . . .
.
.
.
.
.
.
. . . .
.
.
.
.
figure . face pairing graphs   binomial family.
., triangulation ,  path family .,  bounded.
family ., triangulation  ,   closed family .
tetrahedra ., . . . ,.   following manner.
 begin  folding together two faces   .
tetrahedron . . .   gluing . . .
  . ., ., .   identify tetrahedra . .
.  . . . . . . . . .
 gluings identify   vertices   single vertex,.
therefore    .-vertex triangulation. see figure.
.   picture   face pairing graph   .
 . .    shown      closed .-vertex.
triangulation   .-sphere .see  journal version .
 article   details.
 see  . . .,  observe   .
tetrahedron   two normal .subsurfaces. .
 compatible    normal surface  .
triangulation. one   adds genus   overall.
surface     .  show  .
vertex normal surfaces  precisely combinations .
 subsurfaces, whereby  binomial coefficients .
. growth rate easily follow.
remark. experimentation suggests   family.
 might  fact yield  tight upper bound  closed.
.-vertex triangulations. see section .  details.
. bounded triangulations  many normal.
surfaces  number  vertex normal surfaces  .
bounded triangulation   direct impact  algorithms   unknot recognition  incompressibility.
testing .   give  first explicit exponential.
lower bound   worst-case growth rate   quantity.  proof  based   general construction principle .lemma . ,   arbitrary bounded triangulation . satisfying certain weak constraints, uses.
.
. .
figure . attaching two copies  .   tetrahedron .
 recursive squaring argument  obtain  family  triangulations .  . vertex normal surfaces,.
  exponential base .  derived  . .
choosing  suitable starting triangulation .,  obtain.
 explicit base . . . .corollary .
  unknot recognition  incompressibility.
testing,   improve  underlying algorithms .
 considering vertex normal discs .vertex normal.
surfaces   topologically trivial.  theorem .
 show   restricted quantity  also worst-case.
exponential.  build  family  triangulations .
. vertex normal discs.
lemma . suppose .   bounded triangulation .
. tetrahedra, .   boundary face  .   .
 vertices  .  identified  .,  .  one .
 three normal arc types  .    . vertex.
normal surfaces  .  meet .   least one arc.
 type .     normal arc types,  . .
 extended   family  triangulations .  .
 number  vertex normal surfaces grows   rate .
.,  . . .
.
. .
  proof .  detailed proof see  journal.
version.,  recursively construct   joining two.
copies  .   additional tetrahedron . along.
 faces . .see figure . suppose   .
vertex normal surfaces  .  meet .  .
arcs  type .   pair   surfaces .
 two copies  .,   combine  surfaces.
  way  extends  .  meet one  .
free faces   .  just one chosen normal arc type.
,   extension yields  vertex normal surface.
 .   .  pairings,  therefore.
. . .  vertex normal surfaces  . .
recurrence yields  final growth rate  . .
. . .
.
. .  need  assumption   .
vertices   boundary face .  identified  . .
show   triangulation  represents  bounded.
.-manifold.
corollary .    triangulation  . . .
  starting point   family  bounded triangulations .,  . .,   . . . . . . tetrahedra .
. . . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
. . .
.
.
.
.
lst., ., . . .
.
.
.
.
.
.
.
.
figure . left. construction   .-tetrahedron triangulation  lst., ., . right.  meridian disc . .
  .-gon  . normal quad, . normal triangles   maximum  . edge intersections.
 prove  using lemma .  choosing .
starting triangulation  . .  . . . tetrahedra.
  choice  face .  arc type .  . . . .
corresponding vertex normal surfaces.  yields .
growth rate  .  . . . . . .
 face pairing graph    shown  figure .  .
detailed construction see  journal version.
  final result,  construct  path triangulation    tetrahedra . . .,  . ., ., ,.
 joining tetrahedra .  .   map . .
.    shown      bounded.
triangulation whose underlying .-manifold   .-ball.
. details see  journal version.
theorem .    . .,   . .
.
. . . vertex normal discs.
 prove   obtaining explicit recurrences .
 number  vertex normal surfaces  different.
normal arcs based   matching equations.  .
essentially two choices   normal arc,  either.
 triangle  quadrilateral   added   previous.
triangulation giving  . growth rate. , see.
 journal version  details.
. lower bounds   size  normal coordinates   give exponential lower bounds .
 worst-case algebraic complexity . .  bounds.
follow  fibonacci growth rate  . .
.
. .
. understanding  worst-case . .  important  improving  time  space complexity.
 normal surface enumeration algorithms due   better handling   integer arithmetic involved .see section .
 obtain  lower bounds,  first construct .
family  bounded triangulations,  containing  vertex normal disc  coordinates growing exponentially.
  number  tetrahedra.   close  bounded.
family using  constant number  additional tetrahedra    vertex normal surface  exponential.
coordinates  preserved.   way,   able .
construct two families  triangulations, bounded .
closed,  fibonacci type growth rates  . .
 key objects   construction  so-called.
layered solid tori .   parameterised triangulations   solid torus.  layered solid torus denoted lst., ,  . .    boundary  triangulation   torus  exactly three boundary edges,.
   meridian disc . unique disc   solid.
torus meeting  boundary   non-contractible closed.
curve. intersects  boundary edges  ,    . .
points.
layered solid tori   common tools  constructing triangulations   given type  .-manifold.
.see ., ., .    constructing .manifolds.   prominent example   layered solid torus,  one tetrahedron triangulation .
lst., ., .,  shown  figure .
theorem .    family   bounded .vertex triangulations   tetrahedra,   contains  vertex normal disc   maximum coordinate.
.,   denotes  k-th fibonacci number.
 family  consists  layered solid tori  type.
lst.,.,.   vertex normal surface.
   corresponding meridian disc. see  journal.
version  details   proof.
 key idea   construction   closed family.
  n-tetrahedron triangulations containing  vertex.
normal surface  exponentially growing coordinates.
  find  small m-tetrahedron triangulation  .
  boundary   family  layered solid tori.
 acting like  type  plug.    mean  .
contains  normal surface intersecting .   .
way   intersects .    . .  gives rise .
 vertex normal surface    maximum coordinate.
greater   equal  . since   constant,.
 gives   asymptotic lower bound  . . .
closed triangulations   bounded triangulations.
remark. . triangulation  .    .tetrahedron bounded triangulation   . . .
    contains two vertex normal surfaces .
     combined   normal surface intersecting .    pattern  .  face pairing.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
input size  closed closed  .-vertex bounded.
. . . .
. . . .
. . . .
. . . . .
. . . . . . .
. . . . . . .
. . . . . . . .
. . . . . . . . . .
. . . . . . . . . . .
. . . . . . . . .
total  . . . . . .  . . . . . .  . . . . .
 . . . . . .
table .  number  .-manifold triangulations   census.
. .
figure . intersection   .left.   .right.  .
graph    shown  figure .,   intersection.
      boundary .  shown  figure .
 detailed description     found   journal.
version.
theorem .    family   closed .-vertex.
triangulations   tetrahedra,  . .,  containing.
 vertex normal surface  maximum coordinate .
least .   . . mod .   least . . otherwise.
 outlined ,  construct   gluing .
  along  boundary tori.   . . mod .,.
 meridian disc . glued   combination  .
  yields  vertex normal projective plane , .
 . ., . mod ., twice .   combination  .
  yields  vertex normal sphere.  maximum.
coordinates    stated. see  journal version.
 details.
 note   vertex normal sphere  .
.  case  . ., . mod .    non-vertex.
linking normal sphere  . detecting  normal.
surface types  one   key tasks  important .manifold problems   prime decomposition. hence,.
 family    example   case ,  order.
 prove  existence    normal sphere, dealing.
 exponentially large normal coordinates  .
avoided.    hint towards  conjecture  .
problems  intrinsically hard  solve using normal.
surface enumeration methods.
. experimental behaviour.
 turn now   experimental study   combinatorial  algebraic complexities  vertex normal surfaces.  experimental data consists   closed .manifold triangulations   . . tetrahedra,  .
bounded .-manifold triangulations   . . tetrahedra . appearing precisely    relabelling.
 shown  table .,  yields almost . billion.
triangulations  total . . . . . . . . .
. . . .  also extract  . . billion .vertex triangulations   closed census  additional study.
generating exhaustive censuses   possible inputs requires sophisticated algorithms  significant.
computational resources.   . .-tetrahedron.
census   closed triangulations first appeared .
. . also describes    underlying algorithms.   . .-tetrahedron census   bounded.
triangulations  new   paper. moreover,  .
constructed  bounded census   . .,  .
. billion triangulations. however,   use  . .
  experiments   subsequent analysis .
normal surfaces   . . remains    computational reach .  . .  analysis already consumed.
years  cpu time.
table . summarises  experimental results, .
gives worst-case  average-case measurements .labelled max  avg respectively.   quantities.
. .  . .   various settings.  measurement  taken   relevant census  triangulations.
 table .  closed  bounded columns refer   closed  bounded triangulations respectively.
  closed .-vertex column  restrict  attention.
 .-vertex triangulations  closed manifolds,  .
 bounded, discs column   count vertex normal discs .  vertex normal surfaces.   also.
measured  algebraic complexity . .   .-vertex.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
input combinatorial complexity . . algebraic complexity . .
size  closed closed .-vertex bounded bounded, discs closed bounded.
max avg max avg max avg max avg max avg max avg.
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . . . . . . . .
. . . . . . .
. . . . . . .
growth . . . . . . . . . . . .
table . experimental worst-case  average-case results.
combinatorial complexity . . algebraic complexity . .
lower experimental upper lower experimental upper.
bound growth bound bound growth bound.
closed . . . . . .
closed .-vertex . . . . . .
bounded . . . . . . . .
bounded, discs  . . . . . . .
table . summary  worst-case theoretical  experimental results.
 discs-only settings,   omit  details due .
space constraints. see  journal version   paper.
  details.
 final row  table . gives  .best estimate.
  exponential growth rate   quantity .
respect   . just list  base   exponential,.
ignoring  coefficients  polynomial factors. .
growth rates  estimated  linear regression., though.
 cases   worst cases matches  known family.
 triangulations .see .  give  corresponding.
known rate.
  make  broad observations  table .
.  average-case scenarios grow   significantly.
slower rate   worst-case scenarios, sometimes astonishingly .   consistent .
past observations   .typical. triangulations.
exhibit significantly smaller complexity properties.
 expected .see section .
.  closed manifolds, .-vertex triangulations .
give   slight improvement.  worst case.
drops   . . . family described  .    . family  theorem .  closeness   results  surprising,.
.specifically,  take  weighted linear regression  log . .
log .   function  .  weights  taken   ., . . . , , .
order  limit  influence  anomalous small cases.
since  theoretical bounds  . .  .-vertex.
triangulations  much smaller   general.
bounds .see .,  algorithms  working.
   often much simpler .
. bounded triangulations exhibit higher complexity.
properties   closed counterparts. .
 combinatorial complexity . .  discrepancy   pronounced.even  average case .
bounded triangulations  well   worst case.
 closed triangulations.    consistent.
 past experiences  working  normal surface algorithms . restricting  attention .
normal discs .,  unknot recognition.  alleviate  problem somewhat.
table . compares  experimental behaviour .
 worst-case . .   best known theoretical.
lower  upper bounds . .lower bounds. refers .
families  pathological triangulations   highest.
known growth rate  . .,    constructed.
 section .
regarding . .  lower bound  . .
.  known  .,   remaining three.
lower bounds  new   paper .theorem .,.
corollary .  theorem .  first two upper.
bounds  taken  .  final two . bounds.
 well known    appear   literature . .
proof  refer   journal version. regarding . .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 four lower bounds  . .
.
. . .
 new   paper .theorems .  .,  .
four upper bounds  taken  .
  see   experimental growth rates.
 much closer   lower bounds   upper.
bounds.  particular,  arrow . indicates  .
experimental worst-case growth rate  identical  .
best lower bound .   constant factor.  invites.
 following conjectures.
conjecture .  closed triangulations,  maximum number  vertex normal surfaces . .  .
given  grows   asymptotic rate  . .
.,   closed .-vertex triangulations  reduces  .
 closed triangulations  well  closed .-vertex.
triangulations,  maximum coordinate   vertex.
normal surface . .   given  grows  .
asymptotic rate  . .
.
. . . .
bounded triangulations,  maximum coordinate  .
vertex normal disc   given  likewise grows  .
asymptotic rate  . .
.
. . .
 closed .-vertex triangulations,  experimental.
data gives  even stronger result.
theorem .  closed .-vertex triangulations, .
maximum number  vertex normal surfaces . . .
 given  . .  precisely .,   attained  .
binomial triangulations   described  section .
conjecture . theorem .  true   positive.
integers .
. discussion.
 noted   introduction, although  consider.
close  . billion distinct triangulations,   .
relatively small  less   equal  . tetrahedra.
despite ,   reasons  believe  .
experimental results might generalise.  .
allow  flexible triangulations . just simplicial.
complexes.,  census contains  rich diversity  .manifolds .including . distinct closed .-irreducible.
manifolds ., . moreover, several   patterns.
  see  table . . particular theorem . .
established early    remarkably consistent.
  exception,   case  arbitrarily bounded.
manifolds,  greater number  tetrahedra seems .
allow  better choice   starting triangulation .
 lemma .  order  obtain  higher exponential.
base.
 seen  table .,   still  long way  .
 lower bounds  upper bounds  worst-case.
complexities converge.     paper produce  first explicit lower bounds  several computationally important settings,   also gives strong experimental evidence   lower bounds  close.
 . even exactly. tight.  suggests    now.
 upper bounds  require significant improvement,.
inviting new directions  research   rich interplay.
 topology, polytopes  complexity theory.
</doc>
<doc title='8_ALENEX_25.txt'>
downloaded  knowledgecenter.siam.org.
inducing suffix  lcp arrays  external memory.
timo bingmann., johannes fischer.,  vitaly osipov.
kit, institute  theoretical informatics, . karlsruhe, germany.
.timo.bingmann,johannes.fischer,osipov.kit.edu.
abstract.
 consider text index construction  external memory.
.  first contribution   inducing algorithm .
suffix arrays  external memory. practical tests show.
  outperforms  previous best  suffix sorter.
.dementiev  ., alenex .   factor   two.
 time  .o-volume.  second contribution  .
augment  first algorithm  also construct  array .
longest common prefixes .lcps.  yields  first .
construction algorithm  lcp arrays.  overhead .
time  . volume   extended algorithm  plain.
suffix array construction  roughly two.  algorithms.
scale far beyond problem sizes previously considered  .
literature .text size  . gib using  . gib  ram .
 experiments.
. introduction.
suffix arrays ., .  among   popular data.
structures  full text indexing.  list  suffixes .
 static text  lexicographically increasing order. .
  allows  efficiently locate arbitrary patterns.
 unstructured texts .like dna, east asian languages,.
etc.  time proportional   pattern length .
opposed  text length.,  also fast phrase searches.
., .     .   suffix array  built.
  phrase beginnings  .
 first   important step  using suffix.
arrays   efficient construction   index .suffix.
sorting.,  term .efficient. encompassing  time.
 space.  recently,  text indexing community  confronted   dilemma   .
theoretically fast algorithms  constructing suffix arrays .linear-time  integer alphabets.   rather.
slow  practice .,   superlinear algorithms.
existed  outperformed  linear ones   realistic.
instances,  terms   time  space .,.,. .
particular,  extremely elegant difference cover algo.supported  dfg spp .
.supported   german research foundation .dfg.
.partially supported   project . . .peppher.
ict-.
rithm .  short.  .rkka.inen  . ., .
 quickly become  showcase string algorithm .
 now  taught  many computer science classes.
around  world,  reported   . times slower.
  best superlinear solutions, even   careful implementations .
 situation changed   . nong  .
.,  cite  recent journal versions whenever.
possible. presented another extremely elegant linear.
time algorithm called sais   also fast  practice.
.based   induced sorting principle . despite.
 almost in-place  faster  . almost .
fast .  previous algorithms   practical inputs,.
 worst-case guarantees also imply    .
similar behavior   inputs,    engineered.
superlinear algorithms .,.,., etc.  exist .bad.
inputs   running time shoots   several.
order  magnitudes.
nonetheless,  simplicity   . algorithm.
.mostly sorting  scanning. enables straightforward.
adaptation   advanced models  computation.
.pram, , distributed, etc.,  usually leads .
optimal algorithms   models.  fact,   .
fast  implementation  . .  outperformed.
  external suffix sorters  practice   time.
  writing.  external implementations  .
.  variant . confirmed  results .
 many applications .,  fast string matching.,.
 suffix array needs   augmented   longest.
common prefix array .lcp array  short.,  holds.
 lengths  longest common prefixes  lexicographically consecutive suffixes.  internal memory,  lcp.
array   constructed sufficiently fast. indeed, .
currently fastest algorithm . also uses  induced.
sorting framework   sais  based.  .
 model,  . suffix sorter   augmented .
also construct  lcp array within sorting complexity. however,    aware   previous implementation   approach. another purely theoretical solution   use   suffix tree algorithm .
 constructing lcp arrays  derive  lcp array    euler tour   tree.  approach.
. copyright . siam.
unauthorized reproduction   article  prohibited.
seems even less suitable   efficient implementation.
    couple  semi-external construction algorithms .,.,.,  .semi-external. means .
  need  arrays  ram,   parts.
  scanned.
 point    truly external lcp array.
construction algorithm    missing piece  .
fast practical  suffix tree construction, , .
barsky  . ., . . say   survey  .
suffix trees. . conversion   suffix array  .
suffix tree turned    disk-friendly, since reads.
  suffix array  writes   suffix tree .
 performed sequentially. however,  suffix array.
needs   augmented   lcp information .
order   converted   suffix tree.  also.
comment   possibility  adapting external .
 lcp arrays. .  currently  clear  efficient.
 presented algorithm   lcp computation .
   practical implementation.  finally .
say. . may   one step  divides   .
scalable solution  constructing suffix trees  disk .
inputs   type  size.    done,  whole.
world  new possibilities will  opened, especially .
 field  biological sequence analysis.  present.
paper closes  gap,  outlined   following section.
. contributions.
.  contributions. motivated   superior.
performance   sais algorithm   suffix.
array construction algorithms  internal memory, .
 paper  investigate   induced sorting principle.
  exploited also    model.   two.
goals  mind. . engineer   suffix sorting .hence.
also bwt. algorithm  outperforms  currently.
best one .  keeping  within sorting complexity,.
 . implement  first external memory lcp array.
construction algorithm   faster   .-based.
approach.    algorithms  based  .
induced sorting principle . thus,  make  first.
comparative study  suffix arrays    includes.
 induced sorting principle, since  previous studies.
., .  conducted   advent  sais.  . .,.
 show  sais  suitable    model .
reformulating  original algorithm    uses.
 scanning, sorting, merging,  priority queues.
 former three operations  certainly doable .
,    also  priority queues achieving.
sorting lower bounds   theory .   practice.
.,.  make  careful implementation decisions.
 order  keep  .o-volume low.   result,.
 new algorithm, called esais,   two times.
faster   em-implementation  . . .
. volume  reduced   similar factor.  .
proceed  engineer  first fully  algorithm .
lcp array construction.   . times faster .
  implementation  lcp construction using .
.recall     implementation . .
increase   time  . volume  esais .
lcp array construction compared  pure suffix array.
construction   around two.
 algorithms scale far beyond problem sizes previously considered   literature.  sum,  experiments reported   paper took . computing days.
 . tib . volume.   extreme end,  .
build  suffix-array   . gib xml dump  .
english wikipedia  . .sec per character using .
. gib  main memory,   total   . tib.
 generated .o-volume.  results  never .
reported .
.  related work. general-purpose .
string sorting routines   described  arge.
 . .   also practical  methods .
constructing related text indexes like  burrowswheeler transform .  recent paper . describes .
 lcp array construction algorithm   specific.
case  short dna-reads . , due   quadratic.
dependency   length   longest read, .
suitable  arbitrary strings.  completely different.
research topic  pursued     use  external.
suffix array  efficiently answer queries. see . .
. preliminaries.
 ., . . ., . . . , .  ., . . ., . . . ,  . . .
ranges  integers,  .cond . ., .   boolean.
variable indicating  truth  condition cond.
given  string  . . . . . .   characters.
drawn   totally ordered alphabet .,  call .
substring  . . . . . .  i-th suffix   . .
 simpler exposition,  assume  .   unique.
character .   lexicographically smallest, although.
 implementation   rely    sentinel.
character.  suffix array sat     permutation.
  integers ., .,   tsat . . tsat .
.lexicographic order  always intended  comparing.
strings  .  denote  inverse permutation .
sat  isat .  companion array lcpt  defined.
 lcpt . . lcpt .sat . . .,sat .,  lcpt .
remains undefined  lcpt ., .   length  .
longest common prefix .lcp.   suffixes    .
. induced sorting toolkit. following previous.
work .,  classify  suffixes  two types.  .
.  suffix   type.     . .,  .
otherwise. suffix .  fixed  type . furthermore,.
 distinguish  .left-most. occurrences  either type.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .  .  precisely,   .    s-type .
.  l-type. symmetrically,   .-type    ltype  .  s-type.  last suffix . . .
 always .,   first suffix  never .  .
sometimes  also say  character    type.
using  classifications, one  identify subsequences within  suffix array.  range  suffixes.
starting    character   called  c-bucket,.
   composed   sequence  l-suffixes followed  s-suffixes.  also define  repetition count.
  suffix   rep. . maxk. . . . . . . .
.   . subbuckets    decomposed  ranges  equal repetition counts,  .
call repetition buckets.
 principle behind induced sorting   deduce.
 lexicographic order  unsorted suffixes   set.
 already ordered suffixes. many fast suffix sorting.
algorithms incorporate  principle  one way .
another .   built   following inducing.
lemma .
lemma .   lexicographic order   .-suffixes.
 known,   lexicographic order   l-suffixes.
  induced iteratively smallest  largest.
proof.  start   . .   lexicographically.
ordered set  .-suffixes. iteratively, choose  unsorted l-suffix  .  , among  unsorted lsuffixes,  smallest first character   smallest rank.
 suffix . within ,   .  already  .
  properties,  .     .  . .
follows due   transitive ordering  l-suffix chains,.
    inserted     next larger l-suffix.
 procedure ultimately sorts  l-suffixes, .
   .-suffix   right.
analogously,  order   s-suffixes   induced.
iteratively largest  smallest,   relative order  .
.-suffixes  known. therefore,  remains  find .
relative order  .-suffixes.
  .-suffix ,  define  .-substring.
., . . . ,  .,     next .
.-suffix   string.
 last .-suffix .  fixed    sentinel .substring  .  call  last character   .
.-substring  overlapping character. .-substrings.
 ordered lexicographically,   component.
compared first  character    type, lcharacters  smaller  s-characters  case .
ties.  partial order allows one  apply lexicographic.
naming  .-substrings .  representing .
.-substring   lexicographic name   superalphabet ., one  efficiently solve  problem .
finding  relative order  .-suffixes  recursively.
suffix sorting  reduced string  lexicographic names.
 .-substrings.
. induced suffix sorting  external memory.
 first goal   design   algorithm based  .
induced sorting principle  runs  sorting complexity.
   lower constant factor  . . .
basis   algorithm   efficient  priority-queue.
. .,  suggested   proof  lem. . since.
  derived  ram-based sais,  call  new.
algorithm esais .external suffix array construction .
induced sorting.  first comment  details  .
pseudocode shown  alg. .,    simplified variant.
 esais. . .   devoted  complications .
arise due  large .-substrings.
  denote  reduced string consisting  lexicographic names  .-suffixes.  objective  lines.
.   create  inverse suffix array isar, containing  ranks   .-suffixes   .  line .,  input.
 scanned back-to-front,   type   suffix .
 determined  , .,  type. . . thereby,.
.-suffixes  identified,   assume   .
.-suffixes  . .-substrings  , plus.
 sentinel .-substring.   .-substring, .
scan creates one tuple.  tuples   sorted .
described   end  . . .note   type  .
character inside  tuple   deduced   characters   type   overlapping character. .
sorting,  line .  .-substring tuples  lexicographically named  respect   .-substring ordering,.
  output tuple array   naturally ordered .
names  . .,.  names must  sorted back .
string order  line .  yields  reduced string ,.
wherein  character represents one .-substring. .
 lexicographic names  unique,  lexicographic.
ranks  .-substrings  simply  names   .lines.
. otherwise  ranks  calculated recursively .
calling esais  inverting sar .lines .
 isar containing  ranks  .
.-suffixes, .
apply lem. .  lines .   contains quintuples ., , , ., . . . , ., .  ., , .  .
sort key,   composed  character , indicator.
 . type.   .   relative rank   suffix .
 efficiently implement lem. ., instead  checking .
unsorted l-suffixes,  design    create  relative order  .  l-suffixes  described   proof.
extraction    always yields  smallest unsorted l-suffix, ,   l-suffixes within  c-bucket .
sorted,  smallest .-suffix   unsorted preceding.
l-suffix  position  . . .hence . . . thus diverging slightly   proof,    contains.
l-suffixes   .  already ordered, plus  .
.suffixes  .    ordered.    time.
  contains    items.  line .,  .
 initialized   array .,   built  line .
 reading  input back-to-front , re-identifying.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
algorithm . esais description  tuple pseudo-code.
. esais. . . . . . . begin.
. scan  back-to-front, create . . .  . .,. .   .-suffixes,  sort .-substrings.
 . sorts. . . . . .  ., , type. . ., . . ., .,  . .,. . .  . . . .
.  . . ., . . . lexnames. . . choose lexnames  . .,.  .-substrings.
.  . . . ., . . sort.  second component. . . sort lexnames back  string order.
.   lexnames     unique .
. sar . esais. . recursion  . . . .
. isar . .  . ., . . sort. .sar., . .  . .,. . . . invert permutation.
. else . .sort sorts lexicographically unless stated otherwise.
. isar .  . isar   generated directly.
. . . . . , , isar., . . . . ., . . ., . . ., .,  . .,. . .  . . .
. . . .,  . createpq.
.  ., , , . . . . ., .
.  ., , , . . . . ., . . .extractmin.  . induce  next .  l-suffix.
.   .   .append., . . save   next l-type  .
.  . .   .insert., , ., . . . . ., . . . .  l-type.
. else .append. ., , ., . . . . ., . . . .  s-type.
. repeat lines .  construct   .
. array  inverted  order  .s--.
. return .  . ., . . merge., . .   . , . .  .reverse.  first component. .
.-suffixes  merging  isar  get  rank .
 tuple. notice   characters  .-substrings.
 saved  reverse order.   loop  lines .
 repeatedly removes  minimum item  assigns.
  next relative rank  enumerated  .   .
inducing process.   extracted tuple represents .
l-suffix,  suffix position   saved     next.
l-suffix   ti-bucket .line . extracted .
.-suffixes.
    output.   preceding suffix . .
l-type,   shorten  tuple  one character .
represent  suffix,  reinsert  tuple   relative rank .line . however,   preceding suffix.
.  s-type,   suffix   .-type,   must.
 saved   inducing  s-suffixes .line . .
   empty,  l-suffixes  sorted  , .
. contains  .-suffixes ranked   lexicographic.
order. see fig. .   example   process.
  array .   loop  repeated  sort.
 s-suffixes .line .  process  symmetric .
  order  reversed  using .s-- instead.
 incrementing.  . .  occurs,  tuple .
 dropped,     need  recreate .
array . .  l-suffixes  already sorted. .
     computed,  suffix array .
 constructed  merging together    ssubsequences bucket-wise .line .    .
reversed first,   s-suffix order  generated.
largest  smallest. note    formulation .
alphabet .   used  comparison.
. splitting large tuples.   detailed description  alg. .,  must point  two issues .
occur    setting.  .-substrings  usually  short,  least three characters long  .
average four,  pathological cases   encompass.
nearly  whole string. thus  line .  alg. ., .
tuples  grow larger   . block ,  one.
   resort  long string sorting .  seriously,   special case  .    .-suffix,.
 while-loop  lines . inserts . characters,.
 leads  quadratic . volume.  issues .
due  long .-substrings,   will deal  .
differently.
long string sorting     dealt  using.
lexicographic naming  doubling ., sect. . however, instead  explicitly sorting long strings,  integrate  doubling procedure   suffix sorting.
recursion  ultimately  need  sort short strings.
 line .  alg. .   done  dividing  .substrings  split substrings  length   ,.
starting   beginning,  lexicographically naming  along    substrings. thereby, .
long .-substring  represented   sequence  lexicographic names   reduced string.  corresponding.
split tuples  formed    way  .-substring.
tuples   ,  also overlap  one character, except.
  character need   .-type.   recursive call, long .-substrings  correctly ordered among.
  .-substring due  suffix sorting,  split tuples  easily  discarded  line .    .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
algorithm . inducing step  .-substrings split  .  , replacing lines .  alg. .
.  . . . . . . . . . . , . . . . . . .,  . .,. . . split positions,  . . .
. . . sort. . , isar., . . . . ., ,. .  . .,  . max.,  .,  . .,. .
.  . sort. . , rep., , . . . . .,. .  . ,  . max.,  .,   l-type .
.  . sort. . , rep., , . . . . .,. .  . ,  . max.,  .,   s-type .
. . . .,  . .,  . ., . . stack.,  . createpq.  ., , . . . . ., , .
.  .notempty.  .
.notempty. .
.  .empty.   . .topchar.  ., , . . . . ., , . . .top. .
. .insert., ., . . . . ., . ., ., .pop. . induce  .-suffixes.
. . . ,  . .topchar.,  . . . .,  . .,  . . . next a-repetition bucket.
.  .topchar. .   .toprank. .   . induce  l-suffixes.
. ., , . . . . ., , . . .extractmin., .append., . . save   next l-type.
.  . . . .
.  . .   .insert., ., . . . . ., . ., . . .  l-type.
. else .append. ., ., . . . . ., , . . . .  s-type.
. else  . . .   . .  .append., ., . . need continuation.
. foreach merge. ., , , . . ., . . sort. .  ., , , ., . . . , ., . . . .
.  . .   .insert., , . . . . ., . ., . . .  l-type.
. else .append. ., , . . . . ., , . . . .  s-type.
correspond   .-suffix.  d-critical version .
sais ., sect. .   similar approach.
 second issue arises due  repeated re-insertions.
 payload characters     line ., possibly.
incurring quadratic . volume.    handled.
 splitting  .-substrings, now starting   end,.
 chunks  size .   . .  indicating .
 split  ,   . .   actual split length.
lines .  alg. .    replaced  alg. .,.
  will describe   following.    .
set  splitting positions, counting first .  .
 characters backwards starting   .-suffix .
 preceding .-suffix  met.  ,   .substring  tuple  stored   . array, except .
  initial . payload characters  copied. .
call  items seed tuples.   .-substring consists.
   . characters,  continuation tuple .
stored  one   two new arrays     lines.
., depending   type   overlapping character.
 overlapping character  will later  used together.
  repetition count rep.  efficiently match.
continuation tuples  preceding tuples .see . . .
 definition  repetition counts. rep.  easily.
calculated  reading  text back-to-front. along.
  seed  continuation tuples  save  flag.
. marking whether  continuation exists.
differing  alg. .,  line .    initialized.
 empty  . will  processed   stack. .
modification separates   loop  inducing.
 .-suffixes  lines .  inducing  lsuffixes  lines .  two induction sources .
alternated ,  precedence depending  .
top character. .topchar. .   ., , ., , . .
.top. since l-suffixes  smaller  .
.-suffixes.
  start    character,   loop.
 . may  induce  .-suffixes   first.
character  smaller  .topchar. otherwise,.
  loop  .  precedence.  line .
 reached,  loop  . extracts  suffixes .
  starting  ,    . stack must.
 checked .  lines .  extracted tuple .
handled   alg. ., however,     preceding.
character .   tuple   continuation flag  .
set,  tuple underruns   matching continuation.
must  found.   underrun tuple,  required.
position    assigned rank .  saved  .
buffer  ,  will  sorted  merged  .
 array  line . matching   continuation tuple.
  postponed    smallest rank   .
continued tuple may  reinserted   . .
earliest rank   . .,  set  line .,  .
reinsertion will   . .,  thus   loop.
. extracts exactly  ra-th repetition bucket .
.  continuation tuples must   matched.
exactly  per repetition bucket,  continuation.
tuples  sorted  . , rep., ., whereby   .
sequentially merged      kept sorted  .
first component   scanned   stack.
 . .  compute  optimal values  .  ,.
 analyze  resulting . volume.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 .
.
.
.
lexname.
.
.
.
.
recursion.
sar.
.
isar.
.
.
.
.
.
.
.
.
.
while-loop.
.
.
.
.
. sat.
induce .
.
file.
node.
streaming.
node.
sorting.
node.
algorithm . algorithm . alg. .
figure . data flow graph   algorithm. numbers refer   line numbers  alg. .  alg. ., respectively.  input.
  read  saved   file .,  creating tuples. sorting  tuples yields  , whose entries  lexicographically.
named   .  sorted   string index, resulting   .  names   unique  ,  algorithm calls.
 recursively .  calculate sar.  suffix array  inverted  isar .  resulting ranks  merged   .
create seed  continuation tuples .,   distributed  sorters .,.,.  alg. .  main while-loop .
reads  array .  priority-queue . depending   calculation,  while-loop outputs final l-suffix order.
information  , stores merge requests    tuples underrun, reinserts  shortened tuple,   saves .
.-tuples.
merge requests  handled  matching tuples     .  reinserting  .   while-loop .
inducing l-suffixes finishes,  process  repeated  seed tuples  .  continuation tuples  , yielding .
final s-suffix order values   .  output suffix array  constructed  merging    .
. . analysis  esais  split tuples.
 now analyze  overall . performance  .
algorithm  find  best splitting parameters . .
,   practical assumptions.  will focus .
calculating  . volume processed  sort  lines.
.  .,    pqs.
 simplicity,  assume     one elemental data type, disregarding  fact  characters   smaller  indices,  instance. thus .
tuple  composed  multiple elements  equal size.
 write sort.  scan.   number  .
needed  sort  scan  array   elements.  .
practical experiments  assume  . . ,  thus .
relate sort. . .scan.,   equivalent  saying   elements   sorted  one in-memory.
merge step.  parameters  . . . gib. .
 . . . mib.,  used   experiments,   .
. pib. elements   sorted   assumption.
furthermore,  also assume     amortized.
. complexity sort.  sorting  elements,  assumption   supported  preliminary experiments.
  analysis  denote  length  .-substrings.
excluding  overlapping character, thus  sum .
 lengths   string length.   simplicity,.
 assume  line .  alg. . always stores continuation requests   ,  unmatched requests  later.
discarded. thus  analysis  ignore  boolean.
continuation variables.
  broader view   algorithm,  abstracted.
alg. . .including alg. .   pipelined data flow graph.
 fig. .
lemma .  minimize . cost alg. .  use.
 . .  . . .  splitting .
.-strings.
proof.  first focus   number  elements sorted.
 scanned   algorithm  one .-substring .
long length . .    . .  splitting  period.
  set . . .   proof  count amortized.
costs sort. per element sorted  scan. per.
element scanned.   possible,   . .
.-substrings.
 processed   algorithm sequentially.
 one .-substring  algorithm incurs sort.
.  sorting . .line .  sort. . . . . . . .
 sorting    .lines .      total.
 sort. . .
.
. . . . . . . occurs due  repeated.
reinsertions   pqs  decreasing lengths. .
buffer  .line . requires   sort. . . . . .,.
 reading      already accounted .
additionally,   scan. . . occurs .
switching     via .
.,   least  first scharacter  removed. overall,   sort. . .
.
.
. .
.
. . . . . . scan. . .,   minimized .
 .
.
. . .,  assuming sort . .scan.
taking  . .,  get   sort. . .scan.
per .-substring.
next,  determine  value  . .  length.
   start splitting  .  offset  due.
  base overhead  using continuations  just.
reinserting   . given  .-substring  length.
., repeated reinsertions without continuations .
incur sort. . . .  putting  quadratic.
cost  relation   one  splitting   . ., .
get   length . . .  cost   approaches.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 balanced. therefore,  choose  start splitting .
. . .
theorem .   string  length   . volume.
 alg. .  bounded  sort. . scan., .
splitting   . .  . . .  alg. .
proof.  bound  . volume,  consider  string.
 consists  . .
.-substrings  length .,  determine  maximum volume   . . . . , .
. . .   smallest possible length  .-substrings,.
due  exclusion   overlapping character. alg. .
needs scan.  read  twice . lines .  . .
sort. . . . .  construct   line ., counting .
overlapping character  excluding  boolean type,.
   encoded  .   sort  .
volume  lexnames.  already accounted . creating  reduced string  requires sorting   , .
thus sort. . . . .   suffix array  .
reduced string   . . .  computed recursively.
 inverted using sort. . .,   names  already.
unique.  creating isar, alg. .  used   parameters derived  lem. ., incurring  amortized.
. cost calculated    . .
.-substrings. .
final merging     .line . needs scan.
 sum  .
 . . scan. . sort. . . . . sort. . .
.  . . . sort.
.
. . . . scan.
. .min.sort. . . . . scan. ,.
sort. . . . . . . . scan. . . .
maximizing  ., .  . . . .   . . .,  get.
 ., . .  ., . . sort. . scan. .  . .
, solving  recurrence,  ., . . sort. .
scan.  . .  worst-case string  constructed .
.-substrings  length . . .
. inducing  lcp array  external memory.
  section  describe  first practical algorithm.
 calculates  lcp array  external memory. .
general method  integrating lcp construction .
sais  already  described . ,  adapt.
    model    deal  issues .
  arise   ram implementation . .
 latter   implemented recursively.  .
recursion,   assume   lcp array lcpr .
 reduced string   calculated together  sar,.
   base case  unique lexicographic names.
lcpr  simply filled  zeros. calculation   lcp.
array lcpt   original text  done  two phases.
first lcpr  expanded   array lcps. containing.
 lcps  lexicographically consecutive .-suffixes .
 ,     lcp values    suffixes.
 induced  solving semi-dynamic range minimum.
queries .rmqs.  .
. expanding  recursive lcp array.
given  recursively calculated lcp array lcpr,.
 first show   calculate lcps. . .
lcpt .
.
sar., .
.
sar.
.,    maximum number  equal characters .  ,   . starting  two.
lexicographically consecutive .-suffixes. see also fig. .,.
 gives  example   concepts presented  .
section.
  two main issues  deal . firstly, .
reduced character    composed  several characters.
  . apart   obvious need  scaling .
values  lcpr   lengths   corresponding .
.substrings,  note  even different characters  .
   common prefix    thus contribute.
  total lcp.  example,  fig. .  first two.
.-substrings .aba.  .acbba.  start  .
., although   different characters  . .
second issue   lexicographically consecutive .suffixes   lcps encompassing   one.
.-substring  one suffix,     . .
example,  .-suffix . . .acbbabacbbc.  . .
.acbbc.   lcp  .  spans two .-substrings.
  latter suffix.
 handle  issues, additional information must.
 precalculated   .-substring splitting .
lexicographic naming steps  lines .  alg. .  splitting  line .,  .-substring tuples must .
amended   repetition count   overlapping.
character,  . sorts. . ., . . . ,  ., , type., rep. .
., . . ., .
.
.,  . .,. .,  must also influence  sorting  naming  .-substrings,  described   next paragraph. furthermore,  store.
 length   .-substring . split string  large .substrings  split., minus  one overlapping character,   array called sizes. . . .
.
. . .  . .,. .
 string order. lastly,  lexicographic naming,.
 compute  lcps  lexicographically consecutive.
.-substrings   array lcpn ,  later use .static.
rmqs  lcpn  find  common characters  arbitrary .-suffixes.
 final formula  computing lcps.  given .
lcps. . .
sar.lcpr.
.sar.
sizes. . . rmqlcpn ., .
 . . isar.
.
sar. . lcpr.
.
. .
 . . isar.
.
sar. . lcpr.
.
,.
  first part sums   sizes   common.
lexicographic names  consecutive .-suffixes,  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 . . . . . . . . . . . . . . .
               .
type.  . . . .   . . . . .  . .
.
sizes.
. . . . . .
. . . . . .
 . . . . . .
sar . . . . . .
lcpr . . . . . .
lcps. . . . . . .
. . . .  ., , type., rep. lcpn.
., ., , . . .
.aba., ., , . . .
.aba., ., , . . .
.acbba., ., , . . .
.acb., ., , . . .
.bbc., ., , . . .
figure . example   structures     recursive call   induced sorting algorithm. left.  top.
part shows  text,  classification  suffixes   reduced string     algorithm  run recursively. .
resulting suffix  lcp arrays    shown   lower part .sar  lcpr. whereas  former   direct.
correspondence   .-suffixes   ,  latter needs   expanded  lcps.  account   different alphabets .
  . right. additional information needed  expand lcpr  lcps.  sorted array  , consisting  .-substrings.
 associated information.  last column lcpn shows  lcps  lexicographically consecutive .
.-substrings.
rmq delivers  lcp   following unequal pair,.
 explained .  lcpr. . .,   whole.
expression reduces  lcpn .,  one  except.
 must point   fine detail  lcpn . .
.sais, components  .-substrings  compared first.
 character    type.  lcp construction,.
however,   interested    common characters. thus  equal characters  different type.
 encountered,  number  repetitions   distinguishing character  match   .-substrings.
must  added   lcp.   sufficient since  .
 character occurs  different types,  .
differing types  defined   next differing character   suffix,  one suffix      ,.
  therefore must  different. thus  common.
characters    position must  equal   distinguishing character .  particular,  implies.
   need  look one .-substring ahead.
 example, regard  penultimate row  .
right side  fig. . even though    . common characters  .acb.   preceding .-substring.
.acbba.,    .  lcpn   .
.-substring.
.acb.   repetition count  .
like  lcp calculation,  .-substring sort order must  adapted  also encompass  repetition.
count   overlapping character.  , overlapping  characters  smaller   characters.  two.
overlapping  characters,  one  lower repetition.
count  considered  smaller. symmetrically,  two.
 characters,  one  higher repetition count .
smaller.
 established  lcps.   principle calculable,  now discuss   implement  algorithm.
   model. according  . ., two subproblems must  solved efficiently  external memory.
range sums  sizes.  range minimum queries .
lcpn .  first  solved  preparing query tuples .
 sum boundaries   performing  prefix-sum.
scan  sizes. .
  static range minimum queries  lcpn , .
follow  common ram-technique .  precompute.
. potential subqueries   scan  lcpn ,  store.
  disk.  actual queries  divided  .
subqueries, sorted,  merged   precomputed.
queries .first  left,   right query end.  final.
sort  query ids brings  answers  subqueries back.
together.  technique  already sketched  .
. algorithm .
. inducing  lcp array.  now explain .
 construct  lcp array lcpt   input string.
 , given  lcp-values  .-suffixes     array.
lcps. ,  explained .  general idea   follow.
 inducing mechanism  explained  . .  induce.
 lcp-values along   suffix array values .
first look   inducing  l-suffixes .lines .
.  alg. .   follows,  imagine  array.
. consisting   suffix array values  suffixes.
  extracted   priority queue   line .
 alg. . .last element    quintuple.,   order.
   extracted .hence . consists   fifth.
components  ., plus  second components  .
likewise,  define  array lcp. consisting  .
corresponding lcp array values. hence,  aim  .
augment   loop  lines .  alg. .  also.
compute lcp. .  lcps  .
.-suffixes  exactly.
 array lcps. ,  computed .  next show.
  compute  entries  lcp.   l-suffixes.
suppose  line .  just   append ., .
  array . , right next   tuple . , .
. .
 . .    . . .  goal   determine.
,  lcp  suffixes   .   . see also fig. .,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . . . . . . . . . .
. . . . . . . . . . . . . . .
lcp. . . . . . . . . . . . . . .
.   .
. . . . . . . . . . . .
. . . . . . . . . . . .
lcp. . . . . . . . . . . .
  .
figure . example   inducing step. left.   string  fig. .,  suffix-  lcp-values   l-suffixes .normal.
font.  induced   lcps  .-suffixes .bold font.  variable . refers  lines .  alg. .  notation.
.  lcp.  used  denote    lcp values extracted   priority queue   line .  alg. . right.
 reverse process .line .  alg. .,   s-suffixes  induced   .-suffixes.
 shows  situation  terms   . reality.
nonexistent. arrays .  lcp. .  suffixes.
 caused  inducing    .  .  .,.
respectively,  due  lem. .  two latter suffixes.
 lexicographically smaller  suffix . .hence also.
smaller  . now observe   suffixes  .
.  exactly  suffixes .  .   new.
character  prepended. hence,  lcp    .
 exactly one    lcp  .  .
 . . .,   lcp   . . otherwise,.
due   lexicographic ordering   suffixes, .
lcp  .  .   obtained  taking .
minimum   lcp. -values   positions .
 suffixes.  lcps    suffixes  already.
known either  lcps  .-suffixes   induction.
 l-suffixes. hence,  . rmqlcp. . . ., . . . .
 true lcp-value    .  outputting ., .
 line .  alg. .,  .     positions .
.  .   partial suffix array.  positions.
.    available directly   .   .
relative ranks .   preceding  current quintuple.
 remains one exception   lcp   last lsuffix   first s-suffix within  bucket, however, .
case  easy  handle . using  repetition counts .
 suffixes.
 example, look   inducing  suffixes . .
.   left part  fig. .  suffixes start  char. . .
. . . . . . . . . . . . . . . .  . . . .
lcp. . . . . . . . . . . . . . . .  . . . .
. .
figure . general scheme   inducing step. .
inducing ,  lcp value  . rmqlcp.
. . ., . . . .
 derived using  rmq   previous  current.
relative ranks   induce sources, .  .
acter .  suffixes  caused  inducing  .
 .  positions .  .  . , respectively, .
starting  .  lcp  .,   determined .
 trivial range minimum query rmqlcp. ., . . .
therefore,  set lcp. .  .
 rmqs delivering  lcp values  created.
 batch  inducing  answered afterwards,.
forming  lcp array.  notice   .
interdependent .  implies  rmq problem .
 faced    fact  dynamic problem.  solve.
,  decided   explore    well known.
 data structures   buffer trees .  suitable.
 solving  task within sorting complexity. instead,.
 made  highly realistic assumption   main.
memory size   large enough    . .
,  precisely,  .  .   small constant.
 . one gib  main memory   . .  .
 implementation  means   handle problems.
 size  . ., almost one exabyte.  assumption.
  lax   one used  . .
  assumption   split  array.
lcp.  blocks  size  .  .   keep .
lcp. -values   current block  ram. ,.
  keep  minima   . . . previous blocks  ram.  build succinct semi-dynamic.
ram-based rmq-structures   arrays,   .,.
sect. .  every range minimum query  .
split  three subqueries.  first  last subquery.
 contained   block  size ,   middle.
.possibly large. subquery perfectly aligning  block.
boundaries   ends.  former two subqueries.
 answered   block  held  ram,  .
latter subquery  answered   last block  contains   processed.  takes overall . time.
 . .
 made  additional optimizations  cases.
 lcp. -values   induced without range.
minimum queries. one interesting case  related  .
repetition counts. consider among  l-suffixes   cbucket . . .  first suffixes starting  , , ccc,.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
etc.  lcp-values  .,.,., etc.,   exactly.
 repetition count.  current repetition count,.
however,   known variable .  extracting.
  ,  thus  lcp   set immediately.
without  rmq.  optimization turned   .
 effective  highly repetitive texts.
finally,  note    also implemented.
 completely in-memory version  rmqs  relies.
  fact    right-to-left minima .looking.
left   current position .  candidates  .
minima. except  pathological inputs   .
.  right-to-left minima,   minimum.
  bucket boundary  zero. therefore   fit.
 ram    searched   binary manner .
using  involved heuristics .
. experimental evaluation.
 implemented  esais algorithm  integrated.
lcp construction  . using  external memory.
library stxxl .  library provides efficient external memory sorting   priority queue   modeled   design  cached memory . note.
  stxxl  . operations bypass  operating system cache. therefore  experimental results .
 influenced  system cache behavior.  implementation  selected input files  available .
http.tbingmann.esais.
 describing  experiments,  highlight.
 details   implementation.  notably,.
stxxl   support variable length structures,.
   aware   library    .
therefore,   implementation  tuples  .
   associated arrays   fixed length, .
superfluous . transfer volume occurs. due  fixed.
length structures,  results   . analysis .
 tuning parameter   directly  used. .
found   . . . .  good splitting values .
practice.  results   algorithms  verified.
using  suffix array checker ., sect. .   semiexternal version  kasai. lcp algorithm . .
possible.  designed  implementation  use .
implicit sentinel instead  .,.   input containing.
zero bytes   suffix sorted  well. since  goal.
  sort large inputs,  implementation  use.
different data types  array positions. usual .-bit.
integers   special .-bit data type stored  five.
bytes.  input data type  also variable,  .
experimented  usual .-bit inputs,   recursive.
levels work internally   .-bit data type.
 sorting ascii strings  memory,  efficient inplace radix sort .  used. strings  larger data types.
 sorted  ram using . stl. version  introsort.
 initial sort  short strings    implemented.
using  variable length tuple sorter.
 chose  wide variety  large inputs, .
artificial   real-world applications.
wikipedia   xml dump    recent.
version   pages   english wikipedia, .
 obtainable  http.dumps.wikimedia.org. .
dump  dated enwiki-.
gutenberg   concatenation   ascii text.
documents  http.www.gutenberg.org.robot.
harvest  available  september .
human genome consists   dna files .
 ucsc human genome assembly . downloadable  http.genome.ucsc.edu.  files .
stripped   characters  ., , , , .  normalized  upper-case. note   input contains .
long sequences  unknown  placeholders,  influences  lcps.
   decimals  , written  ascii digits.
 starting  .
skyline   artificial string   esais .
maximum recursion depth.  achieve ,  string.
suffixes must  type sequence lsls . . .   .
level  recursion.   string   constructed.
  length  . .,  . ., using  alphabet.
. . . ., ., . . . , . .   grammar . . .,  .
.iti.   . ., . . . , .   . .   . .
 . . . ., , , ,  .,  get dcdbdcdadcdbdcd. .
 test runs  replaced .  .  input skyline.
 generated depending   experiment size,  .
inputs  cut  size.
 main experimental platform    cluster.
computer,  one node exclusively allocated .
running  test instance.  nodes   intel xeon.
. processor clocked  . ghz  . mib .
level . cache.   tests  one core   processor.
 used.  node  . gib  available disk space.
striped  raid . across four local disks  size.
. gib.  rest  reserved   system.  limited.
 main memory usage   algorithms  . gib .
ram,  used  block size  . mib.  block size.
 optimized  preliminary experiments.
due   limited local disk space   cluster.
computer,  chose  run  additional, larger.
experiments  platform .  intel xeon .
processor clocked  . ghz  . mib  level .
cache.  main memory usage  limited  . gib.
ram,  kept  block size  . mib    six.
local sata disk  .   local space  available.
programs   platforms  compiled using .
.  .  native architecture optimization.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . .
.
.
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. construction time.
. . . . .
.
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
. . volume.
plot input . . .
wikipedia xml . . mib .
gutenberg text . . mib .
human genome . . mib .
decimals   . .
skyline .worst-case. . blog. .
esais .
. inputs.
. . . . . . .
.
.
.
input size  .
.
.
.
.
.
.
.
.
. average lcp.
figure .  first row shows construction time  . volume  esais .open bullets.  . .filled bullets. .
experimental platform .  second row shows selected characteristics   input strings.
. plain suffix array construction.  noted.
  introduction,  previously fastest  suffix.
sorter  . .  adapted  optimized .
original source code.,   already implemented.
using stxxl,   current setup  larger data types.
 implementation  . exists   reported  .
 . faster   special case  human dna .,.
    include   experiments.
figure . shows  construction time  .
volume  esais  .  platform  using .-bit.
keys.  two algorithms esais .open bullets.  .
.filled bullets.  run  prefixes  ., .   five.
inputs,   skyline  generated specifically.
  size.  total  plots took . computing.
days   . tib  . volume,    .
one run  performed     . test instances.
  real-world inputs esais. construction time.
  half  .  . volume required .
.http.algo.iti.kit.edu.dementiev.esuffix.docu.
esais  also   .   volume  .
 two artificial inputs exhibit  extreme results .
 designed  provoke.   random input  short.
lcps,    easy case  . nevertheless,.
esais  still faster,   twice  fast.  results.
 esais. worst-case skyline show another extreme.
esais  highest construction time   worst input,.
whereas .  moderately fast  skyline .
efficiently  sorted  triples.  high . volume.
 esais  skyline  due   maximum recursion.
depth, reducing  string   .  filling  .
 . items   level.   implementation.
requires  . volume  sorting,  .
recursively combines short runs  keep  arity .
mergers  main memory small. even though .
reduces  . ,  recursion depth  limited  log. .
 sorting   straightforward.
besides  basic esais algorithm,  also implemented  variant  .discards. sequences  multi. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
construction time.
. . . . .
.
.,.
.
.
.
.
.
.
.
.
.
.
.
itb.
.
.
.
.
.
.
.
.
.
. .
.
. volume.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . .
.
.
.,.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . .
.
.,.
.
.
.
.
.
.
.
.
.
.
itb.
.
.
.
.
.
.
.
.
.
. .
.
. . . . .
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . .
.
.
.,.
.,.
.
.
.
.
.
.
.
.
.
.
.
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
. .
.
esais esais-lcp .external rmq. .
esais discarding esais-lcp .internal rmq. .-lcp.
figure . subfigures . show construction time  . volume   six implementations run  platform   three.
different inputs. subfigures . use .-bit positions,  . runs  .-bit.   right hand side, .
.
indicates.
. volume  bytes per input byte.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. . . . . . .
.
.
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
input size  .
.
.
.
.
.
.
.
.
.
.
. .
.
esais esais-lcp .internal rmq. .
figure . measured construction time  . volume  three implementations  shown   largest test instance.
wikipedia run  platform  using .-bit positions.
ple unique names   reduced string prior  recursion ., . however,  discovered   optimization  much smaller effect  esais   .
suffix sorters .see fig. . .   probably due.
  induced sorting algorithm already adapting .
efficiently   input string. characteristics.
. suffix  lcp array construction. .
implemented two variants  lcp construction. one.
solving rmqs   .lcpext.,    entirely.
 ram .lcpint.   solution saves rmqs.
 disk   inducing process,  constructs.
 lcp array   queries    .
completed. contrarily,  ram solution precalculates.
 lcp   induced position   in-memory.
structure  saves  lcp   . thus  lcp.
array  constructed    time    .
extracting   .  size   in-memory.
rmq structure  related   maximum lcp  .
number  different inducing targets within one bucket,.
 grows   . mib   human genome.
 in-memory rmq construction also requires .
preceding character .   available  processing.
  loop,  restriction  requires  overlap .
two characters  continuation tuples  thus leads .
 larger . volume. since   variant  . .
lcp construction  stxxl  available,  extended.
 original implementation  suggested  .
figure . . shows  results   six variants.
  algorithms   real-world inputs run .
platform .  observe  esais-lcp internal .
external   first viable methods  calculate suffix.
array  lcp array  .  version  .-lcp.
finishes  justifiable time    small instances.
  real-world inputs  construction time  esaislcp  never   twice  time  . without.
lcp construction.  expected, in-memory rmqs .
consistently faster  em-rmqs  also require.
fewer ., even though   tuples  larger.
 exhibit experiments  building large suffix.
arrays,  configured  algorithms  use .-bit.
positions  platform . figure . . show results.
  wikipedia  gutenberg input    .,.
 larger instances require  local disk space.
 available   node   cluster computer. .
average   tests instances  wikipedia, calculation.
using .-bit positions take  .  construction.
time   expected .  . volume.
 size  suffix arrays    built  platform   limited   local disk space.  therefore.
determined  maximum disk allocation required. table . shows  average maximum disk allocation measured empirically   test inputs  .-bit .
.-bit offset data types.
 platform     necessary . tib disk.
space required  process  full wikipedia instance,.
  results  shown  fig. .  maximum.
size   in-memory rmq structure   .
. mib. sorting   whole wikipedia input .
esais took . days  . tib . volume,  .
esais  lcp construction .internal memory rmqs.
took . days  . tib . volume.
esais -lcpint -lcpext . -lcp.
.-bit . . . . .
.-bit . . . . .
table . maximum disk allocation  bytes required  .
algorithms, averaged  rounded    inputs.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
. conclusions  future work.
 presented  better external memory suffix sorter.
  also construct  lcp array. although .
implementations  already  practical,  point.
  optimizations   yield  even better performance   future.  esais  largely.
compute bound,   efficient internal memory priority queue implementation, .  radix heap, may improve suffix array construction time significantly. another fact   lead  significantly better performance    reinsertion     always .
 last tuple   current repetition bucket. thus .
. main-memory merge buffer   bypassed .
many cases. performance  inputs relying heavily .
sorting .like   skyline.  also  improved .
sorting .-substring deeper   three characters.
    short.   whole,  potential   speed improvements  optimization  esais .
higher   .  also note ,  final recursive stage  also output  burrows-wheeler transform . directly   extracted  tuple, instead.
  suffix array. obviously,  real-world applications one  stop sorting  external memory .
 reduced string   suffix sorted internally. .
 currently  implemented. finally,   possible .
combine  two variants  esais-lcp .internal .
external rmqs.  one algorithm   bounded inmemory rmq structure,  unanswered rmqs .
saved    solved later.
</doc>
<doc title='9_ALENEX_42.txt'>
downloaded  knowledgecenter.siam.org.
lempel-ziv factorization. simple, fast, practical.
dominik kempa. simon . puglisi.
abstract.
 decades  lempel-ziv . factorization .
  cornerstone  data compression  string processing algorithms,  uses    still  uncovered.  example, .  central  several recent text indexing data structures designed  search.
highly repetitive collections. however,  many applications computation   factorization remains  bottleneck  practice.   paper  describe simple .
fast algorithms  computing  . factorization.
 new methods consistently outperform  previous approaches  practice, use less memory,  still.
offer strong worstcase performance guarantees.  common feature   new algorithms   avoidance .
 longest-common-prefix array, essential  nearly .
prior art.
. introduction.
   three decades  lempel-ziv . factorization .    fundamental tool  compressing data.  many aspects  .  .
heavily studied   time, efficient computation  .
factorization remains  bottleneck  many applications.
 recent focus   field  compressed fulltext indexing ., .    indexing highly.
repetitive collections. several types  large, modern.
data contain high amounts  duplication  relatively.
long substrings,  indexes based  . exploit.
particularly well ., ., .  data includes .
new  rapidly growing genomic collections produced.
 high-throughput sequencing technology ., ., .
versioned collections  source code  multi-author.
documents,   wikipedia .  web crawls .
efficient index construction  stated   open problem.
  .  .
   traditional setting, compression  files.
using  .zip tool .,   based  ., .
grown popular recently   now bundled  .
linux distributions. .zip  also effective  storing.
collections  files  later require fast random access,.
.supported  part  academy  finland grant .
.algodan.
.helsinki institute  information technology .hiit., department  computer science, university  helsinki.
   case  information retrieval systems ., .
.zip,  capable  superior compression  gzip .
 also .-based.  large files   factorizes.
large blocks. however   measurements .see also.
  kreft  navarro . indicate  .zip.
 high memory overheads  factorization, .
 memory peak  around . bytes,   block  .
bytes.  efficient factorization algorithms  allow.
bigger blocks   processed   less time,  thus.
 immediate practical benefit  systems  users.
aside  compression  indexing, . factorization finds multifarious uses   algorithmic tool .
string processing,  particular  efficient detection .
periodicities  strings ., ., ., ., ., . periodicities.
 turn  diverse applications throughout computer.
science,   fields  bioinformatics, data mining, .
extremal combinatorics.
 contribution.    applications.
 mind,   paper  describe several efficient.
methods  computing  . factorization.  aim.
  develop fast, practical algorithms  operate .
 memory range common  previous algorithms .
 problem.  .  . bytes,   input string.
  symbols.
 common feature   algorithms   work.
 always related .though  different ways.   number  factors   resulting . factorization. .
makes  particularly effective  highly repetitive.
inputs   small factorizations, though  consistently outperform prior methods   types  input,.
repetitive  .
two highlights .  algorithm  uses .
bytes  memory,   . times faster  .
previous fastest algorithm   memory level. .
 algorithm using . bytes   faster  .
 algorithms   literature .usually   factor .
almost two. finally,   focus   algorithms.
  efficient  practice,  new algorithms also.
come  solid asymptotic guarantees  performance.
previous work.  recent survey . outlines .
many .mostly recent. algorithms  . factorization,.
nearly    make use   suffix array .
 longest-common-prefix .lcp. array  intermediate.
data structures ., .  . factorization parses.
 string  length    .  longest previous factors.
. copyright . siam.
unauthorized reproduction   article  prohibited.
. give  precise definition shortly. almost   .
algorithms   survey,   ones since  ., first.
compute  longest previous factor .lpf.  every.
position   string,     final step select just.
 involved   . factorization.  many .
algorithms, computing  .extra. lpf values seems.
unavoidable.  starting position   jth factor.
depends   sum   lengths    . . factors.
prior  ,     tell ahead  time .
positions will  involved   factorization.
 .  . contain experimental evaluations.
  various factorization algorithms described  date.
 used  results   papers  guide .
experiments,  particular  select  best algorithms.
 comparison. along  way  also noticed .
anomalies   performance   algorithms, .
 discuss    section .
. preliminaries.
strings. throughout  consider  string  .
. . . . . .  . .  . . symbols. .
first  symbols    drawn   constant ordered.
alphabet,  size .,  comprise  actual input. .
final symbol .   special .end  string. symbol, .,.
distinct   lexicographically smaller   .
 characters  .
 order  account   practical memory usage.
  algorithms  assume . . . .corresponding.
, say,  ascii alphabet.   . . thus .
symbol requires . byte  storage   length  .
  pointers   require . bytes .
  . ., . . . ,   write .  denote  suffix.
   length  .  . .,   . . . .
. . . .  will often refer  suffix . simply .
.suffix . similarly,  write .  denote  prefix.
   length  . .  write .  represent .
substring . . . . .    starts  position.
  ends  position .
suffix arrays.  make use  several standard.
data structures built  .  first    .
suffix array     array . containing .
permutation   integers .   . .
. . . . . . .   words,.
. .  iff .   jth suffix    ascending.
lexicographical order.  inverse suffix array isa .
 inverse permutation  ,   isa. .  iff.
. . . conceptually, isa. tells   position .
suffix   .
 burrows-wheeler transform, denoted bwt .
 string bwt.   permutation   defined  ,.
  bwt. . ., except  . . .,.
  case bwt. . . none   algorithms.
explicitly build  bwt,    used implicitly .
 places.  also make use  ,  so-called.
last-to-first mapping.   usually defined  terms .
bwt,   will  convenient    define  .
following way. . .  iff . . . . ., except.
 . . .,   case . . isa.
finally,  lcp., . denote  length   longestcommon-prefix  suffix   suffix .  example, .
 string  . zzzzzapzap, lcp., . . . . ., .
lcp., . . . . .zap.
.  . factorization uses  concept .
 longest previous factor .lpf.  lpf  position.
  string    pair ., .  ,  . ,.
. . .  . . .
  words, . . . . .   longest prefix .
.  also occurs   position  .   .
note   .   leftmost occurrence   symbol.
      exist.   case  adopt .
convention   . .  . . . note also .
 may    one potential ,    .
care  one  used.
 . factorization . . parsing.   string.
   just  greedy, left-to-right parsing   .
longest previous factors.  precisely,   jth .
factor . phrase.   parsing   start  position ,.
  output ., . . represent  jth phrase., .
  . phrase starts  position . ., unless.
. . .,   case  next phrase starts  position.
.  call  factor ., . normal   satisfies  . .
 special otherwise.
  description  . allows . .  .
 . . . .  . . . . .  overlap .
.  definition  .  sometimes called selfreferential.  . parsing algorithms  describe.
  adapted  produce non-self-referential parsing,.
  exotic forms . ., ., though  will.
assume  self-referential style throughout.
  example string  . zzzzzapzap,  .
factorization produces  pairs.
., ., ., ., ., ., ., ., ., .
. speeding   lightweight . algorithm.
 first contribution   series  optimizations .
 factorization algorithm due  chen  ., called.
cps. .  original algorithm  two interesting.
properties. firstly,   unique among . factorization.
algorithms    avoids computation   lcp.
array.   reason   one    spaceefficient algorithms known, even considering algorithms.
 use compressed data structures ., . secondly,.
 produces .  order, one factor   time, avoiding.
computing longest previous factors    positions .
 input first.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
plain . . .
.
.
.
.
.
.
.
.
.
kernel.
.
.
.
.
.
.
.
.
.
parsing.
rmq.
intervals.
plain . . .
.
.
.
.
.
.
.
.
.
english.
.
.
.
.
.
.
.
.
.
.
.
.
.
parsing.
rmq.
intervals.
figure . improvements  runtime  various optimizations   cps. . factorization algorithm.  use typical.
repetitive .kernel.  non-repetitive .english. files .details  section . times  seconds per gigabyte.    fast.
interval computation optimization using  levels  lookup tables.    small ranges scanning trick   . .
cps. makes use  ,   preprocesses  fast.
range minimum queries .rmqs. .  range minimum.
query rmq., . returns  position   minimum.
value  . practical implementations  data.
structures supporting fast rmq  now well established.
 compute  factor starting  position , cps.
works  . rounds.  round .  computes .
range   suffix array . containing  .
suffixes  .   prefix.   generic round.
 cps. maintains  invariant   active range,.
. . ., contains   suffixes prefixed  .
. however,  also enforces, via rmq. , .,  .
least one suffix  . . . begins   position.
 . .  course   potentially  lpf  position ,.
  soon   active range   hold  suffix.
less  ,  . factor    known.
cps. moves  one round   next, .
 range . . .  range .,  binary.
searching  find  extents .  ., considering.
 . . . symbols   suffixes  . . . .
 correct    lexicographic ordering  .
.  effect  suffix .   searched  one.
symbol   time  .
. fast interval table computation  important optimization  cps.    described  .
  appears   source code   algorithm.
implementation   computation   lookup table.
storing  extents   interval   symbol .
 suffix array,   minimum value   interval.  precisely,   distinct symbol    .
table stores  triple ., ,.,    suffixes.
prefixed   lie  .,     minimum.
value  .
assuming  alphabet   small constant .
usual . symbols say.  table  small  .
 accessed  constant time.   factor looking.
  interval   table allows  first round .
 successive binary search process   bypassed,.
avoiding  cache misses,  leading   consistent.
improvement  overall factorization times.
   interested  total factorization.
time,  time  initialize  lookup table matters.
   mentioned cps. code,    .
computed  scanning  left-to-right  observing.
 . . . . .      points.
 one interval ends  another starts. however,.
   unpredictable order   values  ,.
computing intervals  way causes roughly one cache.
miss  time  access    examine  symbol.
 leads    first optimization. instead .
scanning   repeatedly accessing    order, .
instead scan ,   cache-friendly left-to-right manner.
  scan  increment  counter   symbol,.
 later prefix sum  counters  obtain  correct.
., . intervals      symbol.  .
scan     also trivially compute  minimum.
  interval.   simply  position   first.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
occurrence    .
  optimization   compute two levels .
lookup tables. one  single symbols  one  symbol.
pairs,       . entries.  allows.
  skip two rounds  binary search instead  one,.
   bigram table  still small enough  fit.
 cache,    greatly increase initialization time.
. time spent scanning   build  lookup tables.
 big files  increase  memory consumption .
 extra table  negligible.
. scanning small ranges   improvement.
 cps. makes use   following easily proved lemma,.
due  crochemore  ilie . . later restated .
ohlebusch  gog .
lemma .     starting position   normal.
. factor   . .resp. .   first value.
smaller     left .resp. right.     .
 lcp., . . lcp., .,  ., . . ., lcp., .,.
otherwise, ., . . ., lcp., .
  binary search phase  cps.,  .
size   range drops   predefined threshold ,.
 stop using binary search   instead scan .
range  . time  find .  .   compute.
lcp., .  lcp., .,  depending   .
greater, output .  .   . factor starting.
 .
setting  . .log . preserves  . log . overall.
runtime  cps.,   scanning scheme  requires.
three cache misses     faster  .
binary searching,  even  small ranges  still.
attract two   cache misses per round .
accessing   narrow  current range.  practice.
 found  . .  give  best performance.
 optimizations  cps.  summarized .
figure .,  shows  incremental improvement.
 runtime achieved  cache-sensitive single-symbol.
interval computation, two-symbol intervals,  finally.
scanning  small ranges.  right   figure.
shows times  several different settings  .  far.
 biggest boost comes   improved interval.
computation,    tricks consistently improve.
performance.
. factorization   inverse suffix array.
 last improvement  cps. used lemma .   way.
 abandon  binary search steps  favour  fast.
short sequential scans     text.  family .
algorithms   section exploit lemma .   different.
way.  use  inverse suffix array isa  first locate.
    position isa.,   search    .
either direction   position,  locate .  .
algorithm .
. . .
.   .  .
. scan .isa.  find .
. scan .isa.  find .
.  lcp., . . lcp., . .
. ., . ., lcp., .
. else.
. ., . ., lcp., .
. output factor ., .
. . . .
figure .  . algorithm,  uses , isa,   .
compute   factorization.  ease  presentation .
assume  .  . exist   factor.  will .
always   case ., say, .   leftmost occurrence.
  symbol  .   cases  easily handled.
 simplest implementation   scheme  .
store isa explicitly, using . bytes,   sequentially.
scan   find .  .  call  algorithm.
. .  uses . bytes  total  , isa,  .
pseudocode  given  figure .  compute  .
factor starting  position ,  use isa  locate  .
  constant time.   scan left  right  .
 find .  .  sum   lengths   scans.
 clearly   ,  size  .    factors.
 runtime  thus .   worst case.
  initially hoped   tighter analysis .
.  lead   faster worstcase bound,  .
following string illustrates  things  indeed get.
quite bad   algorithm.     log n-bit.
binary code   number  . .  example, .
log  . ., . . ., . . ., . . .,  . . .
now,   . log .  consider  following binary.
string.
 . .
. . . . .
. . . . .
.
 initial segment      contains suffixes.
prefixed  .   . log .   suffixes,.
  occur  increasing order  ,  ,  segment      lie looks like. ., , ., ., . . .
  . . log . .
now consider  operation  .  factorizing .   factor starts   position  . .mod .
  algorithm will scan  left  right  position isa.   elements   segment  .
 increasing,  scan left  . will stop immediately,.
however  scan right  . will  . least.  .
right end   segment,   will require . log .
time.        every  . .mod ., overall runtime will  . log .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
although  analysis   rigorous,  .
suggest  bad case exists,  prompted   generate.
 . megabyte instance  string . cps. factorized.
 file  . seconds,  . laboured away  .
minutes  . seconds.
. adding asymptotic guarantees  dismal.
performance  .  string    result  .
algorithm sequentially scanning   isa.  find.
.  .  scanning   avoided   first.
preprocess   build  data structure  answer.
next-smaller-value .nsv.   previous-smallervalue .psv. queries.  found  nsv.psv data.
structure  .novas  navarro .  perfect .
 needs,  space efficient, fast  answer queries,.
 fast  initialize. without getting   many.
details,  data structure offers  space-time tradeoff,.
namely.  requires . bytes  answers queries .
. log. time.
 call  version  .   auxiliary.
nsv.psv data structure isa. setting . . .log .
ensures isa. runs  . log . time overall.  practice  found  higher value  . led  faster runtimes,.
 allowed   reduce space overheads   negligible level.  using  nsv.psv data structure .
find .  .  runtime  isa.  string   .
reduced    respectable . seconds.  brevity.
  points onwards  assume . . .log .
. reducing space requirements  now show.
  reduce  space requirements  isa.   .
careful representation  isa,    adversely.
effect runtime.  well known property  suffix arrays,.
  burrows-wheeler transform,  isa. . . .
.isa.  property   essence   bwt.
inversion algorithm ., .   fm-index . .
 property  mind,  approach   sparsify isa.
 store  every kth value  .  sample.
values  stored   array  . values   still.
 accessed  constant time.  non-sample value.
 . .mod .   recovered  needed  looking.
  first sample larger  ,  . isa. . .,.
  following   mapping  .  mod  times.
starting  .
 problem  now  represent  compactly.
  describe two approaches  found  .
effective  practice.  first one implements  .
rank queries   bwt.  second uses  sparse.
representation    exploits  presence  .
rle-lf.    implemented  answering rank.
queries   bwt   input string .see, . .
 particular, . . .bwt. . rank.,  .
  total number  symbols less  symbol  .
 whole  ,  rank. tells   number .
occurrences  symbol bwt.  position   bwt.
data structures  supporting rank  well studied,.
  implemented  tested many  .  .
 nsv.psv data structure,  require  solution .
answers queries quickly,   also fast  initialize .
memory efficient.  found  following approach .
 best  highly repetitive inputs.
 high degree  repetition    manifest  runs.
 equal letters   bwt  .     number .
runs  bwt.   run  store  starting position.
 bwt, say ,   number  occurrences  bwt.
 position   bwt.  answer rank.  binary.
search   starting positions   runs,  locate.
 starting position   run   falls , say .
 answer  rank.   rank.,   stored.
earlier  , plus  . ,  number  occurrences .
bwt.    .  solution requires . bytes.
 answers rank.  .log . time,   factorizes.
 .  log  .  log . time overall.
sparse-lf.  second approach  computing .
makes  assumption   repetitiveness  .
input,  exploits  presence  .   different.
  usual contexts     computed.
 inversion  indexing   bwt  available.
  symbol   store  position  every bth.
occurrence    bwt, storing . integers  total.
  symbols.   want  compute . .
first inspect  . bwt. . . . . .note. .
  store bwt explicitly.,   binary search.
symbol . list  find  largest position   list.
less  , say .  call   approximate rank value.
.  allows   estimate .,  points   .
place    must  within  positions  .
position  seek .  true . value. finally.
 scan    right   approximate value .
.   find  suffix  value . . . .
position   value  isa. . . .   .
goal.  approach avoids scanning bwt . .
 like  avoid computing on-the-fly  .
cache misses.  query time, scanning    fast, .
causes  extra cache misses.  found  approach.
 almost  fast  rle-lf  repetitive data,  .
space requirements  stable  tunable   types.
 data.  uses . bytes  top    , .
factorizes  . . zkb .  log. .  log . time.
setting  . .log . yields . .  log . complexity.
 practice  set  . .   expect  running.
time .  log .
 refer   algorithm using rle-lf  rank.
queries  isa.,   algorithm  uses sparself instead  isas. figure . gives  overview  .
performance   algorithms relative  isa.  .
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
 files  used  figure .   isas algorithm.
 sampled isa array  different rates  illustrate .
space-time tradeoff.  version  isas  sampling.
rate set   memory usage stays  . bytes .
total  used   experiments  section .   called.
isa.
   non-repetitive file .english.  spacetime curve smoothly drops    available memory increases,  time  kernel file actually increases.
around .   algorithm  sampling isa  .
higher rate.    highly repetitive files .
 benefit    full isa available . .
majority  parsing time  spent  nsv.psv calculations  symbols comparisons. sampling  isa  .
higher rate increases preprocessing time,    .
repaid   parsing phase.
. experiments.
 testing  used  files listed  table . .
tests  conducted   .ghz intel xeon cpu.
 . main memory  . . cache.  .
single thread  execution  used   experiments.
 machine    significant cpu tasks running.    linux .ubuntu ., .bit. running kernel .  compiler  . .gcc version.
. executed   . -static -dndebug options.  times given   minima  three runs.
  recorded   standard  clock function.
 data structures reside  main memory  computation.
 compute  suffix array  use yuta.
mori. divsufsort algorithm  implementation.
.http.code.google.com.libdivsufsort. .
 algorithms  require  lcp array  compute.
 using   implementation   . algorithm .,.
   fastest lcp array construction algorithm.
 know . .   memory peak  . bytes, .
  increase  peak memory   algorithm.
 used .
experiments measured  time  compute .
 factorization.  algorithms,    .
introduced   paper, compute  directly, .
others,   noted earlier, must first compute .
 lpf values.   latter case   include.
 time  compute  lpf values,   .
 implementations produce   . component.
  lpf value,   insufficient  full .
factorization. note   slightly disadvantages .
new algorithms.
 algorithms   memory requirements .
listed  table .  experiments  summarized.
 table . .runtimes.  table . .memory usage.
implementations   algorithms  available .
http.www.helsinki.gsa.  .
found  values . . .   . .    good.
compromise  space  time  use  .
 experiments.
 proposed cps. optimizations significantly improve  runtime.  particularly big change  repetitive files   attributed  fast interval computation.
 parsing phase  cps. strongly benefits  long.
phrases .binary searching   small range. hence .
factorization  files  small    fast.   therefore beneficial  total runtime   preceding phase.
.computation  intervals. takes little time  well.
 new isa. algorithm  consistently faster .
 previous algorithms,  simultaneously use . bytes.
less space.  improvement   cases   least .
.  average.  non-repetitive files  difference.
 even bigger . least . interestingly isa. .
always faster  lcp computation,    used.
 best available solution.
 also note  minor inconsistency  . .
 experiments algorithm   slower  algorithms.
based  lpf array   files . .   always.
faster.     .  slower lcp construction algorithm .  used .see  comparison.
 .   time  compute lcp dominates .
total runtime  lpf-based algorithms.
 isa. algorithm  uses isa sampling .
 competitive  isa.  repetitive files despite.
low memory usage.  explanation   phenomena.
  found  section .   reasonable slowdown.
compared  isa.  non-repetitive files demonstrates.
 effectiveness  sparse-lf representation.
lastly, note  although using  rle-lf representation . place  sparse-lf. restricts  applicability  isa.  repetitive files,  allows  algorithm.
 outperform isa.  sometimes even beat isa.
. conclusions  future work.
  paper   shown   practice .
fastest way  compute  . factorization seems.
   compute  factors   online manner.
.  construction., one   , rather .
computing  lpf values   selecting  .
involved   parsing. computation   lcp array.
also seems unnecessary.   algorithms use  .
 alternative supporting data structures,  .
smaller  faster  initialize   lcp array.
 . factorization algorithms  date, including.
 ones   paper, make use   suffix array,.
  require memory  least sufficient  store .
integers.  important open problem, especially .
text indexes based  .,   develop scalable.
factorization algorithms  completely avoid suffix.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
.
.
.
.
.
.
. . . . .
.
.
.
.
.
.
memory .bytes.char.
.
.
 .
.
.
.
.
iga.
.
.
.
kernel.
 isa.
isa.
isa.
.
.
.
.
.
.
.
.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
memory .bytes.char.
.
.
 .
.
.
.
.
iga.
.
.
.
english.
 isa.
isa.
figure . space-time tradeoff   family  isa-based . factorization algorithms.
name . . . . source description.
dna . . . .  human genome.
proteins . . . .  swissprot database.
english . . . .  gutenberg project.
sources . . . .  linux  gcc sources.
dblp.xml . . . .  dblp bibliography.
cere . . . . . . . yeast genome.
coreutils . . . . . . . gnu coreutils source.
world leaders . . . . . . . cia world leaders.
kernel . . . . . . . linux kernel sources.
einstein. . . . . . wikipedia.
english. . . . . . . . . english.
proteins. . . . . . . . . protein.
dblp.xml. . . . . . . . . dblp.xml.
. . . . . . run-rich string sequence.
. . . . . . thue-morse sequence.
table . files used   experiments.  files   .  pizza-chili standard.
corpus .http.pizzachili.dcc.uchile.texts.html.  .  pizza-chili repetitive corpus.
.http.pizzachili.dcc.uchile.repcorpus.html.  repetitive corpus contains artificially generated sequences ., files  several variants    data .,  files created  standard corpus files  concatenating.
. copies   . prefix  mutating  randomly .  values  . .average length  run  bwt. .
. .average length  phrase   factorization.  included  measures  repetitiveness.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
algorithm space output isa .  description.
isa. .  . . full isa array.
isa. .  . sparse isa sampling, general.
isa. .  . rle isa sampling, specialized.
cps. .  improved version  .
cps. .  original algorithm  .
 .  computelpf  .
 . lpf ultra-fast algorithm  .
lpf. . lpf lpf-optimal  .
lpf. . lpf lpf-online  .
table . algorithms   space requirements . . text length. space requirements include  space   .
text  exclude space  output, unless   necessary  computation. isa .   fraction  isa array  .
stored.  column gives   representation used. .   space column marks   algorithm requires .
extra memory .stack    lpf.  psv.nsv  isa.,   practice  negligible. note   space.
requirement  isa. holds    number  runs   bwt satisfies  . .
testfile  lcp isa. isa. isa. cps. cps.   lpf. lpf.
dna . . . .  . . . . . .
proteins . . . .  . . . . . .
english . . . .  . . . . . .
sources . . . .  . . . . . .
dblp.xml . . . .  . . . . . .
cere . . . . . . . . . . .
coreutils . . . . . . . . . . .
world leaders . . . . . . . . . . .
kernel . . . . . . . . . . .
einstein. . . . . . . . . . . .
english. . . . . . . . . . . .
proteins. . . . . . . . . . . .
dblp.xml. . . . . . . . . . . .
. . . . . . . . . . . .
. . . . . . . . . . . .
table . times  computing  factorization.  times  seconds per gigabyte    include  reading.
  writing  disk.  time  precompute   .   prerequisite   algorithms.   included  .
runtime.  also separately present  time  compute  lcp array , unlike ,   included   total runtime.
 algorithms  use  .lpf.  lpf.
testfile isa. isa. isa. cps. cps.   lpf. lpf.
dna . .  . . . . . .
proteins . .  . . . . . .
english . .  . . . . . .
sources . .  . . . . . .
dblp.xml . .  . . . . . .
cere . . . . . . . . .
coreutils . . . . . . . . .
world leaders . . . . . . . . .
kernel . . . . . . . . .
einstein. . . . . . . . . .
english. . . . . . . . . .
proteins. . . . . . . . . .
dblp.xml. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
table . peak memory usage  bytes per character   algorithms.
. copyright . siam.
unauthorized reproduction   article  prohibited.
downloaded  knowledgecenter.siam.org.
sorting  entire input.
acknowledgments. thanks   golnaz badkobeh, maxime crochemore, juha .rkka.inen, .
travis gagie  inspiring discussions   topic .
. factorization.  simon gog  german tischler.
 sharing source code,   explicating details .
 experiments.    anonymous referees whose.
comments materially improved  paper.
</doc>
<doc title='alx11_01_morarui.txt'>
exact pattern matching  feed-forward bloom filters.
iulian moraru. david . andersen.
abstract.
 paper presents  new, memory efficient  cacheoptimized algorithm  simultaneously searching   large.
number  patterns    large corpus.  algorithm builds upon  rabin-karp string search algorithm.
 incorporates  new type  bloom filter   call .
feed-forward bloom filter.   retains  asymptotic.
time complexity  previous multiple pattern matching algorithms,  show   technique, along   cpu.
architecture aware design   bloom filter,  provide.
speedups  .  .,  memory consumption.
reductions  large  .  compared  grep.
. introduction.
matching  large corpus  data   database.
 thousands  millions  patterns   important.
component  virus scanning ., data mining .
machine learning .,  bioinformatics .,  name.
  problem domains. today,    uncommon .
match terabyte  petabyte-sized corpuses  gigabitrate streams  tens  hundreds  megabytes .
patterns.
conventional solutions   problem build .
exact-match trie-like structure using  algorithm .
 aho-corasick .  algorithms  asymptotically optimal. matching  elements   patterns.
requires  . . . time.  another important.
sense, however,   far  optimal.  per-byte.
processing overhead   high,   dfas constructed   algorithms  occupy gigabytes .
memory, leading  extremely poor cache use  cripples throughput   modern cpu. figure . shows .
particularly graphic example  .  matching.
    thousand patterns, gnu grep .
process  . .sec .using  algorithm  improves  aho-corasick .    number .
patterns increases,  throughput drops drastically, .
 .sec.  cause  shown   line  .
graph.  size   dfa grows  rapidly exceed .
size  cpu caches.
un-cached memory accesses  modern cpus .
.carnegie mellon university, computer science department, pittsburgh,  . e-mail. imoraru.cmu.edu,.
dga.cmu.edu.
dauntingly expensive.  intel core . quad .
cpu used    example  grep,  instance,.
 capable  sequentially streaming  .sec .
memory  .optimistically. executing several billion.
instructions per second.  achieved .sec .
therefore  disappointing fraction   machine. capability.
furthermore,   situations  running .
full-scale aho-corasick implementation   expensive  memory  limited., multiple pattern.
matching  netbooks, mobile devices, embedded systems,   low-power computing clusters . .
applications,   virus scanning, benefit  efficient memory use  order  reduce  impact .
foreground tasks.
 paper makes two contributions  together.
 significantly boost  speed   type  processing,     time reducing  memory.
requirements.   center around making .
efficient use   cache memory.
feed-forward bloom filters. bloom filters .
 previously  used  accelerate pattern matching  reducing  size   input corpus  .
exact matching phase .  paper  refer   exact matching phase   .grep cleanup. phase. feedforward bloom filters reduce  size   input corpus.
 well,   processing, also record information.
  patterns    matched. .
 introduce  second pass filtering step   information  used  reduce  number  patterns .
must  handled   .cleanup. phase.   result,  reduces drastically  memory used  cleanup.
cache-partitioned bloom filters.  lookup .
 typical bloom filter involves computing  hash values.
  query,  using  values  indices  .
bit vector.   hash values must  randomly.
distributed   filter   effective,  since, .
millions  patterns  bit vector must  substantially.
larger   cache available  modern cpus, bloom.
filter implementations  poor cache performance.
 solution   problem   split  bloom filter.
 two parts.  first part  smaller   largest.
.  .  intel core . cpu,  example,  cache miss.
requires . cycles.
number  patterns.
throughput.
memory.
figure .  grep processing rate  memory consumption  various numbers  patterns.  average.
length   patterns  . characters.
cpu cache available .typically . cache.    .
one accessed   large majority   lookups.
 consequence,  will remain entirely cache-resident.
 second part   filter  larger,   accessed.
infrequently .,  true  false positive queries. .
role   keep  false positive rate small.  result.
   cache-partitioned bloom filter   effective.
  classic bloom filter,   much better cache.
performance,    much  . faster,   result.
 describe  techniques  section . .
evaluate   section .  show  pattern.
matching  highly redundant english text  .
accelerated  .  consuming . less memory,.
 random ascii text   searched . faster.
 . less memory,  compared  grep.
. background  related work.
. multiple pattern search.  classic multiple.
pattern search algorithm  aho-corasick .  .
 generalization   knuth-morris-pratt linear-time.
matching algorithm  uses  trie structure  .
 node represents  state   finite-state machine.
  input character,  automaton goes  .
state  represents  longest prefix   match.
  still possible.
 popular gnu fgrep utility uses .
commentz-walter algorithm .  multiple string.
search.  combines aho-corasick   boyermoore single pattern matching algorithm ., .
achieves sub-linear running time  skipping characters.
  input text according   .bad character. .
.good suffix. heuristics.  illustrated  figure ., .
.assuming   percentage  true positive queries  small.
size   dfa used  aho-corasick-like algorithms.
grows quickly   number  patterns. .
increases setup time .building  trie.  reduces.
search speed   poor cache performance.
another boyer-moore style algorithm  multiple.
pattern search   wu-manber algorithm ., employed   agrep tool.  uses  .bad character.
heuristic  skip  characters   input text. .
difference        comparing individual.
characters,   comparing  hash values  groups.
 consecutive characters.  algorithm   effective  relatively small numbers  patterns.hundreds.
 tens  thousands  patterns.  larger numbers .
patterns,  becomes  memory-hungry  thus less.
cache-efficient. lin  . show   wu-manber algorithm  worse cache performance  worse overall.
performance  aho-corasick   number  patterns increases .
complementary approaches  multiple pattern.
matching investigated  idea  encoding  text .
 patterns using  compact scheme,    word.
comparison  equivalent  multiple symbol comparisons .
 inspiration   work described   paper.
  algorithm  rabin  karp presented  .
 patterns. must      length.
 hashed   hash values  inserted   set.
data structure  allows  fast search .  bloom.
filter,  hashtable    bit vector   hashtable.
.  actual search consists   window. size.
equal   size   patterns.slid   input.
text,   hash value  computed   text  .
window,   position.  value   searched.
  set  hashes computed   patterns. .
found,  denotes  possible match,  needs  .
checked  comparing  string   current window.
 every pattern     hash value .
.  average case running time   algorithm.
 linear   hash computations required  sliding.
 window  done  .    achieved .
using  rolling hash function.  hash value .
 current window  computed   hash value .
 previous window,  last character   current.
window,   first character   previous window.
  paper,  present several improvements .
 basic rabin-karp technique.  enable fast .
memory-inexpensive search  millions  patterns .
.
. bloom filters.  bloom filter .   data.
structure used  testing set membership   large.
sets.  allows  small percentage  false positives .
exchange  space  speed.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
concretely,   given set ,  bloom filter uses .
bit array  size ,   hash functions   applied.
 objects    type   elements  . .
hash application produces  integer value  .
 , used   index   bit array.   filter.
setup phase,   hash functions  applied  .
element  ,   bit indexed   resulting.
value  set  .   array .thus,   element.
 ,  will   maximum   bits set   bit.
array.fewer  two hash functions yield   value,.
   bits  already  set   elements.
 testing membership,   hash functions  also.
applied   tested element,   bits indexed .
 resulting values  checked.     ., .
element  potentially  member   set . otherwise,.
  least one bit  .,  element   part   set.
.false negatives   possible.
 number  hash functions used   size .
 bit array determine  false positive rate  .
bloom filter.   set   elements,  asymptotic.
false positive probability   test .
.
. . .see.
section .
 larger  ,  smaller  false positive rate.
furthermore, since hits   bloom filter .false  true.
positives.   expensive  misses . query .
stop  soon  one hash function misses.,  larger .
may also improve  performance .search speed.  .
filter.    hand, random accesses   large bit.
array  poor cache performance  today. machines.
  fixed ,  .  . . . minimizes .
false positive rate.  practice however,   often.
chosen smaller  optimum  speed considerations.
 smaller  means computing fewer hash functions.
improving  performance  bloom filters .
also   subject  much research. kirsch .
mitzenmacher . show  computing   hash.
functions  linear combinations  just two independent.
hash functions   affect  false positive rate.
  bloom filter.  use  result,  explained.
 section . putze  . propose blocked bloom.
filters  .,  achieve better cache performance.
 regular bloom filters  putting   hashes .
 element    cache line   bit vector.
 scheme   effective  applications  .
high true positive search rate,   cache-friendly.
technique   propose   paper  better suited.
 applications   low true positive rate. hao  .
. use partitioned hashing . elements  divided.
 groups   group  hashed   different.
set  functions.  reduce  bloom filter fill factor,.
 therefore  false positive rate.  optimization.
 orthogonal  .
 exist various extensions   bloom filter.
functionality  well. counting bloom filters . allow.
 deletions. bloomier filters . implement associative.
arrays  allow  small false positive look-up rate.
distance-sensitive bloom filters .  designed .
answer queries   type .  close   element.
  set .   certain, suitable metric. spectral.
bloom filters . allow  queries   multiplicity .
items   multiset.  section .  present  .
extension  bloom filters,   call feed-forward.
bloom filters.
. comparison  regular expression.
matching.  algorithm   present  .
paper  applicable  fixed pattern matching. dfa.
based algorithms   powerful    .
also  used  general regular expression matching. .
 work .   succesfully applied feed-forward.
bloom filters  regular expressions  contain fixed.
substrings. expanding regular expressions  multiple.
fixed patterns   using feed-forward bloom.
filters  also   solution  certain workloads,.
  leave exploring   future work.
. design  implementation.
. overview.  multiple pattern matching algorithm   present   paper  designed  perform well  situations    large numbers .
patterns generate  relatively small number  matches.
 takes  account  memory hierarchy  modern.
computers.
 diagram  figure . presents  high-level view.
  approach.
. step . pattern pre-processing. first,  feedforward bloom filter .ffbf.  built   set.
 patterns.
. step . scan items using patterns.  bloom.
filter  used  scan  corpus  discard every.
item ., line  text,   patterns  span.
multiple lines,  input fragment.   .
generate hits   filter  therefore .
contain  matches.   item matches,  .
inserted   feed-forward structure.
. step . scan patterns using matched items. .
set  patterns   scanned using feed-forward.
information obtained   corpus scan. .
 patterns      chance  .
match   filtered corpus  kept   next.
phase.
. step . cleanup.   point,    left  .
 search   small fraction   initial number.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
patterns.
text corpus.
preprocess .
filter.
matchexactly.
patterns subset.
filtered corpus.
results.
feed-forward bloom filter.
.
.
.
.
figure . diagram   pattern matching algorithm using feed-forward bloom filters.
 patterns   small fragment   corpus.
 exact matching step   performed quickly.
  minimal memory requirements using .
traditional multiple pattern matching algorithm.
. aho-corasick. notice   large set .
patterns      memory-resident .
 point   execution   algorithm.
  need  stream  sequentially  external.
media.
 starting point   work   combination.
  rabin-karp algorithm  bloom filters. .
multiple pattern matching approach  augmented.
 two techniques  improve  speed  memory efficiency. feed-forward bloom filters  cachepartitioned bloom filters.
 present  algorithm   whole   section,.
  describe  evaluate  two techniques .
detail. even though   designed  improve .
performance   algorithm,  believe   .
independently useful.
 begin  describing  traditional way .
using bloom filters   rabin-karp algorithm. .
patterns  represent  set   used  build .
bloom filter.   scan,  window   .
length   patterns . assume  now  .
patterns     length.  slid   text.
 tested   filter.  hit denotes either .
true   false positive. distinguishing   two.
  done  two ways. .   bloom filter.
scan,  looking-up  string   current window.
  hash table  contains   patterns,  .
  bloom filter scan,  involves saving .
regions  text .usually lines  text.  generated.
hits   bloom filter,  running  exact multiple.
pattern matching algorithm    smaller input.
  cases,  disadvantage     patterns.
 used  build  data structures .either  hash.
tables   tries.,     memory-inefficient.
feed-forward bloom filters help   second.
phase exact-matching scan  providing  subset containing   patterns  will generate matches.
possibly  small number  patterns  will . .
 words, feed-forward bloom filters   filter.
 corpus like regular bloom filters,  also filter .
set  patterns. usually,  resulting subset contains.
  small fraction   initial number  patterns,.
  memory efficiency. therefore  speed.
 second phase exact-matching scan  drastically.
improved.
 practice,  patterns may     .
length.  solution   take  consecutive characters.
 every pattern .  first  characters.  use.
  substrings  build  bloom filter.  .
 patterns shorter   characters,  will look .
   concurrent exact matching scan. choosing .
  trade-off   effectiveness   filtering.
phase . large  makes  filtering  selective. .
 performance   separate exact matching scan .
short patterns . small  makes  fewer short patterns.
another common case  filtering effectiveness.
may  reduced     small number  patterns.
generate many matches.   situation,  filtering.
  discard  small percentage   corpus.
text.  good way  dealing   case   test .
frequency   patterns   sample   corpus. .
 frequent patterns    excluded  .
filtering phase,  join  short patterns   separate.
exact matching scan.
 pseudocode description   algorithm  presented  figure .
. feed-forward bloom filters. bloom filters.
 used  test set membership. given  set ,  bloom.
filter  able  answer questions   form .   .
  certain false positive probability .  pattern.
matching application,    sequence  characters .
 corpus,     set  patterns.
feed-forward bloom filters extend  functionality.
 answering  number  queries,  feed-forward.
bloom filter provides  subset . . ,  .
.   query .   .   answered .
 . ,   . .
.   . .,     high probability  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.   set   fixed-string patterns.
.   set  input string elements.
phase .  preprocessing.
. find  .  ,  subset    frequent.
patterns.
. choose ,  minimum size   patterns  .
included   bloom filter.
. compute  .  ,  subset   patterns shorter.
 .
. build feed-forward bloom filter ffbf .
 . . . .
phase .  filtering.
. . .,  . ffbf . .
.
 . .    . . . . . . .
phase .  exact matching.
. . . exact match. . . .
. . . exact match. . .
. output . . .
figure . pseudocode   multiple pattern matching.
 feed-forward bloom filters.
query .   .   answered.
 implement  functionality, feed-forward.
bloom filters use two bit arrays instead  one. .
first array  populated using  elements   .,.
 patterns   matched,   rabin-karp., just.
like  regular bloom filter.  second array starts .
 bits .,   modified   querying process.
 every positive test .   .,   inserted .
 bloom filter  uses  second array   bit array.  second bloom filter uses  different set  hash.
functions  determine  bits  set   item, .
 hash functions  efficiently computable based.
upon  hashing   done  test  membership.
  first bloom filter .section .   number .
queries, .  obtained  testing every item   .
 second bloom filter,  putting   items .
generate positive results  .
  implementation,  size  second array.
    first,   sizes   adjusted.
independently.   algorithm  designed .
workloads   positive matches  rare,  total.
time required  inserting entries   second bloom.
filter   small.
 understand   approach  correct, consider   query .   .   answered .
.  earlier version   algorithm,  used  .
hash functions   two filters  avoid additional computation.
 , however, substantially increases  false positive rate.
  pattern-filtering phase.
 certain  .  .  answer must   positive.
, according   procedure described , .
 inserted   second bloom filter.   next.
phase,    elements    queried .
 second bloom filter,  will generate  hit  will.
 included  .
 feed-forward false positives   items  .
   queried   first bloom filter. .
pattern matching  false positive items  patterns.
  must match    cleanup phase, even.
though  corpus fragment  successfully match.
. given  item  .     queried.
  bloom filter,    probability  .
will  inserted  .
 false positive rate depends   standard.
bloom filter parameters.  number  items inserted.
  filter,  number  hash functions,  .
array size. furthermore, recall   item  inserted.
  second bloom filter      matches .
first bloom filter.  feed-forward false positive rate.
therefore also depends   number  items tested.
  first bloom filter multiplied   match.
rate   first filter.
assume  now  true postives .items  actually match  pattern   care .  rare. .
   number  bits   first array,    .
number  hashes used  every item insertion.search.
 ,   .  .   corresponding parameters.
  second bloom filter.   . .   number.
 items inserted,   false positive probability .
 first filter   filter. . function.,, .  feedforward false positive probability will    filter. .
function. filter. . number  queries,., . . explain  approximation .
assuming perfectly uniform hash functions, .
inserting  items   first bloom filter,  probability   particular bit  still .   first array.
. . .
.
. .
.  probability   false positive.
 searching   bloom filter  .
pfp .  filter. . . . .
.
.
.
. .
.
.
 begin  ignoring true positives .  applications  number  true positives  negligible .
compared   number  false positives.,   factor     next section.  now,  consider.
phit . pfp . ptp . pfp .  approximate  probability   bit  .   second array,   queries,.
 using  expectation   number  false positive.
queries   first filter . . pfp .
 . .
.
. .
.
.wpfp.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
thus,  probability   item   will .
selected   part  . .  feed-forward false positive.
.
pfeed.fwdfp .  filter. . .  .
. . . .
.
.
.
.
.
. .  .
.
 expression  represented  figure .  .
function  .,  different values    .,.
  case  . .   . . .  feedforward false positive probability  small,    .
drastically reduced  small adjustments   feedforward bloom filter parameters.  example, consider.
 target feed-forward false-positive probability  .
 searching  . million patterns .,  want.
around .,. patterns  exact matching. .
.  bit vectors  five hash functions  .
bit vector . . . . .   scan .   text.
  surpass  target feed-forward false positive.
probability.  .  bit vectors   . . . ., .
 scan .   text.  .  bit vectors .
still six hash functions   scan . terabytes  text.
 still select   .   patterns  exact.
matching.
. factoring  true positives. intuitively,  .
  number  true positive tests .  first.
bloom filter.  affects  feed-forward false positive.
rate,   percentage  items  generate .
 example,   one item generates   true.
positives,    . bits will  set   second.
bit array.
assume    . items    will.
generate true positives . usually expect .
.
  .
small.   probability   bit  .   second.
bit array    true positive tests .
 ., . .
.
. .
.
.
 conclusion,  probability   bit  set  .
second array,   tests    true positives.
  number  tests   true positives, .
 . . .
.
., .
.
.  .,.
.
.  .
  .   expression presented   previous.
section.
 probability   feed-forward false positive.
becomes.
figure .  feed-forward false positive rate  .
function  .  . . .  varying  .,.
  . .  varying . .   cases .
consider . .   . . .
pfeed.fwdfp . . .
.
figure . presents   cases   first graph .
figure .,  shows   feed-forward false positive.
rate  affected  .
.
 . .  conclude   effect.
  true positives  small even   relatively large.
percent .  patterns  present   corpus.
. cache-partitioned bloom filters. consider .
machine   simple memory hierarchy.  small cache.
memory.    accessed rapidly   large main.
memory   accessed  slowly.   cases .
examine, hits   bloom filter  rare.  bloom.
filter miss requires one   lookups   bit array,.
  number  lookups  inversely proportional.
.  multi-level cache hierarchy  will usually  .
largest cache.
figure .  feed-forward false positive rate  .
function  .  . . .  varying  . . .
 . . .  dashed lines show  effect  .
  items generating true positives. note   .
axis uses  logarithmic scale.
  fraction  bits   set  . filter returns.
.   finds  first . bit.  lookups,.
therefore,   computational cost  hash  data.
 compute  bloom filter bit index,   memory.
lookup cost  depends upon whether  lookup hits.
 . cache  whether  incurs  tlb miss. .
  large cost penalty  cache misses, reducing .
number  cache misses  negative bloom filter lookups.
 substantially reduce  total running time. .
therefore propose  improvement  bloom filters .
 call cache-partitioned bloom filters.
 bit array   cache-partitioned bloom filter.
 split  two components.  small bit array  fits.
completely  cache   large bit array  resides.
  main memory.  first  hash functions hash.
  small cache-resident array,   .
 . . functions hash    non-cache-resident.
part. unlike   regular bloom filter,  cachepartitioned filters  accesses  made   part.
 resides  cache.  first bits checked  always.
 cache,     time one   will  .,.
 will allow  lookup  abort.
cache behavior.  assume   cache uses .
approximation  least-recently-used   degree.
 set associativity . .   result, pages  .
cache-resident part   filter  likely  remain .
cache.  ensure     non-temporal.
reads.  accessing  non-cache resident part .
 bit array.
. accomplish  using non-temporal prefetches  .
prefetchnta instruction available  intel cpus.
tlb behavior.  use  large pages support.
available   modern processors  ensure  .
number  pages required   bit array  smaller.
  number  tlb entries. avoiding tlb miss.
penalties improves speed  .  optimization.
also simplifies  analysis   lets  ignore tlb.
effects.
 inserting  patterns   filter,  probability   particular bit  .   cache resident.
part . . . .
 refine  model , note   cpus.
 perform branch prediction,  branch predictor.
will  wrong every time  bit vector access hits  set.
bit, thus incurring  branch misprediction penalty .
 expected lookup time becomes.
 expression   used  predict  best.
values   parameters  cache-partitioned bloom.
filters,  shown  seciton .
. fast rolling hash functions. besides .
cache behavior, another possible bottleneck   bloom.
filter implementation   computation   hash.
functions.
 using bloom filters  scanning text, .
implementations employ rolling hash functions  easily.
update  hash values based   characters sliding.
 ,    current window.  classic.
rolling hash function used   rabin-karp algorithm.
computes  hash value   string   value  .
corresponding ascii sequence   large base. .
computation, however, requires multiplications  .
expensive modulo operation,   thus   high.
overhead.
 inexpensive  effective rolling hash method .
hashing  cyclic polynomials .  uses  substitution.
box  assign random .-bit values  characters, .
combines  values  bit-wise rotations  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
exclusive-or operation, avoiding expensive multiplications  modulo operations.
  implementation,  use cyclic polynomial.
hashing  obtain two distinct hash values   window.   use  idea  kirsch  mitzenmacher.
.  quickly compute    hashes  linear.
combinations   two values.  hash computations  therefore  efficient.
. evaluation.
 run  tests   . ghz intel core . quad .
cpu  split .  . cache . core  access .
 . .,  .   ram memory.  optimal.
cache-partitioned configuration   setup . . .
 two hash functions   resident part, . .
 three hash functions   non-resident part .see.
section .  details  choosing  parameters.
  feed-forward bloom filter,  bit vectors .
  size.  tests  performed   warm file.
system buffer cache. every time  compare  grep,.
 discount  grep initialization time.  results.
 averaged  four runs   standard deviation.
 always smaller  .   mean.
. overall performance.  compare  algorithm  grep version ., run  fgrep, .
 optimized  fixed-string patterns.  use cacheoptimized feed-forward bloom filters   first phase,.
 grep   second phase.  report aggregate.
throughput  memory consumption.   comparison  use  following three workloads.
read  web.  read  web project .
aims  building  probabilistic knowledge base using.
 content   web.  workload   use .
 evaluation consists  determining semantic classes.
 english words  putting  words  phrases.
 similar structure  finding  relative frequencies   phrases  web documents.  total, .
 approximately . million phrases   search.
 .   web documents. note ,  .
 way   built,  patterns   similar,.
 means   workload  almost  best case.
 grep   worst case   feed-forward bloom.
filter. around .   patterns   . characters,   choose  first . characters   phrase.
.  long enough.  put   bloom filter.  results presented  figure . .top graph.   phrase sets.
   contain  short patterns. since  distribution  pattern lengths  highly application-specific,.
 present results  experiments  short patterns.
separately,  section .
random ascii text.  search  random .character strings consisting  printable ascii characters   random corpus.  line   corpus .
. characters .resulting  . bloom filter lookups.
per line.    one million lines   corpus.
since    redundancy   patterns,  .
probability   pattern will  found   corpus.
  small,  workload represents  best case .
bloom filters,   worst case  grep.  results.
 presented  figure . .bottom graph.
figure . comparison  scanning text .
cache-partitioned bloom filters, feed-forward bloom filters  grep   read  web project .top graph.
 random ascii text .bottom graph.  cpbf.
 ffbf throughputs include  first .filter.  second .grep cleanup. phase.  ffbf also contains .
cache-partitioned optimization ., ffbf   cachepartitioned feed-forward bloom filter, whereas cpbf .
just  cache-partitioned bloom filter.  . million.
random ascii phrases, grep runs   memory .
 system.
dna.  consists  looking  .,. random.
dna sequences  various lengths   genomes .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
three strains  streptococcus suis . .  goal  .
assess  limitations   approach   potentially.
important application    particularity .
 alphabet   small .four base pairs.  method.
.feed-forward, cache-partitioned bloom filter   first.
phase  grep   second. performs increasingly.
better  dna sequences larger  . base pairs.
generates  . speedup  . base pairs.
comparisons   memory requirements .
 two approaches .ffbf . grep versus simple grep.
  read  web  random text workloads .
also presented  figure . . cache-partitioned bloom.
filter without  feed-forward technique .cpbf. .
grep requires  .   memory   grep.
.,  size   bit vector.
 expected, feed-forward bloom filters  much.
better  grep   random text workload. grep.
builds   large dfa   alphabet  large.
  symbols occur   pattern set  almost.
equal frequency,   feed-forward bloom filter.
 needs  run  first pass, since   .
patterns false positives .even    false positive.
matches   corpus.
 read  web scenario   favorable .
grep    many similar patterns . .
first . characters   use  build  feed-forward.
bloom filter     many patterns.,  .
number  patterns  must  checked   second.
phase  large. even , feed-forward bloom filters.
perform substantially better.
grep works well  dna lookups  .
alphabet   small .four symbols. usually .
patterns  short,   dfa  grep builds .
small. furthermore,  patterns containing  four.
distinct characters,  hash values computed  .
ffbf algorithm will  less uniform. however,  .
size   sequences increases,  relative performance.
 ffbfs improves, making   viable solution even.
  setting.
initialization time,  discounted   results presented  figure .,  always substantially.
smaller  feed-forward bloom filters., .  .
 algorithm versus .   grep,   random text.
workload,   . million patterns point.
  also applied feed-forward bloom filters .
virus scanning.  results, reported  ., show .
overall speed improvement  .  .,   .
 time using less  half  memory, overall.
.   claim    representative  workloads .
bioinformatics, even though popular sequence alignment algorithms,   blast, start   multiple-patterns matching.
phase.
.  impact  short patterns.  repeat .
comparison  grep   read  web workload.
  . million phrases point,   time . .
 phrases  shorter  . characters. simple.
grep achieves  throughput  . . using ffbfs.
 searching   short patterns   separate grep.
scan, achieves  aggregate throughput  . . .
better strategy   apply  feed-forward technique.
recursively.  example, using three ffbfs.one .
patterns  least . characters, another  patterns.
 least . characters    .,  another.
 patterns  .  . characters long.
 separate scan   shortest patterns .shorter .
. characters  length.,   achieve  throughput.
 . .
 practice,  short patterns scan   performed  parallel   ffbf scan.   test.
however,  ran  sequentially  order  maintain.
 fair comparison   single threaded grep.
.  benefit  individual optimizations.
feed-forward. figure . presents  results .
comparing cache-partitioned feed-forward bloom filters.
 cache-partitioned bloom filters . feed-forward.
 random text  read  web workloads.  nofeed-forward implementation gains time   .
 process  phrases  filtering  corpus, .
needs  expensive grep cleanup phase using  .
phrases. although  ffbf-based implementation.
achieves higher throughput    random text.
case,  uses much less memory   workloads. .
 important   amount  available memory.
limits  size   pattern set    search.
.  example,    able  search  .
million phrases   machine  .   ram,  .
random text case. even  read  web workload.
 problematic   low-power system. .  .
ram   search     . million phrases.
figure . shows  benefits     following.
three optimizations. cache-partitioning, non-temporal.
reads,  super pages.
cache-partitioning. cache-partitioning  .
optimization  provides  biggest speed-up. note.
  used  hash functions   partitioned filters , even   made  slightly slower, .
wanted  false positive rate    least  small.
    non-partitioned filter. table . compares.
 false positive rates   two bloom filter variants.
 . million phrases.
super pages. using super pages provides  almost constant time reduction, since    tlb.
misses  triggered  one   first bloom filter.
lookups.even  cache-resident part   filter  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .
.
.
 .
.
.
number  phrases.
 .classic . time.
. . ntr. time.
.ntr . . time.
.ntr time.
figure .  graph shows  benefit   optimization.  .cache-partitioning.,  .super pages.,.
 ntr .non-temporal reads.  filters  run.
 .   random ascii text,  different numbers.
 .-characters phrases.  cache-partitioned filters.
use five hash functions .two      cacheresident part.   non-partitioned filter uses four.
   similar size. .    non-partitioned.
bloom filter,  . . .    cache-partitioned.
ones.
filter type . hashes  rate throughput.
classic . . . .
partitioned . . . .
partitioned . . . .
table .  rates  cache-partitioned  classic.
bloom filters,  random text, . phrases.
large    .  pages  fit   tlb.
non-temporal reads.   number  phrases.
increases,  non-temporal reads optimization becomes.
 important,     accesses .
 non-resident part   filter.  non-temporal.
reads   used,  accesses determine fragments.
  cache-resident part   evicted  cache,.
  produces cache misses   critical first.
lookups.
. choosing parameters  feed-forward.
bloom filters.   section  describe  way.
 choose  feed-forward bloom filter parameters.
 size   bit vectors   partitioning.
depend .
.  amount  memory   willing  allocate.
  filter.
.  number  tlb entries  super pages.  .
required number  super pages   large, .
will   tlb miss penalty  will add  .
average filter lookup time.
.  size   largest cpu cache.  determined.
empirically   cpus  large caches, .
filter  faster   . use  entire cache.
    will usually   cache.
contention   bloom filter   processes   parts   program . reading.
 input data.   case, since  hash functions  faster   size   codomain  .
power  .,  used half   available . cache.
 cpus  small caches    hand,.
using less   entire cache may produce .
many false positives   first part   filter .
cache-partitioning  provide  benefit.
 sizes   two bit vectors used   feedforward bloom filter may differ. however,  memory .
  limited, making  equal  convenient .
 reasons presented .
 number  hash functions affects   .
false positive rate   filter,  also  speed.even.
  efficient hash function computation scheme.
  use,  many hash functions may cause.
 many memory accesses,    hash functions   cache resident part will determine many.
tests  non-cache-resident memory.  expected.
lookup time model   presented  section . .
useful  determining  many hash functions  use.
  section   feed-forward bloom filter,  .
aim  optimal speed. figure . shows  comparison.
  speed   fastest filter    .
filter  uses  settings recommended   model.
 determining  settings  provide  best.
speed,  desired false positive rate   achieved.
 increasing  number  hash functions  .
non-resident part.assuming  low true positive rate,.
lookups   section  little influence   speed.
  filter. notice  large decrease   false.
positive rate reported  table .  adding just one.
 hash function   non-resident section  .
filter.
finally,  last parameter  need  determine.
   partition  input corpus, .,  many.
input items . text lines.  scan  performing.
 grep cleanup phase.  coarse partitioning implies.
fewer cleanup runs,   finer partitioning determines.
. parameters   used  modeling  behavior .
 intel core . quad . cpu . . cycles   . miss,.
. cycles   . miss  . cycles   branch misprediction.
figure .  ratio   speed  scanning using cache-partitioned bloom filters  different numbers.
 hash functions   speed   optimal .fastest. setting.  filtered corpus contains .   random.
ascii text.  predicted line shows  speed   filter using  setting   mathematical model  .
average filter lookup time deems    fastest.
 runs   shorter,   feed-forward false.
positive rate will  smaller,  explained  section .
 seen  section .,   highly application specific,.
 therefore    attempt  find  general.
solution.  mention   workloads approaching.
 ideal case ., patterns    different.
  .,  partitioning   vey coarse.
.hundreds  gigabytes  even terabytes,  seen .
section .
. conclusion.
  presented  new algorithm  exact pattern.
matching based  two bloom filter enhancements. .
feed-forward  . cpu architecture aware design .
implementation.  algorithm substantially reduces.
scan time  memory requirements  compared.
 traditional dfa-based multiple pattern matching.
algorithms, especially  large numbers  patterns .
generate relatively  matches.
. acknowledgments.
 thank christos faloutsos, kanat tangwongsan,.
srinivasan seshan   anonymous reviewers .
 helpful suggestions.  work  supported.
  national science foundation  grant ccf.   cylab  carnegie mellon  grant.
daad.   army research office.
</doc>
<doc title='alx11_02_chimanim.txt'>
 closer look   closest string .
closest substring problem.
markus chimani. matthias woste. sebastian .cker.
abstract.
    set   strings   alphabet . .
string   length  .  .  closest.
substring problem .cssp.   find  minimal integer .
.  corresponding string   length .   .
string  .    substring  length .  hamming.
distance     .  say    closest substring.
 .  . . ,  problem  known   closest.
string problem .csp.
particularly  computational biology,  csp.
 cssp  found numerous practical applications.
  identifying regulatory motifs  approximate.
gene clusters,   degenerate primer design.
 study ilp formulations   problems.
 experiments show   position-based formulation   csp performs  well  real-world instances emerging  biology. even  randomly generated instances   hard  solve  optimality,.
solving  root relaxation leads  solutions  close.
  optimum.   cssp  give  new formulation   polytope-wise stronger   straightforward extension   csp formulation. furthermore.
 propose  strengthening constraint class  speeds.
  running time.
keywords. closest .sub.string problem, integer linear.
program, polyhedral study, experimental study.
. introduction.
  paper  consider  np-hard closest string.
problem .csp., sometimes also called center string.
problem,  well   generalization,  closest substring problem .cssp.  problems  diverse applications, .,  computational biology. finding approximate gene clusters using  center gene cluster.
model ., . requires  solve numerous csp instances.
  binary alphabet. degenerate primer design .
leads  csp instances   dna alphabet. .
.institute  computer science, friedrich-schiller-university.
 jena, germany. .markus.chimani, matthias.woste,.
sebastian.boecker.uni-jena. markus chimani  funded.
  carl-zeiss-foundation juniorprofessorship.
cssp,  turn,   extensively studied   context  finding regulatory motifs   upstream region.
 genes ., .
    set   strings   alphabet . .
string  length .  closest string problem  .
find  minimal integer  .  corresponding string .
 length .    maximal hamming distance.
  string      . .,   string  . ,.
 differs       positions.  say   .
closest string  .
similarly,     set   strings   alphabet.
.  string   length  .  .  closest.
substring problem   find  minimal integer  . .
corresponding string   length .    string.
 .    substring  length .  hamming distance.
    .  say    closest substring  .
 biology,  cssp  prespecified   also known.
 implanted-  ., .-motif search.
  last years, multiple heuristic  exact algorithms   developed    problems,.
 integer linear programs .ilps.   rarely considered. yet,  will argue      suitable.
tool   csp, solving  real-world csp instances.
 computational biology easily  provable optimality. even  artificial instances  much larger size .
 still find  prove  optimum. alternatively, .
show  already   root relaxation   problem   find  near optimal solution   typical.
absolute gap    .  supplement  study.
  polyhedral analysis  gives  reasons .
 ilp. success.
   hand,  also investigate  seemingly straightforward generalization cssp.  known,.
natural ilp formulation   lead  satisfactory.
results,     argued  investigating .
 relaxation. therefore  present  new, stronger.
formulation  well   new strengthening constraint.
class.  experiments reveal   computational.
effort due   size   new formulation outweighs.
 benefits  practice.  new constraint class, however,  clearly beneficial. yet,    conclude .
current ilp techniques   really    task .
 cssp, except  small instances.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. organization  contribution.  paper .
divided  two parts, one   csp  one  .
cssp.  part starts   summary   state.
  art,  presents  ilps  corresponding.
investigations,  finishes   practical evaluation.
 test instances  results  published  .
web. http.www.uni-jena.research.pubs.
csp.cssp.html. overall,  summarize  paper.
contribution   csp .
.  give  first investigation   natural csppolyhedron.
.  present  experimental study considering .
artificial instances  real-world instances .
computational biology, comparing  ilp approach   state-of-the-art metaheuristics .
exact fpt algorithms.    first study  .
broad scope.
.  demonstrate  applicability   simple ilp.
approach.
.   relaxation   obtained  far less.
 one second   considered instances. .
show   practice, using general-purpose ilp.
heuristics,  fractional solution   turned.
  feasible integral solution   absolute.
gap    .,  typically  .  .
  cssp  summarize.
.  present  novel ilp formulation based .
assignments  show    polytope-wise.
stronger   previously known formulation.
.  present  new constraint class    used.
  formulations  show   strengthens.
  .
.  give  first systematic evaluation .beyond.
small feasibility studies.  ilps   cssp.
 also consider biology-related instances  .
problem  ., .-motif search.
  following,  . denote  i-th character .
string .  substring  length . starting  position.
  denoted  . . given two strings , .  .
. . .  denote  hamming distance, . .
number  positions   . . .,  ., .
. previous work  studies   csp.
 csp  known   np-complete ., . .
 exists  number  approximation  heuristic.
algorithms. lanctot  . . developed  . . .
approximation based  randomized rounding.  ptas.
 first proposed    . .  running.
time  .rko.log.
.  performance ratio.
. . . . . . .dopt.  constant   improved.
 andoni  . .  .log.
.   .
sun .  .nko.
.
  field  metaheuristics, liu  . . applied.
 parallel genetic algorithm .  parallel simulated.
annealing .  ant colony optimization .aco.
algorithm  presented  faro  pappalardo .
 turned    superior   non-parallel.
implementations    . due   heuristic.
nature   algorithms    quality guarantee.
despite  hardness   problem  .
several results  exact solution strategies, many .
respect  fixed parameter tractability .fpt. .
parameter . gramm  . . achieve  running time.
 .  bound  successively improved.
   sun .  .  . .  wang.
 zhu .  . . . . . chen .
. .  improved  running time  using .
three-string approach  . .  . . .
  .  . . . recently, hufsky.
 . . presented  search tree algorithm  worst.
case running time  . . , however, performs.
much better  practice. besides fpt algorithms,.
meneses  . . investigated different ilp models.
 proposed heuristics  upper  lower bounds.
  branch-and-bound approach.  parallel version .
 .upper bound. heuristic  developed  gomes.
 . .  solved considerably larger instances .
reported  . kelsey  kotthoff . investigated.
 constraint programming approach.    first.
attempt   kind   reported running times .
 competitive yet.
  papers conducted extensive experiments.
.see .  none   tested  random .
practical instances  real-world size.
.  csp polyhedron.
 natural ilp formulation introduces  binary variable .,  every character . . .  every position.
. .  .    solution string .  shall  . iff . . .
since      character  every position .
,  need character selection equalities.
.
. ., . .
  . .  . .   optimize   minimal.
hamming distance   additionally requiring.
. .
.
.
., .  . . .
thus  guarantee     least  large  .
number  mismatches     . .
denote  natural formulation .originally proposed .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
., ., .   context  approximation algorithms.
 .csp.    compared   formulations.
  csp  meneses  . . according .
 investigations,  formulation performs best .
practice.  fact,   use  equivalent reformulation.
.csp.  reduces  amount  variables   factor.
 roughly .   relaxation   written .
min  .
.
.,.
.
. .
.
.
.
.
.,.
.
.  . .
.  . .
.
., . . . . .  . .
., . . . . .  . , . . .
thereby  removed  character selection equalities.
 substitution.  .   arbitrary  fixed character,  . . . . .   replace  ., .
. .,.  inequalities .  model .
transformed requirements ., . . note   .
 require  upper bound    variables,  .
. clearly,   relaxation  equivalent   .
.csp.  observe.
observation .  dimension   csp polyhedron.
 . . . .
given  feasible solution    variables,.
  always  easily find  minimal distance ,.
completing  solution. hence  constraints .
. .   really influence  feasibility  .
solution string     corresponding solution.
value.  polytope describing feasible solution strings.
  fact  simple. two polynomial constraint classes.
suffice  describe  convex hull   binary solutions.
leading  feasible solution strings.
theorem .  constraints .  .  .
complete characterization   feasible solution strings.
  facets   csp polyhedron.
 indicated   introduction,  ilp  .
csp turns     efficient  practice. .
fact, .csp. performs even better  .csp.  .
constraints  sparser, thus  use  formulation .
 experiments.   polyhedral observations.
.   constraints   complete description .
solution strings    remain facets  lifting.
  csp polyhedron.seem    reason  .
observed performance.
. experiments   csp.
 experiments  conducted   intel xeon .,.
. ghz, .  ram running debian .  .bit.
mode.  used ibm cplex . .unrestricted free.
academic version.    solver  branch-and-cut.
framework  default parameters,  restricted .
algorithm   single core  applied  time limit .
usual  ilp approaches.   case . minutes.
. biological instances.
mcclure instances.  real-world mcclure data.
set . contains . instances   . ., ., . .
 . ., .   considered   heuristic.
approach  meneses  . .   parallel heuristic.
 gomes  . .  maximum running time .
 heuristics  reported   .  . second,.
respectively,  gaps  .  ilp .although.
 newer hardware. solves  instances  optimality.
within . milliseconds.    already close  .
resolution   standard timer,  refrain  .
statistical evaluation   rather simple instances.
hufsky instances. hufsky  . . compared .
exact search tree approach   fpt algorithms proposed  .  .  also considered improvements.
  latter using  newly developed data reduction techniques.  used hardware  slightly older.
  one used herein .amd opteron, quad-core,.
.ghz, . ram.  precise runtime comparisons.
 therefore  considered  care. yet  feel.
  speed-up     order  magnitude.
makes  comparison feasible.
  fpt scenario,  ask whether  given.
instance allows  solution    . errors .
answer  time   exponentially dependent  .
. optimization    done via linear search .
increasing .   comparison,  authors establish.
 . . dopt . . constitutes   time-consuming.
step.   efficient algorithm   study  able.
 reject  . .   instances within .
second . minutes, respectively.
 ilp approach solves  instances  optimality.
within . seconds, directly returning dopt  hence.
answering  fpt decision problems along  way.
. random instances.   experiments.
 established biological benchmarks show  .
exact ilp       task  solving ,.
  question arises  large  considered instances may become   .unavoidable. exponential runtime behavior  observed  practice.  therefore generate random instances analogous   process used  multiple  publications   csp.
 first create  random master string   length.
.  instance  consists   copies  , .
figure . ratio  instances    computation took    specified amount  time  . . . .
different   .
  randomly altered  . random positions .
hence dopt . . alternatively,  also consider instances consisting   random strings .denoted .
. . .  constructed . instances   parameter combination   . ., ., ., ., .,  .
., ., ., ., ., ., ., . . ., ., .,.
 . . ., ., ., ., . note   settings include instances   considerably larger.
  considered   publications  know .
 additionally also considered  biology-inspired .character alphabet  two characters cover .  .
string. however,  obtained results  virtually identical   uniform .-character alphabet,   omit .
details.
. exact ilp.  running time   ilp approach  strongly dependent   . ratio. figure.
. shows  . . .  computation time decreases.
rapidly  decreasing .   tendency .
 observed    alphabets, although absolute.
values differ, see . consequently,  also holds.
  ratio  instances solved  provable optimality.    proved  optimal solution  .
  instances  completely random strings within.
 time limit  . minutes, almost  instances .
. . .  solved within . seconds. observe  .
 real-world scenarios   expect  strings .
 somewhat similar,   exactly  cases .
 ilp  particularly strong.  ., ., . values.
 .  .  discussed.
independently  .,  runtime performance  also.
highly dependent   size   alphabet.  .
one hand, computing  initial  relaxation takes.
longer  larger alphabets,   number  variables.
increases. yet,  dual bounds  considerably.
stronger , say, . . .   binary alphabets.
hence  latter require  considerably longer overall.
running time  branch-and-bound.
. root solution   heuristic.  observe .
solving  root node   branch-and-bound tree.
.,   relaxation plus  strengthening cuts.
  done  quickly. roughly .   root relaxations  . .   . . .  solved  less .
. seconds . fig. .   use off-the-shelf generalpurpose heuristics.based  relaxation induced neighborhood search .rins. .   feasibility pump .,.
already part  cplex. default settings. obtain feasible solutions  pruning.  particular,   interested   solutions  solving  root node. .
stopping  optimization process   point,  obtain  heuristic   even measure  obtained qual. quality   heuristic, ., absolute gap   upper bound   root node .
 final lower bound  termination  branch-and-bound.
figure . root heuristic  . . .  . . .
ity  looking   value   optimal  fractional.
 solution.
furthermore,   compare  heuristic solution.
  optimal solution  lower bound  . minutes.
 branch-and-bound.  absolute value   gap.
 shown  fig. .  observe   heuristic  .
 fast  almost always finds  solution  requires.
  one  conflict   optimal solution .see.
tab. ., column ,   absolute values  .  .
conclude   ilp approach provides fast optimal.
solutions  . . .   least  fast feasible solution.
  small gap otherwise.
. comparison   algorithms. tests .
random instances  conducted  .,.,. table .
compares  published results   approach.
  various papers,   generation process.
 ultimately different instances  used. although.
computing  average  multiple random instances,.
 done    mentioned publications, mitigates.
effects  outliers,  reader   aware .
 numbers  merely giving  tendency. similarly,.
. simplify similar studies   future,   generated.
instances discussed   paper   found  http.www.
uni-jena.research.pubs.csp.cssp.html.
 hardware setup  diverse, sometimes using slower.
machines .   ant algorithm., sometimes using.
highly parallel machines  . dual-core cpus .
  parallel heuristic. comparing  running time.
 therefore  possible within orders  magnitudes,.
   focus  comparing  quality  .
obtained solutions.
 see   root heuristic quite clearly outperforms   heuristics   terms  running.
time   solution quality . fact,  always .
least  close   true optimum. also note .
 heuristic solution  obtained   state-of-the-art.
general-purpose heuristic, without specific csp knowledge.    need  special purpose heuristics .
bounding,  contrast   exact approach proposed.
 .
. previous work  studies   cssp.
 cssp  np-hard .  .-hard . .
exists  ptas developed    . .  runs .
.log .
.   sun . propose  fpt.
algorithm  runs  . .  . . . ndlog. .
time. two  fpt algorithms   developed  marx .  running times .log . .
nlog . ando.log log ., respectively.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
table . comparison   ant algorithm . . .intel pentium ., . ghz, .  ram.,  heuristic.
.  . . ghz, .  ram.   parallel version .  . . intel xeon dual processors, .
 ram .,  root heuristic .,   solution   ilp formulation  branch-and-bound .
 consider  random instances  . . .  d-columns give  average achieved objective values. .
    additionally give  values . brackets. restricted   average   instances  .
 proved optimality via .  . column indicates  ratio  instances solved  optimality within .
minutes.  ratio  instances among    solved  optimality    shown   last column.
time .sec. distance .
 former fpt setting  also known   .extensively studied. ., .-motif search problem  computational biology.  uses   input data   cssp.
plus  prespecified   asks   target string  .
length .,       hamming distance.
   given string.   numerous algorithms.
proposed  tackle  problem  practice, based .
suffix trees, search tree pruning strategies,  many.
. see das  dai .  davila  . .  surveys.  currently fastest algorithm   ., .-motif.
search problem  due  boucher  king . .
 able  solve hard instances ., ., . . . see .  . . .,  . .,  . ., . . .,   . .
within . minutes.
meneses  . . describe  ilp   cssp.
 integer programing formulation   sum-of-pairs.
scoring scheme .instead   closest string . .
hamming distance.   developed  zaslavsky.
 singh .  later improved  kingsford .
. . via special purpose separation routines.
. ilp formulations   closest substring.
problem.
 notational simplicity,  will assume   strings.
   length . note     restrict .
formulations.   cssp   generalization  .
csp    straightforward .positional. extension.
 .csp. . ,   binary variables ., set.
 . iff . . .   string  . ,  ask  .
length-. substring . starting  , . .  .  . . . .,.
  . , . . .  choose .  setting .
binary variable ,  .
min  .csspp. .
 use character selection constraints .  .
.csp.,  similarly introduce substring selection constraints . ensuring  exactly one substring per.
string  picked. obviously,  distance bounding constraints . must  apply   substrings. .
 achieved  making   tautology  , . .
yet,  use  position variables   main reason .
 weakness.
observation .   relaxation  .csspp. allows.
 solution   . . whenever . . . . . .
proof. given  problem instance   .
property, set   variables  .,   variables .
. . . . .,   . .  solution satisfies .
 . also .  satisfied,  . . . . . .
. . . . . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.  stronger ilp formulation.  present .
.alignment-based. formulation   provably stronger.
 .csspp. instead  identifying substrings  .
positions,  express every possible character alignment.
explicitly. therefore  introduce binary variables ,.,.
  . iff .  aligned  . . .   .
write.
equalities .  similar   character selection.
constraints, ensuring   position    occupied.
 exactly one character   aligned  exactly.
one character  .  consecutive alignment .
 characters     string   established .
equalities . equalities . guarantee  .
   aligned   strings  . finally,  distance.
 bounded  .   string   constraints.
count  number  mismatched characters  .
target substring.  formulation  considerably larger.
 .csspp., yet   prove    stronger .
 polyhedral point  view.
ilp strength  compared  considering  respective  relaxations, ., instead  requiring binary variable assignments,  allow fractional solutions within . bounds.  solution       lower bound.
  true binary minimum.  say,   relaxation   weakly stronger    relaxation  .
 optimal objective value   least  large  .,.
  possible instance.    weakly stronger .
   vice versa,   .  corresponding.
ilp formulation.  said   .strictly. stronger .
 .  corresponding ilp formulation.   .
 weakly stronger   ,   incomparable.  .
theorem . .csspa.  polytope-wise stronger .
.csspp.
proof.  first argue    relaxation  .csspa.
 give strictly better bounds  .csspp. consider  instance . . .aaa, bab.,. . ., ., . . .
obviously,  optimal distance dopt . .  achieved,.
.,   . .  solving   relaxation .
.csspp.   instance,  optimal value  . . .
achieved  setting  variables  . . obs. . .
.csspa.,   easy  check   smallest  obtainable  . .  setting .,.,. . .
.,.
,. . .
.,.
,. . .
.,.
,. .
.,.,. . .
.,.
,. . .  .
.,.
,. . .
 remains  show    bound obtained.
 .csspa., .csspp.  generate  stronger bound.
 therefore show    transform  feasible.
fractional solution .  .csspa.   feasible fractional.
solution ., .  .csspp.    objective value.
consider  projections.
.,. .
.
.
.
. .
,.
.,.
.
,.
., .
.
.
.
. .
,.
.,.
.
.
   variable space  .csspp.   straightforward  show   projected feasible solutions .,.
 .csspp. equations .  .  satisfied. .
remains  prove . consider .   fixed string.
.   fixed starting position . .
.
.
. , .  .
.,. . .  applying  projections ., substituting.
  .,  applying .  obtain.
.
.
.
.
.
.,. , .
.
.
.
.
.
.
. .
.,.,. .
.
.
.
.
.,.,. .
.
 . appearing   right hand side also occurs.
  left hand side.  sums   right iterate .
 possible characters .   matched  .
.
.
 second term   left hand side sums  .
possible matchings   target substring  . .
 combination,  letters   one occurring  .
 summed .   point  substring starting.
 . will  considered.  remains  cover  variables.
 represent  letters occurring  .   easy .
see    covered   first term.  . .
non-negative, . holds  hence .  satisfied.
.
. delta constraints.   formulations.
  strengthened   following concept. consider.
 fixed substring .
.
.  give  lower bound   .
 case   substring  part   final solution.
therefore  select  substring .   string.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . .,   . . ddh. , .  minimal.
  substrings  . thus . denotes  distance.
 closest substring  .     fixed substring.
.
.
. clearly, .,. . maxs. . .   lower bound .
 optimal distance dopt  .,. . .   hence.
require ., . , .     . , . .  . . . . .
 .csspp. formulation,   case.
  possible   improve  constraints.
 .   set   pairwise different values ., .
 . .  .  . . . . since exactly one substring.
per string shall  selected    bounding .
 ,   consider multiple positions , .
., . .  . . . simultaneously.    .  .
. . .,   require.
.
. .
.,.
,.
.
. ,.
.
.
. .
.,.
.
.
.
.
,.,.
.
. .
 .csspp.  .csspa., respectively.  exists another possibility  enhance  delta constraints. instead  calculating pairwise distances,   compute closest .sub.strings  triples, quadruples,  even.
general r-tuples   given strings, fixing  . . .
substrings  considering  possible substrings  .
  . . strings. although  gives better lower.
bound estimates,  experiments show   additional computational effort   larger constraint.
matrix lead  worse running times  practice.
theorem . augmenting .csspp.  .csspa. .
.  ., respectively, give stronger formulations.
proof.   formulations .csspp.  .csspa. .
example instance   proof  theorem .  .
reused.   ., . .     ,  hence.
generate  constraint  . . .  strings .
 formulations.  root relaxation now gives .
optimal objective value   . . instead   . . .
 . .  .csspp.  .csspa., respectively. .
theorem .  .cssp.  .csspp. augmented.
 . .csspa.  .cssp.
.
.  incomparable. .csspa. augmented  .  stronger .
.cssp.
proof.  prove incomparability  .csspa. .
.cssp.  give two instances .  .  .
  relaxation  .cssp. results   larger solution value  .csspa.  .,  vice versa .
.  . . . . .aabaa, bbcbb, ccdcc, ddadd.,. .
., , , ., . . .   relaxation  .csspa. leads.
  . .    relaxation  .cssp. results.
  . . since ., . .     .  . . . .
.aabbaa, bbccbb, ccddcc, ddaadd.,. . ., , , ., . . .
  relaxation  .cssp. solves .   solution.
value   . . whereas   relaxation  .csspa.
results   . .
 .cssp.  .csspa. augmented  . .
show    relaxation  .cssp.  stronger .
 one  .cssp. therefore,  first observe  .
  instance     relaxation  .cssp.
results   larger solution value   relaxation .
.cssp.  show   bounds generated  .cssp.
.
.
 also  achieved  .cssp.  refer  theorem .
  fact   delta constraints .  .csspa.
  obtained  applying  projections . .
 delta constraints .  .csspp. .
. experiments   cssp.
. test environment  instances.  used.
  test environment  described  section .
,  impose  time limit  . minutes per instance.  tested  four formulations described.
.    denote  branch-and-cut algorithms solving .csspp.dynamically separating .
constraints . .csspa.dynamically separating  constraints .  ., respectively. .,.
. denote  corresponding algorithms   additionally separate  delta constraints .  .,.
respectively.
 compare  algorithm variants,  generate.
 purely random instances  instances according.
  scheme proposed  .,   particularly.
interesting   application   cssp  ., .motif search. first,  create  motif  length .  .
random strings  length . ,    string .
 randomly alter  motif   random positions .
.implant.   . according  .,   estimate.
 number  ., . patterns within  random string.
set.  expected number  motifs  length .  .
errors .
., . . . . . . , .
 .
.
.
.
.
.
. . . .
.
.
.
.
.
.
note      approximation  overlaps .
 covered.  instances  ., . . .   likely.
  implanted motif    substring  length.
.   errors.    hand,  ., . . .,.
  instance already contains   motif .
chance.  latter property  considered  resemble hard instances.  generated  set  parameter.
figure . ratio  termination statuses   formulations  different values  .  .
tuples ., , , ., ., listed  table .,  follows. .
 . . ., ., .    . ., ., .  tried.
 find , .,    ., . . ., .   close.
 ., ., ., .,  .,   biologically relevant lengths . . ., .     hard instances,  also increased .  .   ., .
 close  ., resembling reasonable parameters .
., . . . regarding random instances,  considered  ., . pairs.  created . instances  .
parameter tuple.
. behavior.  observed  already small instances tend   hard   ilp variants. figure .
shows  ratio   different termination statuses.
 turns    position-based formulations solve.
 instances  optimality   alignment-based.
ones. yet,  formulation classes clearly profit .
 addition   delta-constraints.   particularly  case    smaller instances.
 time needed  solve  root node  similar.
   .,     ., respectively.
however,  comparing  formulation classes, .
  least one order  magnitude faster   .
   really surprising,  .csspa. requires  much.
larger constraint matrix  .csspp.   bounds .
.csspa.  stronger    .csspp.,  former.
 lead  smaller branch-and-bound trees. yet, .
 observe   practice,  advantage  clearly.
outweighed   longer  relaxation times.  fig .
shows,  position-based formulations usually suffer.
 insufficient memory .  branch-and-bound.
trees exceeds  memory limit due   .bit cpu.
mode.,   alignment-based formulations run .
 time limit.
 turns    purely random instances .
 implanted instances  ., . . . behave .
similarly.  will therefore now concentrate  .
implanted instances .
 running times    .  ., . . . .
., . . ., respectively,  depicted  fig. . .
figure . running time   position-based ilp   without delta-constraints    cases  ., .
 instances   solved  optimality   formulations  considered.   . .  . . . .
aggregated  . .   . . note  logarithmic scale   vertical axis.
thereby consider  instances solved  optimality .
 algorithms. without delta-constraints,  behaves.
almost identically   cases  ., .  general,.
. achieves  best running times   formulations,.
 particular  small . thereby  observe  deltaconstraints  particularly efficient  smaller ., .
values.   cases,  obtained lower bounds .
non-optimal positions  stronger.
 comparing   .   alignment-based.
formulations  turns      slowest  .
formulations  . outperforms    larger.
.  analysis suggests  delta-constraints .
 stronger impact   practical performance .
 choice   formulation, especially  small-k instances. one  speculate   alignment-based.
formulations may become superior   position-based.
 larger instances,  ,  stronger bound may.
lead  significantly smaller search trees.  speculation  </doc>
<doc title='alx11_03_gogs.txt'>
fast  lightweight lcp-array construction algorithms.
simon gog . enno ohlebusch .
abstract.
 suffix tree    important data structure  string.
processing,   suffers   huge space consumption. .
large-scale applications, compressed suffix trees .csts. .
therefore used instead.  cst consists  three .compressed.
components.  suffix array,  lcp-array,  data.
structures  simulating navigational operations  .
suffix tree.  lcp-array stores  lengths   longest.
common prefixes  lexicographically adjacent suffixes, .
   computed  linear time.   paper,  present.
new lcp-array construction algorithms   fast .
 space efficient.  practice,  algorithms outperform.
 currently best algorithms  large inputs.
. introduction.
 suffix tree   string   length    compact.
trie storing   suffixes  .    extremely.
important data structure  applications  string.
matching, bioinformatics,  document retrieval, .
mention    examples. see . .  drawback.
 suffix trees   huge space consumption  .
. times  text size, even  carefully engineered.
implementations.  reduce  size, several authors.
provided compressed suffix trees .csts. see . .
 .   survey.  cst     divided .
three components. .  suffix array , specifying.
 lexicographic order  . suffixes, .  lcp-array,.
storing  lengths   longest common prefixes .
lexicographically adjacent suffixes,  . additional.
data structures  simulating navigational operations.
  suffix tree.
particular emphasis   put  efficient construction algorithms   three components  csts.
., .efficiency. encompasses  construction time.
 space,   latter  cause  significant memory.
bottleneck.   especially true   first component.   last decade, much effort  gone .
 development  efficient suffix array construction.
algorithms .sacas. see .   survey. although.
linear-time direct sacas  known since ., .institute  theoretical computer science, university  ulm,.
. ulm.
.institute  theoretical computer science, university  ulm,.
. ulm.
periments showed .    outperformed .
practice  sacas   worst-case time complexity  . log .  date, however,  fastest saca.
  linear time algorithm .  uses  . bytes.
memory. interestingly,  ascii alphabet  speed .
compete   fastest lcp-array construction algorithms .laca.  uses equal  less space.  .
somewhat surprising  sorting  suffixes seems.
   difficult  computing lcp-values.
 discussed  section ., today. best lacas.
., .  linear time algorithms,   suffer .
 poor locality behavior.   paper,  present.
two  space efficient .using   . bytes .
 fast lacas. based   observation  one.
cache miss takes approximately  time  . character.
comparisons,  try  trade character comparisons .
cache misses.  algorithms use  text .string. ,.
 suffix array,   burrows-wheeler transform.
.bwt. since  csas  based   bwt.
anyway,  basically get   free.
section . shows  significance   algorithms.
 precisely, experimental results show  .
algorithms outperform state-of-the-art algorithms ., .
 many large texts   always faster  .
previously best algorithms.  superiority   new.
lacas varies   text size . larger  better.,.
 alphabet size . smaller  better.,  number.
 .large. values   lcp-array . less  better.,.
  runs   bwt .   better. .
algorithms work particularly well  two types  data.
   utmost importance  practice. long dna.
sequences .small alphabet size.  large collections .
xml documents .long runs   bwt.
. related work.
  seminal paper ., manber  myers  .
 introduce  suffix array  also  longestcommon-prefix .lcp. array.  showed  .
 suffix array   lcp-array   constructed.
ino. log . time   string  length . kasai  . .
gave  first linear time algorithm   computation.
  lcp-array.  algorithm uses  string , .
suffix array,  inverse suffix array,   course .
lcp-array.    arrays requires . bytes .
 assumption   . ., thus  algorithms needs.
copyright . . siam .
unauthorized reproduction  prohibited.
.
. bytes  total .  ascii alphabet.  main.
advantage   algorithm     simple  uses.
  . character comparisons.   poor locality.
behavior results  many cache misses,   .
severe disadvantage  current computer architectures.
manzini . reduced  space occupancy  kasai .
. algorithm  . bytes   slow   .
.  also proposed  even  space-efficient.
. slower. algorithm  overwrites  suffix array.
recently, .rkka.inen  . . proposed another variant.
 kasai  . algorithm,  computes  permuted.
lcp-array .plcp-array.   plcp-array,  lcpvalues   text order .position order. rather  .
suffix array order .lexicographic order.  algorithm.
takes  . bytes   much faster  kasai .
. algorithm     much better locality.
behavior. however,  virtually  applications lcpvalues  required    suffix array order,  .
  final step  plcp-array must  converted .
 lcp-array. although  final step suffers .
  poor locality behavior,  overall algorithm .
still faster  kasai  .   different approach,.
puglisi  turpin . tried  avoid cache misses.
 using  difference cover method  .rkka.inen.
 sanders .  worst case time complexity .
 algorithm  .   space requirement.
  . . . . bytes,     size  .
difference cover. experiments showed   best.
run-time  achieved   . .,   algorithm.
 still slower  kasai  .    .
uses constant time range minimum queries,  take.
considerable time  practice.  sum ,  currently.
best laca    .rkka.inen  . .
. preliminaries.
 .   ordered alphabet whose smallest element.
  so-called sentinel character .  . consists  .
characters   fixed,   may view .   array.
 size .    characters appear  ascending.
order   array . . ., ., . . . . . .
. . . . . . .   following,    string .
length   .   sentinel character   end.
. nowhere else.  . .  .  . ., . denotes.
 character  position   .   . , .
denotes  substring   starting   character .
position   ending   character  position .
furthermore,  denotes  suffix . .  . .
suffix array    string    array  integers.
  range .   . . specifying  lexicographic.
ordering    suffixes   string ,  , .
satisfies ssa. . ssa. . . . . . ssa. see fig. . .
 example.   following, isa denotes  inverse .
 permutation .
 lcp-array   array containing  lengths.
  longest common prefix  every pair .
consecutive suffixes  .  use lcp., .  denote.
 length   longest common prefix  strings.
  . thus,  lcp-array   array  integers  .
range .     lcp. . ., lcp. . ., .
lcp. . lcp.ssa., ssa.  . .  .  . . see fig.
.   . ,  range minimum query rmq., .  .
interval .   lcp-array returns  index  .
 lcp. . min.lcp. .  .  . .    difficult.
 show  lcp.ssa., ssa. . lcp.rmq. ., .
 burrows  wheeler transform . converts.
 string    string bwt. . . defined .
bwt. . . . .     . . . .
bwt. . . otherwise. see fig. .  lf-mapping .
defined  . . isa. .     . . .
 . . . otherwise. see fig. .  long name.
last-to-first column mapping stems   fact .
 maps  last column  . bwt   first column.
 ,   contains  first character   suffixes.
  suffix array, .,  . . .  precisely,.
 bwt. .    k-th occurrence  character .
 bwt,   . .   index    .
  k-th occurrence     .  lf-mapping.
  implemented  . . . . occ., ., .
 . bwt., .   overall number . occurrences.
 characters     strictly smaller  , .
occ., .   number  occurrences   character .
 bwt.
. first algorithm.
  section,  present  first laca.  pseudocode description   found  algorithm .  .
application    illustrated  fig. . furthermore,.
theorem .    prove  correctness .
also explains .  algorithm  based  lemma .,.
  turn requires  following definition.
define  function prev .
prev. . max. . . .  .   bwt. . bwt.
 prev. . .   maximum  taken  .
empty set. intuitively,   start  index   scan .
bwt upward,  prev.   first index  .
  character bwt. occurs.
lemma .
lcp. .
.
.,  prev. . .
. . lcp.rmq.prev. . ., ., otherwise.
proof.  prev. . .,  slf.   lexicographically smallest suffix among  suffix .
bwt.  first character. hence lcp. . .
otherwise, .prev. . . . .   case,  follows  lcp. . lcp.ssa., ssa. .
lcp.ssa.prev., ssa. . . .
lcp.ssa.prev., ssa. . . . lcp.rmq.prev. . ., .
theorem . algorithm . correctly computes .
lcp-array.
proof.   assumption   entries  .
lcp-array   first . iterations   for-loop .
 computed correctly,  consider  i-th iteration.
 prove.
.  lcp. . .,   entry lcp. will .
computed correctly.
.  . . ,   entry lcp. will .
computed correctly.
.   if-condition  line .   true, .
ssa.  ssa.  compared character  character.
.lines .  lcp.  assigned  correct value .
line . otherwise,   if-condition  line .  true,.
 .  set  max.lcp. . ., .  claim .
. . lcp.   certainly true  . . .,  suppose.
 . . lcp. . . . . according  . proof.
. lemma ., lcp. . . lcp.ssa.prev., ssa.
obviously, lcp.ssa.prev., ssa. . lcp.ssa., ssa.,.
  claim follows.
now,  bwt. . bwt. . .,  ssa. .
ssa.  compared character  character .lines .,.
  first . characters  skipped   .
identical. , lcp.  assigned  correct value.
 line . finally,  bwt. . bwt. . ., .
prev. .  . . ,  conjunction  lemma.
., yields lcp. . . . lcp.ssa.prev., ssa. .
lcp.ssa., ssa. . lcp. thus, . . lcp. . .
 already  correct value  lcp.  lines . .
 skipped   assignment  line .  correct.
.   linear scan   lcp-array,  always.
 last occ.bwt. . prev. therefore,    direct.
consequence  lemma .   assignment  line.
.  correct.
 still   explain   index  .
rmq.last occ.bwt. . ., .   lcp-value lcp.
copyright . . siam .
unauthorized reproduction  prohibited.
.
 line .   computed efficiently.   end, .
use  stack   size .  element   stack.
  pair consisting   index   lcp-value. .
first push .,. onto  initially empty stack .  .
 invariant   for-loop   stack elements .
strictly increasing   components . bottom .
top.   ith iteration   for-loop,  line .,.
 update  stack   removing  elements whose.
lcp-value  greater   equal  lcp. , .
push  pair ., lcp. onto . clearly,  maintains.
 invariant.   . last occ.bwt.  answer.
 rmq., .   pair ., .     minimum .
 indices   greater   equal  .  pair.
  found   inspection   stack. moreover,.
 lcp-value lcp. . .   looking   . . .
meet  . space condition   stack,  check.
  . update   size     greater .
.  ,   remove . . elements   .
    . possible queries.   strategy,.
 stack size never exceeds .   amortized time.
  updates  . furthermore,  inspection .
 stack takes . time.  practice,  works particularly well     run   bwt .
  element   searching    top  .
stack.
algorithm .   quadratic run time   worst.
case, consider .  string  . ababab.
. engineering algorithm .
 first glance, algorithm .     advantage  kasai  . algorithm   holds ,.
, , bwt,  lcp  main memory.  closer look,.
however, reveals   arrays , ,  bwt .
accessed sequentially   for-loop.    .
streamed  disk.   avoid  random access  ,    lcp   shall show next.
 problematic   .jumps. upwards .line .
 . . .  downwards .line .  . . .
 key idea   buffer lcp-values  queues .fifo data.
structures.   retrieve   needed.
first, one  show   condition lcp. . .
 line .  equivalent   . . . . occ.bwt., .
 last condition   evaluated  constant time.
 space .increment  counter cnt.bwt.  iteration.
.,    replace lcp. . .  line .  .
important   case  . . . ,  value.
lcp.  still  one   queues    yet.
 written   lcp-array.   words, .
 reach index ,  still  lcp. . . although.
lcp.  already  computed. thus,   test.
 . . . . occ.bwt., .   decide whether.
lcp.  already  computed  .
second, . lies   .bwt. .
.bwt.occ.bwt., .,  interval   suffixes.
 start  character bwt. note   .
  . different  intervals.  exploit  fact.
  following way.   character  . .  use .
queueqc.   for-loop  add .enqueue.  values lcp., lcp., . . . , lcp.occ., .
 exactly  order  .  iteration ,  operation enqueue., .  done   . bwt.   .
lcp.rmq.last occ.bwt., .  line . provided.
 . . ,   line .   .  .   . . also.
 iteration ,  operation dequeue.  done   .
bwt.  line . provided  . . .  dequeue.
operation returns  value lcp.   needed.
 line . moreover,   . . . . occ.bwt., .,.
  know  lcp.   computed previously   still  one   queues. thus,  operation dequeue.  done   .  . immediately.
 line .,   returns  value lcp.
 space used   algorithm now  depends.
  size   queues.  use constant size buffers.
  queues  read.write  elements . disk.
  buffers  full.empty . even allows  answer.
 rmq  binary search ino.log. time. therefore,.
  text  remains  main memory   obtain.
  bytes semi-external algorithm.
. second algorithm.
 section contains  second laca. see algorithm.
.   based   following observation.   set.
m-indices, consisting   indices   lcp. . ,.
 known .initially,   true   . .   entries.
  lcp-array   value .   already .
computed,    possible  compute  set .
. .-indices  lemma .
fix  index  . m-indices.  define functions .
  .
. . max. . . .  . , bwt. . , .
.   .  .  . lcp. . .
. . min. .  .  . , bwt. . , .
.   .  .  . lcp. . .
  . .  . . . . . .  .
maximum .minimum.  taken   empty set.
lemma . fix  index  . m-indices.   .
.   . . .  . . . .
lcp. . . .
proof.  lemma .,   lcp. .
. . lcp.ssa.prev., ssa. moreover,  .
readily verified  prev. . . ,.
 conjunction  lcp.ssa., ssa. . ,.
proves  lemma.
copyright . . siam .
unauthorized reproduction  prohibited.
.
algorithm . construction   lcp-array.
. lcp. .,.,., . . . ,.,.
.  char . .    . .
. . .
. m-indices. ., . . . , . . .
. repeat.
. . .-indices. .
.    . m-indices .
.  . .
.   char. .
.  lcp. .     char . . .
.   char .bwt. . . .  .
.  char .bwt. . . .
.   char.   char . .
.  .  . .
.  . .
.  . .   lcp. . . .
.   char . . .
.   char .bwt. .  .
. add .   set . .-indices.
.  char .bwt. .
.   char.   char . .
.  .  . .
. lcp. .
. . . .
.   lcp-values  calculated.
theorem . algorithm . correctly computes .
lcp-array.
proof.   . m-indices.   while-loop  lines.
.,  algorithm scans bwt upwards  long .
 corresponding entry   lcp-array  greater.
  equal      characters  .
seen  far. whenever  encounters  character  .
seen ,  sets  char .    increments.
 counter   char   characters seen  far .
one.    while-loop  lines .,  .
. . .      char . . .   whileloop  lines .,  algorithm scans bwt downwards.
 long   corresponding entry   lcp-array .
strictly greater      characters  .
. . . holds   seen  far. whenever.
 encounters  character   seen   .
. . . holds, say  index ,   adds . .
 set . .-indices. according  lemma ., .
 correct   . .  avoid   .
character   considered ,  char .  set  .
.undefined. furthermore,   char  decremented .
one.
observe   contrast   upward scan, .
downward scan stops   index .  lcp. . .
 reached.    harm  . . m-indices,.
.,  algorithm starts  downward scan starting .
index .,  . . .  index .  . . . .
index .
  string  . .,  upward scan ends.
 index .   worst case time complexity .
algorithm .  also .
.  hybrid algorithm.
 experiments showed  even  careful engineered.
version  algorithm .   always beat  currently fastest laca .   reason,  will now.
present  hybrid  algorithms .  .  uses  modification  algorithm .   first phase.  modified.
version computes  lcp-entries whose value  smaller.
  equal  .,  .   user-defined value.
.  know    entries    .
greater  .    obtained  algorithm .
 modifying lines ., .,  .  follows.
.  bwt. . bwt. .  . . . .
.  . . .  . . .
.
. lcp. . min.lcp.rmq.last occ.bwt. .
., . . .,. . .
 practice, . . .   good choice  lcpvalues greater  .   marked   value .
  lcp-entry occupies  one byte. .
 string  must also  kept  main memory, .
results   total space consumption  . bytes.
  . . . . .  .   lcp. . .  .
array containing  indices    values  .
lcp-array  . .  phase .   second phase.
   calculate  remaining  . . many lcpentries,    use algorithm .   task. .
many texts, however,    . . see section.
.   case,  cache misses   avoided .
restricting  original arrays lcp, ,  bwt .
 indices  .  denote  compact arrays.
 lcpi, lfi,  bwti. see table .  following.
additional information  needed  adapt algorithm .
  compact arrays.
.    adjust lfi   entries give .
original indices   lcp-array,   need .
relative   new indexing.  relative values.
  calculated  linear time   stored .
.
.  algorithm .,  start   index   lcp. .
.   scan  lcp-array up-  downward.
copyright . . siam .
unauthorized reproduction  prohibited.
.
algorithm . optimized version  phase . using .
. bytes  space.
.  .  . . downto . .
.  lcpi. . .
.  enqueue.-indices., .
. lcpi . .
. . .
. repeat.
.  . . . . downto . .
.  m-indices.   empty .
. . dequeue.m-indices.
.  . .
.   char. .
.  .bwti.,bwt.
.
 . . ., . .
.   char . . .
.   char .bwt. . .  .
.  char .bwt. . .
.   char.   char . .
.  run. . .  break.
.  .  . .
.  . .
.  .bwti.,bwt.
.
 . . ., . .
.   char . . .
.   char .bwti. .  .
. lcpi. contains .
.
 . .
. enqueue. .-indices.bwti.,.
lcpi.
.  char .bwti. .
.   char.   char . .
.  run. . . . .  break.
.  .  . .
. lcpi. .
. .bwti.,bwt.
.
 . ., .
. . . .
.   lcp-values  calculated.
  index   found  lcp. . . .
decide   scan must  terminated,  introduce.
 array run .
run. .
.
.   . .  . . . . . .
. otherwise.
 lcp. . .,   lcp. . . . .  .
  run. . .
.  always  access  bwt. . .,  add.
 array bwt.   defined  bwt.
.
 . .
bwt. .
. fact,  downward scan ends  lcp. . . .
case will also  dealt .
now    ingredients   space optimized.
version   second phase  shown  algorithm .
  improve  locality behavior,  store .ientries   lcpi-array.   possible  .
will  access lcp-values.   ,   faced.
  problem    decide   point .
time  up-  downward scan    terminated.
. run-array   useful   original threshold.
.     . .  solve  problem,  will.
access m-indices  decreasing order  whenever .
index  . m-indices   .fully treated. . line.
.,    written  lcpi.  mark   setting.
.bwti.,bwt.
.
 .  ., .
.
  able  access m-indices  decreasing order,.
 use . queues.one   character   alphabet.
 index   put  queue m-indices.   suffix .
index    suffix array starts  character . .
queues  initialized   .-indices  lines .  .
note   indices   queue   decreasing.
order.   for-loop  line .,  access  queues.
one  one  decreasing lexicographic order.  .
 . .   clear   m-indices  processed.
 decreasing order.  still must  shown  .
decreasing-order-property   invariant   repeatloop, .,   assumption   holds  , .
must  shown   also holds  . .   .
indeed  case follows  two key observations. first,.
 indices   lcpi.
.
. . .  bwti. . .
 processed  decreasing order   m-indices.
 processed  decreasing order. second,   .  .
bwti. . bwti.,  .
.
. . .
.
.  latter  .
consequence   central property   lf-mapping.
 bwt. .    q-th occurrence  character  .
 bwt,  . .    index    . .
 q-th occurrence     .
. experimental results.
besides algorithms .  .,   implemented .
compared four lacas.
. klaap.  semi-external version   algorithm.
presented  . using . bytes. pseudo code .
presented  algorithm .
. .-kmp.  semi-external version   algorithm.
presented  . using . bytes. pseudo code .
presented   algorithm .
. .  hybrid algorithm presented  section .
using . bytes  memory.
. . occurs    bwt  pair ., . .
occur initially.
copyright . . siam .
unauthorized reproduction  prohibited.
.
 . lcpi. lfi. .
.
. run. bwti. bwt.
.
 .  .
. . . . .  .  anelen.
. . . .  .  . ele lepanelen.
. . . . . . .   elen.
. . . . . .   len.
. . . .  .  lepanelen.
. . . . . . .   nelen.
table .  compact arrays   . . . . .  .   lcp. . .
. .  hybrid algorithm using buffered queues.
  first phase . sec. .  therefore usually.
using   bytes  memory.
.
 implementations  part   first author. sdsllibrary,   available   gpl licence .
http.goo.faeu.  library provides  array.
data structure called int vector  uses   bits.
per integer .  constant  lies  ., .,   .
bit compressed array.  enables  implementations.
 work  input greater  .  without doubling.
 space. however,  access time   int vector.
element   . slower    byte aligned.
version. since  sacas use byte aligned arrays, .
speed relative   lacas  faster   factor.
 used  pizza.chili  manzini. corpus  test.
set.  tests  performed    equipped .
 dual-core amd opteron . processor  . .
main memory. tables .  . show  running times.
. measured real time.  peak memory consumption.
 different text categories, text sizes,  algorithms.
 course,    interesting  know  .
lacas perform relative    phases  .
cst construction.  experimental results  figure.
. answer  question. although  hybrid algorithm.
 performs many  character comparisons .
klaap  .-kmp,  clearly beats  algorithms .
 pizza.chili corpus.  example, klaap  .kmp take . . . character comparisons   input.
dblp.xml.   takes . . .  contrast,.
 requires  . . . random accesses   text,.
   algorithms need  . .see table.
.   texts.  cost  random accesses increases.
 file size.    two times faster  klaap.
 .  dna sequence,   three time faster .
. finally,   focus   two phases  .
 first phase usually takes  space  time. .
parameter    second phase lies   range.
 . .xml.  . .english text  many.
repetitions.  small  . . ., algorithm .
beats   time,    totally inappropriate .
large  .  takes . times longer  english. .
. algorithm . never beats another algorithm  time.
 space.
acknowledgment  recent developments.
 corpus  manzini contains one test case  .
 worst-case behavior occurs.  human chromosome . .see table . despite  fact   .
  lcp-values  greater  .,  second phase.
takes  . times longer   linear algorithms.
 thank  anonymous reviewers  pointing  .
   hard test case.  problem lead   redesign.
 algorithm.    idea.  second phase .
 made linear  applying  .-algorithm   small.
subset   lcp-values   greater  . .
  done   .  log  . . bits  using .
rank data structure   bit vector  indicates .
 lcp-value  greater  .  algorithm consisting  phase .   modified phase .   linear.
time worst case complexity.  will  made available.
 http.arxiv.org.
</doc>
<doc title='alx11_04_berberiche.txt'>
 elimination method  solving bivariate polynomial systems.
eliminating  usual drawbacks.
eric berberich. pavel emeliyanenko. michael sagraloff.
abstract.
 present  exact  complete algorithm  isolate.
 real solutions   zero-dimensional bivariate polynomial system.  proposed algorithm constitutes .
elimination method  improves upon existing approaches   number  points. first,  amount .
purely symbolic operations  significantly reduced, .
,  resultant computation  square-free factorization  still needed. second,  algorithm neither assumes generic position   input system  demands.
  change   coordinate system.  latter .
due   novel inclusion predicate  certify   certain region  isolating   solution.  implementation exploits graphics hardware  expedite  resultant computation. furthermore,  integrate  number  filtering techniques  improve  overall performance. efficiency   proposed method  proven .
 comparison   implementation  two state-ofthe-art implementations,  , lgp  maple. isolate.   series  challenging benchmark instances,.
experiments show   implementation outperforms.
 contestants.
. introduction.
finding  real solutions   bivariate polynomial.
system   fundamental problem  numerous.
applications  computational geometry, computer.
graphics  computer aided geometric design. .
particular, topology  arrangement computations .
algebraic curves ., ., ., ., . crucially rely  .
computation  common intersection points   given.
curves . also  curves defined   partial.
derivatives.   design  robust  certified.
algorithms,  aim  exact methods  determine.
isolating regions   solutions.  methods .
 capable  handling  input,  , even systems.
 multiple solutions.  proposed algorithm.
bisolve constitutes   exact  complete.
approach.  input   zero-dimensional ., .
exist  finitely many solutions. polynomial system.
.max-planck-institut . informatik, saarbru.cken, germany,.
.eric,asm,msagralo.mpi-inf.mpg.
., . . ., . . . defined  two bivariate polynomials  integer coefficients. bisolve computes.
disjoint boxes ., . . . ,  . .   real solutions,.
  box  contains exactly one solution .,.
  isolating.  addition,  boxes   refined.
  arbitrary small size.
main results. bisolve   classical elimination.
method  follows   basic idea   grid.
method  .   insulate method  .
 computing  topology   algebraic planar.
curve.  ,   consider several projection.
directions  derive  set  candidates  possible.
solutions  eventually identify  candidates .
 actually solutions.
 precisely,   first step,  separately eliminate  variables     means   resultant computation. ,   second step,   possible.
candidate .represented  pair  projected solutions .
  y-direction.,  check whether  actually constitutes  solution   given system  .  proposed method comes   number  improvements.
compared   aforementioned approaches  also .
 existing elimination techniques ., ., ., ., .
first,  tremendously reduced  amount  purely.
symbolic computations, namely,  method  demands  resultant  gcd computation  univariate polynomials  integer coefficients. second, .
implementation profits   novel approach ., .
 compute resultants exploiting  power  graphics.
processing unite .gpus.  remark ,  comparison   classical resultant computation   cpu,.
 gpu implementation  typically   .times faster.  experiments show ,   considered instances,  resultant computation   longer .
.global. bottleneck   elimination approach. third,.
 proposed method never uses  kind   coordinate transformation, even  non-generic input. .
.  analysis   planar curve  . ., . . . . ., . .
.,   crucial  find  solutions   .  . .  method.
 . uses several projection directions  find  solutions.
. system  .  . .  non-generic   exist two.
solutions sharing  common coordinate.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
latter  due   novel inclusion predicate  combines information   resultant computation .
 homotopy argument  prove   certain candidate.
box  isolating   solution. since  never apply.
 change  coordinates,  method particularly profits   case      sparse   .
  interested  .local. solutions within  given.
box. finally,  integrated  series  additional filtering techniques  allow   significantly speed .
 computation  many instances.
 implemented  algorithm   prototypical package  cgal .  ran  software .
numerous challenging benchmark instances.  comparison,  considered two currently state-of-the-art.
implementations,  , isolate .based   .
fabrice rouillier  ideas  .  lgp .
xiao-shan gao  . .,  interface  maple .
 experiments show   method  efficient  .
outperforms  contestants   instances. .
precisely,  method  comparable   considered.
instances  typically  .  .-times faster.
  instances,  even improve   factor  .
 .  filters apply  many input systems.
 crucially contribute   overall performance.
  remark   gain  performance .
 solely due   resultant computation  .
gpu  rather due   combination   sparse.
use  purely symbolic computations  efficient.
.approximate. subroutines.  prove  latter fact.
 providing running times   without fast.
gpu-resultant computation.
related work. since polynomial root solving  .
 important problem  several fields, plenty  distinct.
approaches exist  many textbooks  dedicated .
 subject.  mainly distinguish  two kinds.
 methods.
 first comprises non-certified  non-complete.
methods  give,  contrast   goal , .
guarantee  correctness  termination .,  multiple.
roots exists. representatives   category .
numerical ., homotopy methods .  subdivision.
methods. ., ., ., .  major strength  .
methods      efficient   instances.
due   use  approximate computations  .
provided  intbis, alias, intlab  mpfi.
 second category consists  certified  complete methods       added.  far, .
elimination methods based  .sparse. resultants, rational univariate representation, groebner bases  eigen.subdivision methods   made certifying  complete.
 considering worst case separation bounds   solutions,.
 approach    shown effective  practice  far.
values  proven   reasonably efficient representatives   category. see,  instance, ., ., ., .
 introductions   symbolic approaches. common    methods    combine  projection   lifting step similar   proposed approach. recent exact  complete implementations.
 computing  topology  algebraic curves  surfaces ., ., ., ., ., . also make use   elimination techniques. however, already  low dimensional application shows  main drawback  elimination methods,  ,  tremendously suffer .
costly symbolic computations. furthermore,  given.
system might   non-generic position  makes.
 lifting step non-trivial.   .hard situations.,.
 existing approaches perform  coordinate transformation . project  generic direction.  eventually increases  complexity   input polynomials.
 particular,     interested  .local. solutions within  given box,  methods induce  huge.
overhead  purely symbolic computations.  proposed algorithm constitutes  contribution  two respects.  number  symbolic steps  crucially reduced  partially .resultant computation. outsourced.
  gpu.  addition, generic  non-generic situations  treated    manner , thus,  coordinate transformation  induces  overhead .
symbolic computations   longer needed.
. setting.
 input   algorithm   following polynomial.
system.
.
.
., . .
.
,.
fijx.
iyj . .,.
., . .
.
,.
gijx.
iyj . .,.
  ,  . ., .  polynomials  total degrees .
 , respectively.  also write.
., . .
.
.
.
.
 .
 .
.
.
.
.
 .
 .
., . .
.
.
.
.
 .
 .
.
.
.
.
 .
,.
  . , .
.
 . .,  . , . . .  , .
 ,  denote  degrees     considered.
 polynomials    , respectively. throughout.
 paper,   assumed       common.
factors. hence,  set  . ., . . ., . .
.otherwise,       decomposed  common .
non-common factors . part   algorithm.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
., . . .  .complex. solutions  .  zerodimensional  consists,  .zout. theorem,  .
  .  distinct elements.
 algorithm outputs disjoint boxes  . . .
  union    contains  real solutions.
 . ., . . ., . . ., . . . .  . .
 .     isolating,  ,  contains.
exactly one solution.
notation.   interval  . ., . . ,  .
. . . denotes  center   . . . . .
radius  .   arbitrary  .    . ., .
denotes  disc  center   radius .
.  algorithm.
. resultants  method  based  well known.
elimination techniques.  consider  projections.
.
.
 . . . . .   ., . . ., . . .,.
.
.
 . . . . .   ., . . ., . . .
  complex solutions  onto    y-coordinate.
resultant computation   well studied tool  obtain.
 algebraic description   projection sets,  ,.
polynomials whose roots  exactly  projections .
 solution set .  resultant . . res., , . .
    respect   variable    determinant.
  . . . . . . sylvester matrix .
  definition,  follows  . . . .
degree less   equal   . .  resultant.
. . res., , .      respect    defined.
 completely analogous manner  considering   .
 polynomials   instead  .  mentioned .
 resultant polynomials   following important.
property . .   proof.
theorem .  roots  .  exactly  projections   solutions  . onto  x-coordinate.
  roots   greatest common divisor . .
gcd.fmy ., gny .   leading coefficients  .
 .  precisely,.
. . . . . .  . . . . . . .
 .,  corresponding result holds.
. . . . . .  . . . . . . .,.
 . . gcd.fmx., gnx.  multiplicity.
  root .  . .   sum.   intersection.
multiplicities.   solutions  .  x-coordinate.
.y-coordinate. .
. isolating  solutions. project, separate.
 validate  start   following high level.
description   proposed algorithm  decomposes.
 three subroutines.   first step .project., .
project  complex solutions   . onto  xand onto  y-axis.  precisely,  compute .
restrictions  . . .
.
 .   . .  . .  .
complex projection sets  .  .
.
   real axes.
 isolating intervals   elements. obviously,.
 real solutions   contained   cross product.
 .  . . . . .   second step .separate.,.
 compute isolating discs  well separate .
projected solutions   .  latter prepares.
 third step .validate.   candidates   .
either discarded  certified    solution  .
 main theoretical contribution   introduction.
  novel predicate  ensure   certain candidate.
., . .  .  actually fulfills ., . . ., . . .
. theorem .   candidates ., . . .,.
simple interval arithmetic suffices  exclude ., .  .
solution  .
 remark ,  order  increase  efficiency.
  implementation,  also introduce additional.
filtering techniques  eliminate many   candidates.
 . however,   sake  clarity,  refrain .
integrating  filtering techniques   following description   three subroutines. filtering techniques.
 covered separately  section . section . briefly.
discusses  highly parallel algorithm   graphics.
hardware  accelerate computations   resultants.
needed   first step.
project.  compute  resultant  . . .
res., , . . .   square-free factorization  .
 precisely,  determine square-free  pairwise.
coprime factors  . .,  . ., . . . ,deg.,  .
. .
.deg.
. .
.  remark ,  .
.  root .  . . .,  intersection multiplicity       .infinite point. .,. . ., . .
also  taken  account.  simplicity,  decided  .
consider   general projective setting.
. multiplicity   solution ., .  .  defined.
  dimension   localization  ., ., .  ., .
considered  c-vector space . ., .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 . ., . . . ,deg., . . . yun. algorithm .,.
alg. . constructs   square-free factorization.
 essentially computing greatest common divisors.
    higher derivatives   iterative way.
next,  isolate  real roots ., ,  . ., . . . , ., .
 polynomials .  ,  determine disjoint.
isolating intervals .,. .     interval.
.,. contains exactly one root .namely, .,. .
   union   .,.,  . ., . . . , ., covers.
 real roots  .   real root isolation, .
consider  descartes method ., .   suited.
algorithm.   square-free factorization  know.
 ., ,  . ., . . . , .,   root    multiplicity .
separate.  separate  real roots   . . .
  .complex. roots  ,  step   crucial.
  final validation.  precisely,  . . .,.
  .-th real root   polynomial . , .
. . ., . . . ,deg.  . . ., . . . , .  arbitrary.
indices.  refine  corresponding isolating interval.
 . ., . . .    disc . .  .
contain  root  . except .   refinement.
 ,  use quadratic interval refinement .qir .
short. ., .  constitutes  highly efficient method.
   simple tests   fact   eventually.
achieves quadratic convergence.
 order  test whether  disc . . isolates.
.    roots  ,  consider  approach.
  first introduced  .   based  .
following test.
 ., . . . .
.
.
.
.  . .,.
  . . denotes  arbitrary polynomial  ,.
,  arbitrary real values. ,  following theorem.
holds.
theorem . consider  disk . . . .  .
center   radius .
.   ., . holds    . .,   closure.
.  . contains  root  .
.   .
.
 ., . holds    .
.
.,  . contains.
  one root  .
proof. . follows   straightforward computation.
   . .,  .
. . . . . . . .
.
.
.
.
. .
.  similar result,  reader may also consider . .
 corresponding test  introduced   based  interval.
arithmetic .
, thus,.
.
. . .
.
. .
.
.
.
.
. .
.
. .
.
.
since . . . .    ., . holds.  particular,.
  . .,   inequality implies . . . ,.
thus,    root  .
 remains  show .   .
.
 ., . holds, ,.
  point  . .,  derivative . differs .
.   complex number  absolute value less .
. consider  triangle spanned   points.
., .  .,   .  . denote  angles.
  points .  ., respectively.   sine.
theorem,  follows .
. sin. . . . . . sin . .
.
.
.
thus,  arguments  .  . differ  less.
 arcsin.   smaller   equal  .
  . . assume   exist two roots ,  . .
 . since  .  implies . . .,    possible.
  .
.
. ., . holds,   assume   . .  split.
   real  imaginary part,  ,  consider.
. . . . ., . . ., .  ,  . . .  .
two bivariate polynomials. , . . . . . .
 . . . . . . . . .  . . . . .
implies, due   mean value theorem  several real.
variables,   exists  . . ., .  .
. . . .
similarly, . . . . . implies   exists .
. . ., .   . . . . .  . .
., . . ., ., thus,  follows .
. . . . . therefore, .  . must .
perpendicular. since . .  . ivx .  . iuy, .
arguments  .  . must differ  . .
contradicts   result   differ  .
argument  .  less  ., thus, . follows.
theorem . now directly applies   .
scenario,   . .   . . .  precisely, .
 refined   . .
.
. . , .  .
.
. . , . holds.
   . .   latter two conditions  fulfilled,.
. . isolates .    roots  .  .
situation,  obtain  lower bound .  . .
 boundary  . . . .
lemma .     interval  contains  root.
.  . .  .
. .
.
. . , .  .
.
. . , . holds .
  . .,   disc . . . . isolates .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
   .complex. roots   ,    .
 boundary .  .,  holds .
. . . . .deg. . .
proof. .  isolating  already . .  isolating. ,  . . .   arbitrary root   .
 . . .  . . .  distance  .   .
,   point  . .,  holds .
. . .
. . . . .
. .
. .
. . .
. .
.
.
.
.
. . .
. . . . .
.
.
.
.
.
.
hence,  follows .
.
. . . .
. . . .
. . . .
.
.
. . .
. . .
. . . .
. . deg. ,.
  root . occurs  many times   .
product   multiplicity   root  . .
 compute . . .deg. . .
 store  interval .,  disc .  .
lower bound .  .   boundary .
 .
proceeding  exactly   manner  .
real root .  .,  get  isolating interval .,.
 isolating disc . . . .   lower bound.
.  .  .   resultant polynomial ., project  separate  processed.
 exactly   manner.  compute . .
 corresponding square-free factorization. , .
 real root .  .,  compute  corresponding.
isolating interval .,  disc .   lower bound.
.  .  .
validate.  start   following theorem.
theorem .  .  .  arbitrary real roots .
.  ., respectively. ,.
.  polydisc ., . . . . . contains.
  one .complex. solution  .  ., .
contains  solution  .,   solution .
real valued  equals ., .
.   arbitrary point ., . . .   boundary  ., .,  holds .
. . .  . . ., .
. . .  . . .
proof. .   easy consequence   construction.
  discs .  . namely,  ., . contains.
two distinct solutions  .,    differ .
 least one coordinate. thus, one   discs .
 .  contain two roots  .  . since.
 discs  isolating   root   corresponding.
resultant polynomial,  follows  ., . contains.
  one solution.   case,  ., .
contains  solution  .,  solution must .
real since, otherwise, ., .  also contain .
corresponding complex conjugate solution .   .
real valued coefficients. . follows directly  .
definition  ., .,  definition  ., .
 lemma . .
 denote ., . . . . . .  candidate.
box   real solution  .,  .  . .
real roots  .  ., respectively. due .
theorem .,  corresponding .container polydisc.
., . . . either contains  solution  .
 ., .    solution contained  ., .
hence,   candidate pair ., . . ,  suffices .
show  either ., .   solution  .  .
corresponding polydisc ., . contains  least one.
solution.   following steps,  fix  polydiscs.
., . whereas  boxes ., .   refined.
.  refining  isolating intervals . .
.  also introduce exclusion  inclusion predicates  ,  sufficiently small ., ., either.
., .   discarded  certified   solution  .
 order  exclude  candidate box,  use simple interval arithmetic.  precisely,  evaluate.
., .  ., .,  .  . constitute box functions    , respectively.  either.
., .  ., .   contain zero, .
., .    solution  . vice versa,  ., .
   solution  ., . becomes sufficiently small,.
 either . . ., .  . . ., . .
 exclusion predicate applies.
 remains  provide  inclusion predicate,  ,.
 method  ensure   certain candidate ., . . .
 actually  solution  .  first rewrite .
resultant polynomial . .
. . ., . . ., . . ., . . ., .,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 ., . . ., .,    expressed .
determinants  .sylvester-like. matrices.
 .   .  obtained  ., .  replacing  last column  vectors .yny. . . . . . . . . .
 . . . . . ymy. . . . .  appropriate size, respectively ., . .  matrices  size . .
. . .  univariate polynomials   . first.
 . . . columns.  powers   .  last column.  zeros  entries.  now aim  upper bounds.
 .  .   polydisc ., .  polynomials .  .  huge coefficients  .
computation, either via  signed remainder sequence .
via determinant evaluation,   costly. hence,  directly derive  upper bounds   corresponding.
matrix representations without computing . .
. due  hadamard. bound, .  smaller .
 product   .-norms   column vectors .
 .  absolute value     entries   .
  easily upper bounded  using interval arithmetic   box  .  contains  polydisc ., .
hence,  get  upper bound   .norm  .
column vector , thus,  upper bound ., ., .
 .  ., .  multiplying  bounds  .
column vectors.    manner,  also derive .
upper bound ., ., .  .  ., . .
respect   second projection direction,  write.
. . . .  . . .   corresponding polynomials ., . . ., .  exactly   manner .
done  .,  compute corresponding upper bounds.
., ., .  ., ., .  .  . .
., .
theorem .   exists  ., . . ., .
.
.
., ., . . ., . .
., ., . . ., . . .
.
., ., . . ., . .
., ., . . ., . . .,.
 ., . contains  solution  . , thus,.
., . . .
proof.  proof uses  homotopy argument. namely,.
 consider  parameterized system.
.
., . . . . ., . .
., . . . . ., . . .,.
    arbitrary real value  ., .   . .,.
.  equivalent   initial system .   . .,.
.   solution  ., ., namely, ., . .
complex solutions  . continuously depend  .
parameter . hence,  exists  .solution path.
. . ., . . .  connects . . ., . .
 solution . . .  .  show  .
  leave  polydisc ., . , thus, .
  solution  ., . assume   path .
leaves  polydisc,   exists  . . ., . .
., . . . . ., .  assume  . . .
. case . . .  treated  analogous manner.
since ., .   solution  .   . .,  must.
 ., . . ., .  ., . . ., .
hence,  follows .
. . ., ., . . ., ., .
. ., . . ., .
., . . ., .
. ., ., . . ., .
., ., . . ., .
. .
 contradicts  fact  .  lower.
bounded  .  follows  ., . contains.
 solution  . , according  theorem ., .
solution must  ., . .
theorem . now directly applies   inclusion.
predicate. namely,   refinement  ., ., .
choose  arbitrary ., . . ., . .,  center.
.,.   candidate box ., .  check.
whether  inequalities .  .  fulfilled.
 ., .   solution  .,   inequalities.
eventually hold , thus,   shown  ., . .
 solution.
 remark   upper bounds ., ., .,.
., ., ., ., ., .  ., ., .  far.
  optimal. nevertheless,  inclusion predicate  still efficient since   approximate  potential solution ., .  quadratic convergence due.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 qir. hence,  values ., .  ., . become  small    iterations.  order .
improve   upper bounds,  propose  consider  sophisticated methods  numerical analysis  matrix perturbation theory ., . finally,.
  like  emphasize   method applies.
particularly well   situation     interested   solutions  . within  given box.
 . .,. . .,. . . though . . capture.
 .real  complex. projections   solutions  .
system,     search  real ones contained.
within  interval .,. .,. ,  candidate.
boxes within     considered  separate .
validate. since  computation   resultants .
relatively cheap due   fast implementation  .
gpu  method  particularly well suited  search.
 local solutions.
. speedups.
. resultants  graphics hardware computing  resultants  bivariate polynomials   important .symbolic part.   algorithm. despite  large.
body  research existing   subject, symbolic computations still constitute  large bottleneck  many algorithms  substantially limit  range  applicability.  use  novel approach exploiting  power.
 gpus  dramatically reduce  time  computing resultants.   section,  briefly discuss .
algorithm.  refer  reader  ., .  details.
 approach  based   classical .divideconquer-combine. modular algorithm  collins .
 algorithm   summarized   following steps.
. apply modular  evaluation homomorphisms .
map  problem  computing  large set  problems.
  simple domain. . compute  set  resultants.
  prime field. . recover  resultant .
polynomial interpolation  chinese remaindering.
unfortunately, collins. algorithm   original.
form   suitable   realization   gpu.
    amount  parallelism exposed  .
modular algorithm  still  low  satisfy  needs .
 massively-threaded architecture.  overcome .
limitation  reduce  problem  computations .
structured matrices  matrix operations typically.
map  well   gpu. threading model.  .
problem  expressed  terms  linear algebra,  data.
dependencies  usually made explicit .though  .
cost   additional work. allowing  fine-grained.
parallelism    key ingredient  implementing.
 gpu algorithm.
  result,  steps   algorithm except  initial modular reduction  partly  chinese remaindering  run   graphics hardware, thereby minimizing  amount  work   done   cpu. .
expository purposes,  outline   computation.
 univariate resultants   detail.
suppose,     polynomials  .  degrees.
  , respectively.   clear   resultant.
    reduces   triangular factorization .
 sylvester matrix  .see section .  matrix.
 . . . .  . .  structured   satisfies .
displacement equation .
 . zrsat . gbt ,.
  .  .   , . .,   . .
  down-shift matrix zeroed everywhere except  .
  first subdiagonal. accordingly,  generators.
,  matrices whose entries   deduced .
 matrix   inspection. hence,   apply.
 generalized schur algorithm  operates  .
matrix generators  compute  matrix factorization.
 . time. see ., . .
 short,  schur algorithm   iterative procedure.   step,  brings  matrix generators  .
.special form.   triangular factors  easily.
 deduced based   displacement equation. using.
division-free modifications  procedure   performed   finite field giving rise   factorization.
algorithm running  . time using  processors.
although,  theoretical background   algorithm  well-established,    say much .
 realization.  give  basic idea, observe ,.
  two levels  parallelism available   graphics processor. block-level parallelism allows numerous thread blocks  execute concurrently without .
explicit communication . synchronization. .
.   turn, threads    block  also.
executed  parallel   communicate using synchronization barriers  shared memory.  latter.
one  referred   thread-level parallelism. suppose.
   applied modular  evaluation homomorphisms  reduce  problem  computing  univariate resultants     moduli. hence,  .
launch  grid   . thread blocks   individual block computes one univariate resultant using.
 schur algorithm .  pseudocode  .sequential. algorithm   found  ., section .
now, exploiting thread-level parallelism,  assign one.
thread  one row     generator matrices, .
,  four elements . , . .   iteration, one thread updates  associated generator rows.
.multiplies   . . transformation matrix. .
explains  basic routine   algorithm.
.remark ,  algorithm described  ., . compute resultants  bivariate polynomials, however dealing  univariate.
polynomials constitutes  .basic building block.   algorithm.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
  important  understand     number.
 factors governing  performance   gpu algorithm. ,  instance, include. thread occupancy,.
shared memory usage, register pressure, synchronization overhead,   concrete realization   modular.
arithmetic   gpu.  topics  covered  .
papers cited .
  univariate resultants .   modulus.
   evaluation point  .    computed,  interpolate  resultant polynomial .
  prime field   eventually lift  via chinese remaindering  obtain  integer solution.  steps.
 also executed .partly.   gpu.  remark .
polynomial interpolation corresponds  solving  vandermonde system. , exploiting  structure .
vandermonde matrix   use  schur algorithm .
solve  system   small parallel time.
. filters besides  parallel resultant computation,  algorithm elaborates  number  filtering techniques  early validate  majority   candidates.
 first step,  group candidates along  .
vertical line . fiber.   x-coordinate . . root .
.  process  together.  allows   use.
extra information   real roots  ., . . . .
., . . .  candidate validation.  replace .
tests based  interval evaluation .see page .   test.
based   bitstream descartes isolator . .bdc .
short.  method allows   isolate  real.
roots   polynomial  .bitstream. coefficients, .
, coefficients    approximated  arbitrary.
precision. bdc starts   interval guaranteed .
contain  real roots   polynomial,  proceeds .
interval subdivisions giving rise   subdivision tree.
accordingly,  approximation precision  coefficients.
 increased   step   algorithm.  leaf.
  tree  associated   interval  stores.
 upper   lower bound   number  real.
roots within  interval based  descartes. rule .
signs.  interval    subdivided  .
bounds equal .,   interval  discarded,  .,.
   found  isolating interval. isolating.
intervals   refined  arbitrary precision. .
remark  bdc terminates   real roots  simple.
otherwise, intervals  contain  multiple root .
 refined  never certified  contain  root.
  algorithm,  apply bdc   polynomials.
., .  ., . eventually, intervals   .
share  common root   polynomials will .
.    concerned   fact  vandemonde.
systems  notoriously ill-conditioned since  operations .
performed   finite field.
discarded.  property  essential   .filtered.
algorithm.  candidate box ., .   rejected .
soon   associated y-interval .   overlap.
  least one   isolating intervals associated.
 ., .  ., . see figure . .
grouping candidates along  fiber  . . also.
enables   use combinatorial tests  discard .
 certify . first,   number  certified.
solutions reaches mult.,  remaining candidates.
 automatically discarded   real solution.
contributes  least   . multiplicity   root.
 . . theorem . second,  .    root.
  greatest common divisor .   leading.
coefficients      mult.  odd   except.
one candidate along  fiber  discarded,  .
remaining candidate must   real solution.  .
 complex roots come  conjugate pairs ,.
thus,   change  parity  mult.  remark.
,  case   system .   generic position.
  multiplicities   roots    odd, .
combinatorial test already suffices  certify  solutions.
without  need  apply  inclusion predicate .
section .
now, suppose ,   combinatorial test,.
  several candidates left along  fiber.  instance,  latter  indicate  presence  covertical.
solutions.   case,  using  inclusion predicate,   apply  aforementioned filters  horizontal direction.  precisely,  construct  lists .
unvalidated candidates sharing   y-coordinate.
.  process  along  horizontal fiber.  .
step,  initialize  bitstream trees  ., . .
., .  proceed  exactly   way  done .
vertical fibers. see figure . . candidates  still.
remain undecided   tests  processed  considering  inclusion predicate.  section .,  .
next examine  efficiency   filters,  will refer.
  procedure   bidirectional filter.
. implementation . experiments.
  implemented  algorithm   prototypical.
package  cgal.  throughout  library  follow.
 generic programming paradigm ,  instance,.
enables   easily exchange  number types used .
 method  isolate  roots   polynomial without.
altering  main structure   implementation.
  experiments,   used  number types.
provided  gmp .  fast polynomial gcd .
ntl . library.  experiments   run .
.ghz .-core intel xeonw.  .   . cache.
.computational geometry algorithms library, www.cgal.org.
.gmp. http.gmplib.org, ntl. http.www.shoup.net.ntl.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. .
. .
.,.
.,.
.,.
.
.
.
.
.,.
figure . . intervals containing  roots  ., .  ., .  refined   either   overlap  .
fully included  candidate boxes.   former case,  boxes   discarded. . unvalidated candidates .
passed  bidirectional filter  runs bitstream isolation  another direcion.
 linux platform.   gpu-part   algorithm,   used  geforce gtx. graphics.
processor .fermi core.  compared  approach .
 bivariate version  isolate .based    fabrice rouillier.  lgp  xiao-shan gao  . .
  interfaced using maple .  remark ,.
  important substep  isolating  real roots .
 elimination polynomial,  three contestants .including  implementation. use  highly efficient implementation provided  .
 tests consist  two parts.   first part,.
 consider .special. curves .  derivative .
y-variable. selected   aim  challenging different.
parts   algorithm  showing  efficiency .
 filtering techniques given  section . .
curves,  instance,  many singularities  highcurvature points  requires many candidates  .
tested along  vertical line,  prohibit  use .
special filters. descriptions   considered curves .
corresponding timings  listed  table .  table .,.
respectively.   second part   experiments,.
 study  performance   bisolve  random.
polynomials  increasing total degrees  coefficient.
bit-lengths.  refer  reader  table .  .
corresponding timings.
 columns .  table .,  experiments.
  algorithm  given   filters set .
.allfilters.,  bitstream  combinatorial.
filter .bstr.comb.,  bitstream filter .
.bstr.    filters set  .  bisolve,  report timings respectively   without.
gpu resultant algorithm.   remaining configurations  show   timings using gpu resultants.
. http.www.loria.equipes.vegas.
.lgp. http.www.mmrc.iss.xgao.software.html.
cpu-based timings  easly  obtained  taking .
difference  bisolve-columns.
one  observe   algorithm  generally.
superior  isolate  lgp even   filters .
 used.  comparing columns .  table ., one.
 see  filtering sometimes results   significant.
performance improvement.  combinatorial test.
 particularly useful   defining polynomials.
  system .  large degrees . large.
coefficient bit-length     time  number.
 covertical  singular solutions  small compared .
 total number  candidates  checked. .
bidirectional filter  advantageous   system .
covertical solutions  one direction .say along y-axis.
   cohorizontal.   essentially  case.
 challenge ., cov sol .  spider.
another strength   approach relates   fact.
  amount  symbolic operations  crucially reduced. hence,   time  computing resultants .
dominating,  gpu-based algorithm offers  speed-up.
  factor  .   version  default resultant implementation.   also worth mentioning .
 isolate  lgp benefit   fast resultant.
computation available  maple  cgal. default.
resultant computation.  generally much slower .
  maple.   result,    large discrepancy.
 columns .  .  bisolve.
table . lists timings  experiments  random.
curves.  instance consists  five curves   .
degree .  ., dense  sparse.   report .
average time  compute  solutions  one  .
ten pairs  curves.  order  analyze  influence .
 coefficients. bit-lengths,  multiplied  curve .
.authors  indebted  cgal developers working  resultants.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
instance description.
. circles circles . .-norm, clustered solutions.
curve issac  curve appeared  .
tryme covertical solutions, many candidates  check.
large curves large number  solutions.
degree . surf silhouette   algebraic surface, covertical solutions   directions.
challenge . many candidate solutions   checked.
 . . eps. singular points  high tangencies, displaced.
ftt . . . many non-rational singularities.
dfold . .  curve  many half-branches.
cov sol . covertical solutions.
mignotte   product  . mignotte polynomials, displaced. many clustered solutions.
spider degenerate curve, many clustered solutions.
hard one vertical lines  component  one curve, many candidates  test.
grid deg . large coefficients, curve  generic position.
huge cusp large coefficients, high-curvature points.
cusps  flexes high-curvature points.
. circles . circles . .-norm, clustered solutions.
ten circles set  . random circles multiplied together, rational solutions.
curve. curvature  degree . curve, many singularities.
compact surf silhouette   algebraic surface, many singularities, isolated solutions.
. sings . large coefficients, high-curvature points.
swinnerston dyer covertical solutions   directions.
challenge . . many candidate solutions   checked.
 . . eps. singular points  high tangencies, displaced.
spiral. . taylor expansion   spiral intersecting  curve  many branches, many candidates  check.
table . description   curves used   first part  experiments.  case   single curve given,  second.
curve  taken    first derivative . y-variable. curves marked   star .  given  .
.   . ., ., .  increased  constant.
coefficient  one. since  latter operation constitutes.
  small perturbation   vanishing set  .
input system,  number  solutions remains constant.
  content   polynomials. coefficients also.
stays trivial.  see   bidirectional filtering.
    advantage   system defined.
 random polynomials  unlikely   covertical.
solutions. however,   case,  candidates .
rejected   combinatorial check, thereby omitting.
.  expensive. test based  theorem . .
results   clear speed-up   .non-filtered. version.
also, observe  gpu-bisolve   vulnerable.
 increasing  bit-length  coefficients  .
becomes critical  isolate.  lgp. performance.
  also observed ,   filtered versions, .
time   validation step  almost independent  .
bit-lengths.
 omit experiments  refine  solution boxes .
certain precision   matches  efficiency  qir.
due   fact    algebraic descriptions .
 solutions.   y-coordinates.
 defining polynomials  archived online.
 http.www.mpi-inf.mpg.departments.
projects.geometry.bisolvedatasetalenex.
zip.
. summary  outlook.
 propose  exact  complete method  isolate .
real solutions   bivariate polynomial system. .
algorithm  designed  reduce  number  purely.
symbolic operations  much  possible. eventually,.
 resultant  gcd computation  still needed. .
transferring  resultant computation   gpu, .
 able  remove  major bottleneck  elimination approaches.  order   improve  implementation,  aim  outsource  square-free factorization.
  gpu  well,  step  seems   feasible since factorization  also well suited   .divideconquer-combine. modular approach. since  initial.
motivation   speed   topology  arrangement computation  algebraic curves  surfaces, .
plan  extend  method towards  direction. another promising algorithm   recently proposed.
 fabrice rouillier  .   based  computing.
rational univariate representations  means  computing  subresultant sequence.  expect  implementation   available soon  aim   comparison .
 approach. furthermore,    interesting .
extend  algorithm  handle higher dimensional systable . experiments   curves listed  table . execution times   seconds, including resultant computations.
bisolve-gpu.  approach  gpu-resultants. bisolve-cpu.  approach  cgal. cpu-resultants.
isolate  lgp use maple. implementation   resultant computation. bold face indicates default setup.
 bisolve  .timeout.  running time . . sec.
tems  complex solutions. finally,   like .
investigate  hybrid methods    combination.
  numerical complex root solver   exact post.
certification method serving   additional filter .
 validation step .  spirit  ., .  .
convinced     candidate boxes  .
treated even  efficiently   use   methods.
 claim , eventually,  total costs  solving .
bivariate system    dominated   .
 root isolation step   elimination polynomial.
 many instances,  experiments already hint .
 latter claim.  aim   improve  implementation  show  behavior   instances  .
provide  proof  terms  complexity  well.
acknowledgments.
 thank michael kerber   anonymous reviewers.
  constructive  detailed criticism  .
helped  improve  quality  exposition  .
contribution.
</doc>
<doc title='alx11_05_blellochg.txt'>
 simple parallel cartesian tree algorithm.
  application  suffix tree construction .
guy . blelloch. julian shun.
abstract.
 present  simple linear work  space,  polylogarithmic time parallel algorithm  generating multiway cartesian trees.   special case,  algorithm.
  used  generate suffix trees  suffix arrays .
arbitrary alphabets    bounds.  conjunction.
 parallel suffix array algorithms,    skew.
algorithm,  gives  rather simple linear work parallel algorithm  generating suffix trees   integer.
alphabet . . ., . . . , .,     length   input string.  generally, given  sorted sequences .
strings   longest common prefix lengths .
adjacent elements,  algorithm will generate  pat tree.
.compacted trie.   strings.
 also present experimental results comparing.
 performance   algorithm  existing sequential.
implementations   second parallel algorithm. .
present comparisons   cartesian tree algorithm.
     constructing  suffix tree using .
algorithm.  results show    variety  strings.
 algorithm  competitive   sequential version.
  single processor  achieves good speedup .
multiple processors.
. introduction.
  string   length    character set . .
., . . . , .  suffix-tree data structure stores  .
suffixes     pat tree . trie   maximal branch.
free paths  contracted   single edge.  addition  supporting searches     string  . .
 . expected time., suffix trees efficiently support many  operations  strings,   longest.
common substring, maximal repeats, longest repeated.
substrings,  longest palindrome, among many others .gus.     one    important.
. work  supported  generous gifts  intel, microsoft  ibm,    national science foundation .
award ccf.
.carnegie mellon university, e-mail. guyb.cmu.edu.
.carnegie mellon university, e-mail. jshun.cmu.edu.
. general alphabets   used  first sorting .
characters   labeling   .  .
.worst case time  constant sized alphabets.
data structures  string processing.  example, .
 used  several bioinformatic applications,  .
reputer ., mummer .dpcs., oasis .mpk.
 trellis. .  suffix trees   linear.
time algorithm  constructing   introduced.
 weiner .wei. .although  used  term position tree. since  various similar constructions .
 described .mcc.     many implementations   algorithms. although originally.
designed  fixed-sized alphabets  deterministic linear time, weiner. algorithm  work   alphabet.
., . . . , ., henceforth .,  linear expected time simply  using hashing  access  children   node.
 algorithm  weiner   derivatives  .
incremental  inherently sequential.  first parallel algorithm  suffix trees  given  apostolico .
. .ail.   based   quite different doubling.
approach.   parameter . . . . .  algorithm.
runs  . . log . time, .
.
. log . work  .
.
space   crcw pram  arbitrary alphabets.
although reasonably simple,  algorithm  likely .
practical since    work efficient  uses superlinear memory .  polynomial factor.  parallel.
construction  suffix trees  later improved  linear.
work  space  hariharan .har.,   algorithm.
taking .log. . time   crew pram,  .
 farach  muthukrishnan  .log . time using.
 randomized crcw pram . .high-probability.
bounds.  later results    constant-sized alphabet,  .considerably non-trivial.,    seem.
  amenable  efficient implementations.
one way  construct  suffix tree   first generate.
 suffix array . array  pointers   lexicographically sorted suffixes.,   convert    suffix.
tree.  binary alphabets  given  length  .
longest common prefix .lcp.  adjacent entries.
 conversion   done sequentially  generating.
 cartesian tree  linear time  space.  approach.
  generalized  arbitrary alphabets using multiway cartesian trees without much difficulty. using suffix arrays  attractive since  recent years  .
 considerable theoretical  practical advances .
 generation  suffix arrays .see . .pst. .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
interest  partly due   need   widely used.
burrows-wheeler compression algorithm,  also  .
 space-efficient alternative  suffix trees.  .
   dozens  papers  efficient implementations  suffix arrays. among  karkkainen .
sanders  developed  quite simple  efficient parallel algorithm  suffix arrays ., .  .
also generate lcps.
 story  generating cartesian trees  parallel  less satisfactory. berkman .  .bsv. describe.
 parallel algorithm    nearest smaller values.
.ansv. problem,    directly used  generate  binary cartesian tree  fixed sized alphabets.
however,   directly  used  non-constant.
sized alphabets,   algorithm   complicated.
iliopoulos  rytter . present two much simpler.
algorithms  generating suffix trees  suffix arrays,.
one based  merging  one based   variant .
 ansv problem  allows  multiway cartesian.
trees. however   require . log . work.
  paper  describe  linear work, linear space,.
 polylogarithmic time algorithm  generating multiway cartesian trees.  algorithm  based  divideand-conquer   describe two versions  differ.
 whether  merging step  done sequentially .
 parallel.  first based   sequential merge,.
  simple,    tree  height ,  runs .
.min. log , . time   crew pram.  second version   slightly  complicated  runs.
 .log. . time   crew pram.   use.
linear work  space.
given  linear work  space algorithm .
generating  suffix array  corresponding lcps using.
. time  results lead   linear work  space.
algorithm  generating suffix trees  . log. .
time.  example using  skew algorithm . .
 crcw pram   .log. . time  constantsized alphabets  ., . . . . . time  .
alphabet .  note   polylogarithmic time,.
linear work  linear space algorithm   alphabet.
.  imply stable radix sort  .   .
bounds,    long open problem.
 comparison  also present  technique  using.
 ansv problem  generate multiway cartesian.
trees  arbitrary alphabets  linear work  space.
 algorithm runs  . . log . time  .
crcw pram,  .   best time bound  .
linear-work stable sorting  integers  .  .
show   cartesian tree   used  generate .
ansv  linear work  polylogarithmic time.
  implemented  first version   algorithm  present various experimental results analyzing  algorithm   shared memory multicore parallel.
machine   variety  inputs. first,  compare .
cartesian tree algorithm   simple stack based sequential implementation.  one core  algorithm .
 . slower,   achieve  . speedup .
. cores   . speedup  . cores using hyperthreading .two threads per core.  also analyze.
 algorithm  used  part  code  generate .
suffix tree   original string.  compare  code.
  ansv based algorithm described   previous.
paragraph   existing sequential implementations.
 suffix trees.  algorithm  always faster  .
ansv algorithm.  algorithm  competitive .
 sequential code   single processor .core., .
achieves good speedup  . cores. finally,  present.
timings  searching multiple strings   suffix tree.
 generate.  times  always faster   sequential suffix tree  one core  always  .
. faster  . cores using hyperthreading.
. preliminaries.
given  string   length    ordered alphabet.
.,  suffix array, , represents   suffixes   .
lexicographically sorted order.   precise, . . .
     suffix starting   . position .
 appears   . position   suffix-sorted order.
 pat tree .mor. . patricia tree,  compacted trie.
  set  strings    modified trie   . edges.
  labeled   sequence  characters instead  .
single character, .  node   single child,  .
every string   corresponds  concatenation  labels.
  path   root   leaf. given  string  .
length ,  suffix tree   stores   suffixes  .
  pat tree.
  paper  assume  integer alphabet . . .
    total number  characters.  require.
  pat tree  suffix tree supports  following.
queries   node  constant expected time. finding.
 child edge based   first character   edge,.
finding  first child, finding  next  previous.
sibling   character order,  finding  parent.
  alphabet  constant sized   operations.
 easily  implemented  constant worst-case time.
 cartesian tree .vui.   sequence  elements.
taken   total order   binary tree  satisfies.
two properties. . heap order  values, .  node.
  equal  lesser value     descendants,.
 .  inorder traversal   tree defines .
sequence order.  elements   sequence  distinct.
  tree  unique, otherwise  might  .
 elements   distinct  refer   connected.
component  equal value nodes   cartesian tree .
 cluster.  multiway cartesian tree  derived  .
cartesian tree  contracting  cluster   single.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
node  maintaining  order   children. .
multiway cartesian tree   sequence  always unique.
 lcp.,.   length   longest common prefix  .  . given  sorted sequence .
strings  . ., . . . , .,   string lengths  interleaved   length   longest common prefixes.
. ., lcp ., ., ., . . . , lcp ., ., .
 corresponding multiway cartesian tree  .
structure   pat tree  .  pat tree  .
generated  adding strings   edges,   easy.
 .   node  value  . lcp ., . .
parent  value .  edge corresponds   substring . . ., . . . , .   special case, interleaving.
 suffix array   lcps  generating  multiway cartesian tree gives  suffix tree structure. .
summary, beyond  trivial operations, generating.
 multiway cartesian tree  sufficient  converting .
suffix array  corresponding lcps   suffix tree.
  paper,  use  concurrent-read exclusivewrite parallel random access machine .pram. model.
  concurrent-read concurrent-write .crcw.
pram.   crcw pram,  use  model .
concurrent writes    location results   arbitrary processor succeeding.  analyze  algorithm.
  work-time framework   assume unlimited processors  count  number  time steps .
total number  operations. using brent.  scheduling principle,  implies  . . time bound using.
. processors,  long  processors   allocated.
efficiently .jaj.
. parallel cartesian trees.
 describe  work-efficient parallel divide-and-conquer.
algorithm  creating  cartesian tree.  algorithm.
works recursively  splitting  input array  .
two, generating  cartesian tree   subarray,.
  merging  results   cartesian tree .
.  define  right-spine .left-spine.   tree .
consist   nodes   path   root  .
rightmost .leftmost. node   tree.  merge works.
 merging  right-spine   left tree   leftspine   right tree based   value stored  .
node.  algorithm  similar   . log . work.
divide-and-conquer suffix array  suffix tree algorithm.
 iliopoulos  rytter .,    important.
difference    algorithm  looks   nodes.
  spines   deeper   deeper   two.
roots   fully parallel version uses trees instead.
 arrays  represent  spines.  leads  .
. work bound.  addition, iliopoulos  rytter.
algorithm works directly   suffix array rather .
solving  cartesian tree problem   specifics .
different.
 describe  partially parallel version  .
algorithm .algorithm .   fully parallel version.
.algorithm . algorithm .   simple,  takes.
  .min. log , . time,     depth .
 resulting tree, although   inputs  takes.
significantly less time .   sequence ., ., . . . , .
 takes .log . time even though  resulting tree.
 depth .  algorithm  needs  maintain.
parent pointers   nodes   cartesian tree. .
complete  code  provided  figure .  line numbers.
  will  referenced throughout  description.
 algorithm takes  input  array   elements.
.nodes.  recursively splits  array  two halves.
.lines ., creates  cartesian tree   half, .
 merges    single cartesian tree .line .
  merge .lines .,  combine  right spine.
  left subtree   left spine   right subtree.
.see figure .  right .left. spine   left .right.
subtree   accessed  following parent pointers.
  rightmost .leftmost. node   left .right.
subtree.  leftmost  rightmost nodes   tree.
 simply  first  last elements   input array.
 nodes.  note    merge reaches .
deeper   two roots  stops  needs  process.
 remaining nodes    spine.  code .
figure .   keep child pointers since  .
need    experiments,    easy  add .
left  right child pointer  maintain .
theorem . algorithm . produces  cartesian tree.
  input array.
proof.  show   every step   algorithm,.
  heap   inorder properties   cartesian trees  maintained.   base case,  cartesian.
tree  one node trivially satisfies  two properties.
  merge,  heap property  maintained   node. parent pointer  changes  point  .
node  equal  lesser value. consider modifications.
  left tree.   right children   right spine.
  changed. therefore  descendants   right.
tree will correctly appear    inorder traversal.
similarly    direction  left tree descendants.
  right tree node will correctly appear   .
inorder traversal. furthermore  order within  .
 two trees  maintained since  node    descendant   right .left.   trees  merging.
remains  descendant   right .left.   merge.
theorem . algorithm .  constructing  cartesian tree requires . work  . space  .
ram.
proof.  use  following definitions  help .
proving  complexity bounds   algorithm.  node.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. struct node . node. parent . int value . . .
.
. void merge . node.     , node.      . .
. node. head .
.   .     .value .   ght.value . .
. head .     .     .     .parent .
. else .head .      .     .  ight.parent .
.
.  . . .
.   .     . null. .head.parent .      . break .
.   .      . null. .head.parent .     . break .
.   .     .value .   ght.value . .
. head.parent .     .     .     .parent .
. else .head.parent .      .      .  ight.parent .
. head . head.parent .
.
. void       antree . node. nodes , int . .
.   . . . return .
.    spawn       antree . nodes ,  . . . .
.       antree . nodes. ,. . . . .
.         .
. merge . nodes.,nodes. . . . .
figure .  code  algorithm .  cilk spawn  cilk sync declarations  part   cilk. parallel.
extensions .int.  allow  two recursive calls  run  parallel.
  tree  left-protected     appear  .
left spine   tree,   node  right-protected  .
  appear   right spine   tree.  node .
protected     left-protected  right-protected.
  algorithm,   node becomes protected, .
will always  protected  will never    looked.
  since  algorithm always  processes .
left  right spines   tree.  show  .
 merge,   two   nodes   looked .
become protected,   charge  cost  processing.
 two nodes   merge . call  last node.
looked    right spine   left tree lastnodeleft.
  last node looked    left spine   right.
tree lastnoderight .see figure .
 nodes   looked , except  lastnodeleft  lastnoderight will  left-protected .
lastnodeleft.     nodes become either descendants   right child  lastnodeleft .
lastnodeleft   lastnoderight.  descendants.
 lastnoderight . lastnoderight   lastnodeleft.  symmetric argument holds  nodes .
right-protected. therefore,  nodes looked , except.
 lastnodeleft  lastnoderight, become protected.
  sequence  operations.  charge  cost .
processing lastnodeleft  lastnoderight   merge.
.
    node appears  lastnoderight.
 lastnodeleft    looked    .
becomes protected. therefore  total number  nodes.
looked   .   lastnoderight  lastnodeleft .
  . . merges,       nodes .
become protected   total work  . since .
node  maintains  constant amount  data, .
space required  .
note  although algorithm . makes parallel.
recursive calls  uses  sequential merge routine. .
 worst case   take time equal   depth .
 tree.  now describe  fully parallel variant, .
 refer   algorithm .  algorithm maintains.
binary search trees   spine,  substitutes .
sequential merge   parallel merge.  will use split.
 join operations   spines.  split goes  .
spine tree  cuts    specified value    .
values less  equal     one tree  values greater.
    another tree.  join takes two trees .
  values   second  greater  equal  .
largest value   first  joins   one. .
 run  time proportional   depth   spine.
tree   join adds   one   height  .
larger two trees.
without loss  generality, assume   root .
 right cartesian tree   smaller value  .
root   left cartesian tree .  figure .  .
left tree,  end point   merge will   root.
 find   stop merging   right tree, .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
figure . merging two spines. thick lines represent  spines   resulting tree. dashed lines represent edges.
 existed   merge     merge. dotted edges represent  arbitrary number  nodes. .
non-dashed lines represent edges   resulting tree.
algorithm searches  left-spine   right tree  .
root value   left tree  splits  spine  .
point. now  merges  whole right-spine   left.
tree   deeper portion   left-spine   right.
tree.   merge  two parts   spine .
 thrown  since  nodes  become protected.
finally  algorithm joins  shallower portion  .
left spine   right tree   left spine   left.
tree  form  new left spine.  right-spine  .
resulting cartesian tree        right.
cartesian tree   merge.
theorem . algorithm .  constructing  cartesian tree requires . work, .log. . time,  .
space   crew pram.
proof.  trees used  represent  spines  never.
deeper  .log . since  merge   one.
join,  adds  one node   depth.  splits.
 joints therefore take .log . time.  merge.
  done using  parallel merging algorithm .
runs  .log . time  . work   crew.
pram .jaj.,     number  elements.
 merged.  depth  algorithm . recursion.
 .log .,  gives  .log. . time bound. .
. work bound follows   similar analysis  .
  sequential version,   exception  splits.
 joins   spine cost  extra .log . per merge,.
    recurrence  . . . . . .log .,.
 solves  .  trees   spines take.
linear space   . space bound follows. processor.
allocation  straightforward due   .log . time.
  merges.
lemma .  output  algorithm .   used.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 construct  multiway cartesian tree  . work .
 ram. algorithm .  perform   task .
. work  .log . time   erew pram.
proof.  algorithm .,    done using path.
compression  compress  clusters    value.
  root   cluster,     used.
  .representative.   cluster.  parent.
pointers  nodes   cluster will now point  .
.representative.   cluster.  takes linear work.
 algorithm ., substitute path compression .
 parallel tree contraction algorithm. parallel tree.
contraction   done  . work  .log . time.
  erew pram .jaj.
 non-constant sized alphabets   want .
search   tree efficiently . expected time per.
edge.  edges need   inserted   hash table,.
   done ino.log . time ando. work .
.   randomized crcw pram.
corollary . given  suffix array   string .
 alphabet .   lcps  adjacent elements,  suffix tree   generated  hash-table format.
using algorithm ., tree contraction,  hash table insertion,  . work, .log. . time,  . space.
  randomized crcw pram.
proof. follows directly.
. cartesian trees   ansv problem.
  nearest smaller values .ansv. problem .
defined  follows.   element   sequence.
 numbers, find  closest smaller element  .
left     closest smaller element   right.
 .   augment  ansv based cartesian.
tree algorithm  berkman .  .bsv.  support.
multiway cartesian trees,  also show   use.
cartesian trees  solve  ansv problem.
berkman . . algorithm solves  ansv.
problem  . work  .log logn. time  .
crcw pram.  ansv    used  generate.
 cartesian tree  noting   parent   node.
    nearest smaller value  one   two.
directions . particular  larger   two nearest.
smaller values   parent.  convert  cartesian.
tree   multiway cartesian tree, one needs  group.
 nodes pointing    parent  coming .
  direction together.  .   best time.
bound  stably sorting integers  . using linear.
space  work,  grouping   done  linear work.
 . . log log . time  sorting   parent .
numbers   nodes. stability  important since .
need  maintain  relative order among  children.
  node.
theorem .  multiway cartesian tree   array.
 elements   generated  . work  space.
 . . log log . time   crcw pram.
proof.  follows   bounds   ansv.
algorithm   integer sorting.
   currently know whether .  polylogarithmic   present  result seems weaker  .
result   previous section.   experimental.
section  compare  algorithms experimentally. .
related work iliopoulos  rytter . present .
. log . work polylogarithmic time algorithm based.
  variant  ansv.
 now describe  method  obtaining  ansvs.
  cartesian tree  parallel using tree contraction.
note    node   cartesian tree  .
 nearest smaller neighbors .   . must .
  path   node   root .one neighbor .
trivially  node. parent.  first present  simple.
linear-work algorithm   task  takes time equal.
  depth   cartesian tree.   denote .
depth   tree,   root   depth . .
following algorithm returns  left nearest neighbors.
  nodes.  symmetric algorithm returns  right.
nearest neighbors.
 every node, maintain two variables, node.index.
  set   node. index   sequence corresponding   inorder traversal   cartesian.
tree  never changed,  node.inherited, .
 initialized  null.
  level    tree  .  .
 parallel,   nodes  level . pass.
node.inherited   left child  node.index.
  right child.  child stores  passed.
value   inherited variable.
  nodes  parallel.  node.inherited . null, .
node.inherited denotes  index   node. left.
smaller neighbor. otherwise      left.
smaller neighbor.
 now present  linear-work  .log . time.
parallel algorithm   task based  tree contraction .jaj.  find  left neighbors,  describe.
  decompress  tree several configurations .
rake  compress operations,   rest   configurations   symmetric argument.  compress,.
   left-left  right-left configurations. .
 left-left configuration,  compressed node takes.
 inherited value   parent.   right-left configuration,  compressed node takes  index value.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
  parent.  raking  left leaf,  raked leaf takes.
 inherited value   parent,   raking  right.
leaf,  raked leaf takes  index value   parent.
  find  right neighbors  symmetry.
. experiments.
 goal   experiments   analyze  effectiveness   cartesian tree algorithm     .
also  part  code  generate suffix trees.  compare.
 algorithm   ansv-based algorithm   .
best available sequential code  suffix trees.  feel.
  important  compare  parallel algorithm .
existing sequential implementations  make sure .
  algorithm  significantly outperform existing.
sequential ones even   modest number  processors.
.cores. available  current desktop machines.  .
discussion  refer   two variants   main algorithm .section .  algorithm .  algorithm .,.
   ansv-based algorithm  algorithm . .
 experiments,  addition  implementing algorithm.
.   variant  algorithm .,  implemented parallel code  suffix arrays   corresponding lcps,.
 parallel code  inserting  tree nodes   hash.
table  allow  efficient search.  ran  experiments   .-core parallel machine using  variety .
real-world  artificial strings.
. auxiliary code.  generate  suffix array.
 lcp  implemented  parallel version  .
skew algorithm .  implementation uses .
parallel bucket sort .jaj., requiring . work .
. time   constant  . .  lcp.
code  based   . log . solution   range.
minima problem instead   optimal .  .
implement  parallel version   linear-time rangeminima algorithm  .,  found   .
slower. due  better locality   parallel radix sort.
  sequential one,  code   single core .
actually faster   version  . implemented .
 paper  available online, even though  version.
  implement  lcp.  get   .  .
fold speedup   .-core machine. compared  .
parallel implementation  suffix arrays  kulla .
sanders .,  times  faster  . cores .
 . core numbers reported   . seconds.
 . seconds  . million characters., although.
 clock speed  . slower     .
 different system    hard  compare directly.
mori provides  parallel suffix array implementation.
using openmp .mor.,   found    slower.
  corresponding sequential implementation,.
even  using . cores.  parallel implementation.
significantly outperforms   mori.   .
 two existing parallel implementations  suffix.
arrays    aware .
 note  recent sequential suffix array codes .
faster   running  one core .pst., mor.,.
mor.,       compute  lcps.
 real-world texts,  programs  faster  .
code   factor   .  .   due .
many optimizations  codes make.  expect many.
  optimizations   parallelized  .
significantly improve  performance  parallel suffix.
array construction,      purpose  .
studies. one advantage  basing suffix tree code .
suffix array code, however,   improvements made.
 parallel suffix arrays  improve  performance.
  suffix tree code.
 use  parallel hash table  allow  fast search.
  suffix tree.  hash-table uses  compare.
 swap  concurrent insertion. furthermore .
optimized  code    entries near leafs .
 tree   inserted   hash table   linear.
search  used instead.  particular since  cartesian.
tree code stores  tree nodes   in-order traversal.
  suffixes   suffix tree,  child  parent near.
 leaf   likely   near     array.
  code   child  within  constant  . .
 experiments.   array    store   .
hash table  use  linear search.
 algorithm .,  implemented  . log .
work  .log . time ansv algorithm  .bsv.
instead   much  complicated work optimal.
version. however,  used  optimization  makes.
 run significantly faster  practice.  particular,.
using  doubling search,  left query  location .
runs  time .log. .  . .     resulting.
nearest lesser value   . max. . ., . . . , . .
. . .,  symmetrically  right queries.
. experimental setup.  performed experiments   .-core . hyper-threading. dell poweredge .  . . .ghz intel .-core . nehalem processors,  .mhz bus,  .  main.
memory.  parallel programs  compiled using .
cilk. compiler .build .   . flag.  sequential programs  compiled using . . .
 . flag.
 comparison  sequential suffix tree code .
used tsadok.  yona. . code  kurtz. code.
  mummer project .dpcs., kur. .http.
.mummer.sourceforge.net.,    publicly available.   list  results  kurtz    superior    .   .
 test files. kurtz. code  based  mccreight.
suffix tree construction algorithm .mcc.  inhercopyright . .  siam .
unauthorized reproduction  prohibited.
.
ently sequential  completely different   algorithms.  researchers  experimented .
building suffix trees  parallel .,  due  difficulty  obtaining  source code,    .
results   implementation. however,  running.
times appear significantly faster   reported .
 corresponding papers, even  accounting  differences  machine specifications.
 running  experiments  used  variety .
strings available online .http.people.unipmn.
manzini.lightweight.corpus.,  microsoft word.
document .thesaurus.doc., xml code  wikipedia.
samples .wikisamp.xml  wikisamp.xml.,  artificial inputs.  also included two files  integers, .mrandom-ints.,  random integers ranging  .  .,  .mrandom-intsimax,  random integers ranging  .  .,  show   algorithms run efficiently  arbitrary integer alphabets.
 present times  searching  random substrings   suffix trees  several texts constructed.
using  code  kurtz. code.  also report.
times  searches using myer  manber. suffix array.
code .  abouelhoda . show   code.
.mamy. performs searches  quickly  kurtz.
code .   text,  search .,. random.
substrings   text .    found. .
.,. random strings . will   found. .
lengths uniformly distributed  .  .  file.
etext. consists   etext. data  special characters removed .mamy   work  special characters.,   size  .  file .mrandom.
contains . random characters.
. cartesian trees.  experimentally compare.
 cartesian tree algorithm  algorithm .
  linear-time stack-based sequential algorithm.
 .gbt.   also  linear-time sequential algorithm based  ansvs,   verified   stackbased algorithm outperforms  ansv one   .
report times   former. figure . shows  running.
time . number  processors    algorithm.
  stack-based one  log-log scale.  parallel algorithm achieves nearly linear speedup  outperforms.
sequential algorithms  .   cores.
. suffix trees.  use algorithm .  . along.
  suffix array code  hash insertion  generate.
suffix trees  strings. table . presents  runtimes.
 generating  suffix tree based  algorithm .,.
 variant  algorithm .,  using kurtz. code.
  implementations based  algorithm .  .
 give  sequential .single thread. running times.
 parallel running times  . cores  hyperfigure . running times  cartesian tree algorithms.
 . random characters  .-core machine  loglog scale.  .-core time  actually .-cores using.
hyper-threading.
threading.  note   speedup ranges  .
 .,   worst speedup   string  equal.
characters. figure . shows runtime   function.
 number  cores  . million random characters.
.mrandom. compared  kurtz. code,  code.
running sequentially   . faster  .
slower.  parallel code, however,  always faster.
 kurtz. code    . faster. comparatively,.
kurtz. code performs best  strings  lots .
regularity .   identical string.   .
 incremental sequential algorithms based  weiner.
algorithm  particularly good   strings. .
runtime   code  affected much less   type.
 input string.
figures .  . show  breakdown   times .
 implementations  algorithm .  algorithm .
respectively  run  . cores  hyper-threading.
figure . shows  breakdown   time  generating.
 suffix array  lcp array.  algorithm . .
.   total time  spent  generating  suffix.
array,  .  inserting   hash table  less.
 .  generating  cartesian tree   suffix.
array .,  code shown  figure .  algorithm.
.  note   ansv  takes  .  .
total time even though    . log . algorithm.
  likely due   optimization discussed .
since    spend  lot  time optimizing .
suffix array  hash code,  expect  overall code.
performance   improved significantly. figure .
shows  running time  algorithm .  random.
table . comparison  running times .seconds.  mummer. sequential algorithm   algorithms  suffix.
tree construction  different inputs  .-core . hyper-threading. dell poweredge .  . . .ghz.
intel .-core . nehalem processors   .mhz bus.
character files  varying sizes.  note   running.
time  superlinear  relation   file size, .
hypothesize    due  memory effects. .
 implementation  algorithm .   truly parallel,.
  incredibly straightforward  performs better .
algorithm .
search times  reported  table . searches.
done   code   integers,   done .
kurtz. code  myer  manber. code  done.
 characters.  report  sequential  parallel.
search times   algorithm.  results show .
even sequentially,  code performs searches faster .
  two implementations .  code  likely.
 perform even better   modified   search .
characters instead  integers.
. space requirements. since suffix trees  often constructed  large texts . human genome., .
 important  keep  space requirements minimal.
 ,    related work  compactly representing suffix trees .ako., sad.  implementations  algorithm .  algorithm . use . integers.
per node .leaf  internal.   . bytes  .
hash table.  totals   . bytes.  compares   . bytes  kurtz. code,  .
 optimized  space .dpcs., kur.  leave.
 optimization  space   code  future work.
. conclusions.
  described  work-optimal parallel algorithm.
 .log. . time  constructing  cartesian tree.
  multiway cartesian tree.  using  algorithm,.
  able  transform  suffix array   suffix tree.
 linear work  .log. . time.  approach .
much simpler  previous approaches  generating.
suffix trees  parallel   handle arbitrary alphabets.  implemented   algorithm,  showed.
  achieves good speedup  outperforms existing.
suffix tree construction implementations  small scaled.
</doc>
<doc title='alx11_07_breslaul.txt'>
disjoint-path facility location. theory  practice.
lee breslau . ilias diakonikolas . nick duffield .   .
mohammadtaghi hajiaghayi . david . johnson . howard karloff .
mauricio . . resende . subhabrata sen .
abstract.
 paper   theoretical  experimental study .
two related facility location problems  emanated.
 networking. suppose   given  network.
modeled   directed graph  . .,., together .
.not-necessarily-disjoint. subsets      , .
   set  customer locations     set .
potential facility locations . typically  .  . .
goal   find  minimum sized subset  . .  .
  every customer  .    two locations.
., . .  .   traffic    .   . .
routed  disjoint paths .usually shortest paths. .
 network. routing protocols.
although  prove   problem  impossible  approximate   worst case even  within.
 factor  .log.
.    . . . .assuming  npcomplete language   solved  quasipolynomial.
time.,  show   situation  much better .
practice.  propose three algorithms  build solutions  determine lower bounds   optimum.
solution,  evaluate   several large real isp.
topologies   synthetic networks designed  reflect.
real-world lan.wan network structure.  main algorithms  .  algorithm  performs multiple.
runs   straightforward randomized greedy heuristic.
 returns  best result found, .  genetic algorithm  uses  greedy algorithm   subroutine,.
 .  new .double hitting set. algorithm. .
three approaches perform surprising well, although, .
practice,   cost-effective approach   multirun greedy algorithm.  yields results  average.
. labs . research, . park avenue, florham park, .
.
.computer science department, university  california, soda.
hall, berkeley,  .  work  performed  .
author   student  columbia university,   partially.
supported  .
.amazon web services, . . avenue south, seattle, .
.  work  performed   author   student.
  university  massachusetts,   partially supported.
 .
within .  optimal   synthetic instances .
within .   real-world instances, excluding .
largest .  realistic. one.   latter instance,.
  two algorithms come   , finding.
solutions     three times better .
   multi-start greedy approach.
 terms   motivating monitoring application,.
 every customer location    facility location,.
 results  even better.    double hitting set solution  . better   default solution.
 places  monitor   customer location . .
comparisons help justify  proposed alternative monitoring scheme  .  results also show , .
average   real-world instances,   save .
additional .  choosing  .shortest path. routes.
, rather  taking  simpler approach .
relying   network  choose   .
. introduction.
 paper studies two new facility location problems.
relevant  questions  internet traffic monitoring .
content distribution.  problems differ  .
 standard predecessors    customer must.
 served  two facilities rather  one.  addition,.
 service routes must  vertex-disjoint.
 specifically, suppose   given  network.
modeled   directed graph  . .,., together .
possibly overlapping vertex subsets , .  , .
   set  customer locations     set .
potential facility locations. suppose  addition .
  pair ., .,  .    .  ,   given.
 set  ., .  directed simple paths     .
.  sets may  defined implicitly .  .
set   shortest c-to-f paths.,    explicit list.
 permitted paths. indeed,   important special.
case  applications      ., .   set .
 shortest c-to-f paths.  convention,  require .
  .  .  ,   zero-length path .    ., .,.
, since  zero-length path    simple path.
   ,   fact   ., . . ., . denoting.
 length-. path starting  ending  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
suppose  .    customer location  ., .
  pair  potential facility locations   , .
either . . .  . . . . .
definition .  say  ., . covers   .
pathwise-disjoint fashion   exist paths . .
 ., .  . .  ., .    common vertex except .   pair covers    setwise-disjoint.
fashion   path   ., . shares  vertex . .
.   path   ., .
note    . .   ., . contains  zerolength path    ,   definition  pair.
., . will cover    fashions.
definition .  subset  . .   called  pathwisedisjoint .respectively, setwise-disjoint. cover    .
every  .     pair ., ., ., . .  ., .
 .  necessarily distinct,   ., . covers.
   pathwise-disjoint .respectively, setwise-disjoint.
fashion.
 two problems  study  defined  follows.
definition .  pathwise-disjoint facility.
location .pdfl.,   given , ,  ,  .
sets  ., .  asked  find  pathwise-disjoint cover.
 minimum size  ,    cover exists. setwisedisjoint facility location .sdfl.   .
problem except   cover must  setwise-disjoint.
  paper,  analyze  complexity  pdfl.
 sdfl  propose  test algorithms  .
 first observation    problems   viewed.
 special cases  set cover  pairs .scp., first.
described  .
set cover  pairs .scp. given  ground set  .
elements,  set   cover objects,   set   triples.
., , .,   .   ,  . , find  minimumcardinality covering subset . .    ,  .
covers      .  ,   ,  . ., possibly.
  . ,   ., , . .  .
pdfl  sdfl   formulated  scp .
taking  . ,  .  ,  ., ., . .     .
., . covers    pathwise-disjoint .setwise-disjoint.
fashion.
 prove, subject   complexity assumption, .
 polynomial-time algorithm  approximate scp .
within  factor   .log.
.    . . . .
best previous hardness bound  scp  just set.
cover-hardness .  will show   two facility.
location problems cases    worst case just .
difficult, even   sets  ., .  restricted  shortest.
paths. nevertheless,  shall see    types .
problems  arise  real-world networks,  variety.
 algorithms perform extraordinarily well  practice.
 tested three main algorithms.  uses .
 subroutine  standard randomized greedy heuristic.
.greedy.  actually solves  general scp problem.  first   main algorithms, greedy., .
 variant  greedy  performs . runs  returns  best solution found.  second   genetic algorithm .genetic.  uses greedy   subroutine.
 third, double hitting set ., exploits  graph.
structure  approximately solves setwise-disjoint.
facility location   sets  ., . consist .
 shortest paths.precisely  version   problem.
 arises   monitoring application.   valuable.
side effect,  also   used  derive   good.
lower bound   optimum   case.
 addition,  formulated  derived scp instances  mixed integer programs,  cplex .
able  solve  optimality     instances .
. . . ., although,  course, running times grew dramatically  graph size.
 final algorithmic challenge    constructing  derived scp instances.  involves exploiting shortest path graphs  determine  .often quite.
large. sets  relevant triples.  triples  required.
    algorithms .even .,   needed .
significant algorithmic ingenuity  prevent  computation    major bottleneck.
. outline.  remainder   paper  organized  follows.  section .  describe  two applications motivating  study.  section .  present.
 complexity results.  section .  describe .
heuristics  implemented.  test instances  described  section .,   experiments   results  summarized  section .
. related work.   previous work  set.
cover  pairs ,  far   know,   .
hassin  segev .,   theoretical rather .
experimental.  paper considers two applications.
  significantly different   introduced.
, ,   worst-case point  view, much easier.
 approximate.  paper also introduces  variant .
 greedy algorithm studied    general scp.
problem  analyzes  worst-case behavior.
. applications.
.  first application. content distribution.
 setwise-  pathwise-disjoint facility location problems arise   variety  networking contexts.  primary motivation  studying  comes.
  scheme proposed  .  active monitoring .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
end-to-end network performance. however,  variants   simple alternative motivation  terms  .
idealized content distribution problem,   shall.
use  help illustrate  definitions. suppose  wish .
distribute real-time data,   television broadcasts,.
  network    provide  rapid method .
recovering  link  vertex failures. suppose .
  service interruptions caused   failures.
  costly  ,    want  distribution process   relatively robust  . .
common standard  robustness  immunity   single vertex  link failure .  instance might result.
  accidental cable cut.  guarantee  resilience,   need  place multiple copies  .
data source   network,     costs.
 hosting  copies,   like  minimize .
number   hosting sites   deploy.
pathwise-disjoint facility location models.
 application  follows.  network  . .,.
  underlying fiber network linking various sites.
 set   customer locations   set  sites .
  receive  data stream.  set   facility.
locations   set  potential sites   content.
  hosted.  sets  ., . correspond   paths.
    route  content  facility  .
customer ,  considerations   presence .
optical switches, desire  low latency, etc., may restrict.
 set  paths allowed. note     talking.
 paths   facilities   customers rather.
  customers  facilities,    case .
 definitions. however,   easy  see   two.
versions   problem  equivalent . simply reverse.
 arcs.
  assume  link capacity    issue,.
  pathwise-disjoint cover  minimum size  .
represents  minimum-cost choice  hosting locations.
  data, subject   constraint   single.
vertex  link failure  disconnect  .non-failed.
customer    data sources.
setwise-disjoint facility location models.
 variant   application      .
control   routing,  instead must rely  .
network    routing  . many internet service.
providers .isp. route packets within  networks.
using  shortest-path protocol   ospf  is-is.
  protocols, packets must  routed along shortest.
paths,   weight .length.   arc  set  .
network managers    balance traffic  optimize.
 performance metrics.      one.
shortest path leaving  given router,   traffic .
split evenly   alternatives.    .
 help  balancing traffic,   traffic engineers.
may specifically set weights  yield multiple shortest.
paths  key routers.  actual splitting .
performed based  computing hash functions  entries.
  packet. header .typically simply  destination.
 address.  functions   randomly.
chosen,  subject  change  short notice, .
 typically  available  . thus  .
 multiple shortest paths, although contemporaneous.
packets   given router    destination .
likely  follow   path,  actual route chosen.
may   readily predictable.   know   .
must   member   set  ., .   shortest paths.
    .  means    way  guarantee.
vertex-disjoint paths   customer   two facility.
locations    .   restrict attention  pairs .,  .
   corresponding shortest path sets intersect.
  ,  consequently  problem becomes .
setwise-disjoint facility location problem .
 shortest path sets.
.  second application. host placement.
 end-to-end monitoring.    application.
 motivated  paper.    realistic .
 first,  also  complicated,  readers .
interested   algorithmic results  safely skip .
section   first reading.
suppose    internet service provider .isp.
 provide .virtual private network. .vpn. service .
   customers.    service,  agree .
send traffic  various locations specified  .
customer, promising  provide  certain level  service.
  connections,   specifying  actual route.
 packets will take. . actual routing will  done.
   optimize  utilization   network, subject.
  promised levels  service.  network  .
digraph  . .,.,    vertices correspond .
routers   arcs   links  routers.  key.
service quality metric  packet loss rate . fraction .
packets   path  fail  reach  destination.
 ., . denote  probability   packet sent.
 router .  router . will successfully arrive. .
goal   obtain estimates  ., .   collection.
 customer paths pri, . note ,  contrast  .
content distribution application,     worry.
 links. failing .  cause re-routing., .
merely   underperforming.
one way  measure  loss rate   path .
 network  router .  router .   attach.
extra equipment   routers, use  equipment .
.  send special measurement packets  ., .
use  equipment  .  count  many  .
packets arrive.   packets  sent   . arrive,.
  .    good estimate  ., .,.
assuming   sufficiently large. unfortunately, .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
process  authorizing, installing,  maintaining .
extra equipment   time-consuming  expensive.
thus,  scheme may   practical   large.
network  hundreds  thousands  distinct path.
endpoints. moreover,  may  impossible  install.
 needed equipment     endpoints due.
 lack  space   concerns.   reasons,.
 authors  . proposed  alternative scheme .
 adapt   fact  certain vertices  house.
 needed equipment,  also may yield  substantial.
reduction   total amount  monitoring equipment.
needed.
figure .  centralized monitoring scheme  .
  new scheme,   monitoring  initiated.
  single special measurement vertex  ,  originally proposed  ., . see figure .  measure loss.
  path  vertex .  vertex .,  equipment.
  sends  packet   circular path  first goes.
fromm  . . hop-on path.,  traverses  path.
 .  .,  finally returns  . tom . hopoff path.   make  following assumptions.
. packets   dropped  arcs,   vertices.
.   close approximation  reality  modernday networks,   arc models  system.
consisting   physical wire.fiber connecting .
endpoints, together   line card    .
ends.
.  three paths ,. , .,. ,  ., .
pairwise arc-disjoint. .  shall show , .
will typically  true shortest-path routing.
. loss rates  different arcs  independent  .
. .  somewhat less realistic,  .
approximately true except  heavily-loaded networks.
figure . scheme  .  measuring loss rate  hop-on.
 hop-off paths.
   packets  sent   circular path.
,.,., ,  expected number .
.  packets.
successfully making  roundtrip will   . .
., ., .,. thus   measure .
. .
 good estimates  ., .  .,.,  will.
  estimate.
., . .
 .
., .,.
.
thus   reduced  problem  measuring  loss.
rates   collection  paths  arbitrary vertices.
   estimating  loss rates   collection .
hop-on  hop-off paths,    either begin .
end   .
 .   proposed   loss rates  .
given path endpoint   estimated  sending packets.
along  ., ,. circuit , , ,  packets.
 sent   . received, concluding  ., . .
.,. .
.
 . . unfortunately,  assumes .
internet performance  symmetric,   definitely.
 .  quite accurate way  measure  loss rates.
  course   put equipment   ends .
   hop-on  hop-off paths,   method.
 require installing equipment  just  many.
routers    original scheme  measuring  .,.
paths directly . indeed  one  vertex, since now.
 need equipment   . setwise-  pathwisedisjoint facility location arise   context  .
tomographic method proposed  .  estimating loss.
rates   potentially much  efficient fashion.
 terms   facility location problems,  set.
  .customer. vertices will consist   endpoints.
  original paths whose loss rates  wish  estimate.  set   .facility locations. will   vertices   capable  hosting monitoring equipment,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
   context  will call  .potential. monitoring vertices. given  path endpoint    monitoring vertex ,  set  .,. consists   paths along.
  may legally route packets      .
network,  currently configured. .     monitoring vertex,   ., .   singleton set consisting.
   zero-length path    .
suppose    path endpoint  .,.   pair.
 monitoring vertices  cover    pathwise-disjoint.
fashion.   claim . justified . , .
installing monitoring equipment  .  .,  .
estimate  loss rates ., . .  hop-on path .
.  .,. .  hop-off path  .   .
  monitoring vertex,  . . . . ,   .
straightforward  measure  loss rates  sending.
packets      counting  number .
  successfully arrive   destinations.
 key case   .  . differ  .
. hence   . see figure . assuming.
  allowed  specify  routing paths  .
 .  .,  fact  .  . cover  .
 pathwise-disjoint fashion means    pick.
legal routing paths .  .    . .
., respectively,   vertex-disjoint except .
 . hence arc-disjoint. moreover, assuming also.
   restricted   shortest paths, .
 guaranteed    common routing protocols.
.ospf  is-is.,  also  ,  additional.
standard assumptions,  two paths .  .  arcdisjoint   path     ,   .
arc-disjoint   path  .     .
   consequence   following lemma,.
whose additional assumptions      arc.
weights used  ospf  is-is   shortest path.
computations.  weights  set  traffic engineers.
 help balance traffic loads  normally obey certain.
restrictions. first,   positive integers. second,.
 practice networks  typically symmetric directed.
graphs,    digraph contains  arc ., ., .
 must also contain arc ., .  weights    .
digraph   symmetric   every arc ., .,.
  ., . . ., . typically,   always,.
 weights  indeed symmetric.
lemma . suppose   given  symmetric directed.
graph  . .,.,  weight function    arcs .
 symmetric  positive,  three vertices , , . .
,  ,  shortest-weight paths   digraph.
       , respectively,    arcdisjoint. .proof omitted.
 basic idea   technique  .  estimating.
 loss rate ., . using  paths   send.
multicast packets     along path  , replicate.
  ,   send  copies along paths . .
.  .  ., respectively.  , .  .
report back   .using  guaranteed-delivery service.
  tcp.    packets arrived. based  .
information, estimates ., .  loss rate .,.
  estimated  sending packets along  ., ,.
loop  counting  number  arrive back   ,.
using  fact   loss rate   loop  .
., .,. . note   result like lemma . .
needed   method   provide reliable estimates, .
fact  observed  .,  contained   result.
 scheme may require two monitoring hosts.
 measure  hop-on  hop-off rates   path.
endpoint , rather   single one  .
 required   placed  monitoring equipment .
vertex  . however,  scheme   potential.
advantage   given monitoring vertex   reused  handle many different path endpoints. thus.
    substantial net overall savings  .
total number  monitoring vertices used,  hence .
equipment  operational cost.
 stated,  problem  finding  minimum sized.
set  monitoring vertices    place equipment.
    estimate loss rates   hop-on  hopoff paths  simply  original pathwise-disjoint.
facility location problem.  practice, however,.
 will most-likely   rely   isp. routing.
protocol .ospf  is-is.  deliver  packets,  ,.
    first application, will face  setwisedisjoint facility location problem.
   noted ,  contrast   first.
application,  necessity  vertex-disjoint paths .
  .  ., rather  simply arc-disjoint paths,.
 less clear, since   previous lemma   .
guarantee   paths  arc-disjoint  .
path    .    meaningless distinction.
  setwise-disjoint case, however,  light  .
following lemma.
lemma . suppose  ., .   .,  .   sets.
  shortest paths  vertex   vertices    .,.
respectively,   given digraph .   path .
 ., . shares  arc   path   .,  .  .
   path   ., . shares  vertex   .
  path   .,  . .proof omitted.
 detailed description   implementation  .
scheme   formulas used  estimating ., .
 .,.  presented  .
. complexity.
  section  investigate  computational complexity  pathwise-  setwise-disjoint facility.
location.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
scp   general   np-hard,  also.
strongly inapproximable   worst-case.   .
. .  .   observed  scp   least .
hard  approximate  set cover,    prove.
much stronger inapproximability .albeit   slightly.
stronger complexity assumption.
theorem .   . dtime.polylog., .
polynomial-time algorithm   guaranteed  find .
solution  scp   within  factor  .log.
.  .
optimal   . . .
proof  theorem .  theorem follows via.
 approximation-preserving transformation  .
minrep problem  kortsarz,  showed  .
inapproximability bound  hold  minrep .
 minrep,   given  bipartite graph  .
.,.   . . vertices  partitions   vertex.
sets   side   bipartite graph   groups .
 vertices, .     left  .  .
  right.   also given  integer .  ask.
whether    subset  . .   . . .  .
  every pair ., ., . . ,  . ,   contains.
 edge   vertex    one   ,  .
  subgraph induced   .
 transform minrep  scp  letting  items.
  covered   pairs ., .   contains.
 edge   member     member .
 .  set  covering objects   ,   item.
., . covered   pairs ., . .     . ,.
 .  ,  ., . . .     one-to-one.
correspondence  scp cover sets  subsets.
 . meeting  minrep requirements,   two.
sets    size. hence  approximation.
guarantee  scp implies  equally good guarantee.
 minrep,   scp must   least  hard .
approximate.
 fact,  special cases pdfl  sdfl  scp.
   worst case  hard  approximate  scp.
,   consequence   following theorem. .
proofs     next theorem will appear  .
full version .
theorem . even  restricted  instances .
  .  ,.
. sdfl   least  hard  approximate  scp,.
even   set  ., .   set   shortest.
paths    .
. pdfl   least  hard  approximate  scp,.
even   set  ., .   explicitly given subset.
  set   shortest paths    .
theorem . leaves open  case  pdfl .
 allowed paths include  shortest paths,  simply.
 selection  ,    yet prove  .
hard  scp  general.   still .logn.-hard .
approximate, however,   consequence   following.
theorem.
theorem .  polynomial-time approximation algorithm  pdfl  guarantee  solution  .
 logn times optimum    . . unless  . ,.
even   set  ., .   set   shortest paths.
      .  .
. algorithms.
  section  describe  algorithms  setwiseand pathwise-disjoint facility location  .
algorithms  constructing  required scp triple sets.
  problems.
. greedy heuristics.  basic greedy heuristic  underlies   algorithms  two phases. .
first begins  initializing  cover . .    empty.
set. ,  long  .   cover   .  , .
find   . .   . covers  maximum.
number  additional elements.   maximum number  positive,  add   . otherwise, choose .
pair ., . .  . .  yields  maximum increase .
 number  elements covered.   pair yields  increase,   instance  infeasible.  second phase.
minimalizes  cover. test  object   cover .
turn  see   removal  still leave  valid cover,.
   remove . . .greedy. algorithm  . .
 include  minimalization phase,    growth.
phase  considers pairs  every step,  just  .
  singleton helps.   hence likely   significantly slower  less effective  practice.
 implementation  greedy uses randomized.
tie-breaking   growth phase.  allow two options.
  minimalization phase. either consider facilities.
  reverse   order     added .
 cover,  consider   random order.  also.
allow two options  starting  growth phase. either.
take  best pair,  take  best singleton. none.
  options . combinations  options. seems .
dominate    others.
  test  multiple-run variant  greedy.
.greedy.,  performs . runs  returns .
best solution found.   . runs,  cycle .
 four option combinations, using   . runs.
multiple runs  feasible    implement .
basic algorithm  run  linear time. .technically .
time  . . . . . . . .,     set .
triples,    instance classes . . tends   .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
dominant term.  details   implementation will.
 presented   full paper.
. genetic genetic algorithms  variants  local.
search  mimic  evolutionary process  survival.
  fittest.  genetic algorithm  scp, calledgenetic   follows, uses  .random key. evolutionary strategy proposed  bean ., .   approach,.
 .chromosomes.    evolving   solutions ,  .random-key. vectors  .
solutions   derived.
  set  cover objects   . ., ., . . . , .
 genetic,  chromosome   . vector.
.gene., . . . , genek.  length .  derive  solution.
.cover. .    chromosome  follows. start.
 . . . . genei . ., . .  . .  .
.  already.
 cover, halt. otherwise, complete .   cover using.
 basic greedy algorithm .without randomization.
 minimalization.  .fitness.   chromosome .
  size   resulting cover .
 overall genetic algorithm starts  creating.
 population   randomly generated chromosomes,.
  gene   equal probability   .
 . .  experiments,  set  . min., . .
 population  evolves   sequence  generations.   generation  start  computing .
solution   member   population, yielding .
fitness.  top .   population  fitness .
.elite. members. automatically pass    next generation. population.  addition,  provide diversity,.
.   next generation consists  randomly generated chromosomes, like  generated initially. .
 remaining .,  repeat  following .crossover.
construction. pick  random member ., ., . . . , . .
 top .   current generation. population .
 random member ., ., . . . , .   remaining .
 .child. ., ., . . . , .   pairing  determined.
 follows.   , independently, set  .  .
probability .,  otherwise set  . .
 scheme insures   best solution always.
survives   next generation,   may continue.
 champion   dethroned   better solution.
generations  continued  max., .  gone.
 without  improvement   fitness .cardinality.
  best solution.   take  final champion .
 .minimalize.    phase .  greedy .although,.
 practice,  rarely helped   final champion.
 parameter settings   algorithm . .
min., . ., max., . generations, top ., etc.
 based  preliminary experimentation  .
intuition derived  applications   approach .
 problems.  appear  yield  good tradeoff.
 running time  quality  solution  .
application,   make  claim    optimality.
.  double hitting set heuristic .
 section describes  double hitting set heuristic.
.     one   algorithms  explicitly.
exploit  structure   digraph ,   .
one  come   .log . performance .guarantee,.
.guarantee.  quotes    refers  covering.
 .t-good. customer nodes, .t-good.   defined .
 moment. . key fact    many   test.
instances, almost  customer nodes  t-good. .
applies   case    sets  ., .  paths.
consist    shortest paths     ,  .
  case    generated  ospf . .
   test instances   main applications.
 ospf  split traffic   case  multiple.
shortest  .  paths,  amount  splitting .
occurs  practice seems   limited.  quantify .
point,  need  definition.
definition .  say  potential facility location .
 good  customer vertex    .    shortest.
 .  paths leave  via   arc. equivalently,.
 ., . denotes  weight  arc ., .  dist., .
denotes  distance    ,   potential facility.
location   good  customer vertex    .  .
., . . dist., . . dist., .   out-neighbors .
   one.
   just one shortest  .  path, clearly  .
good  ,   may  good   even  .
 many  .  paths. note     good  ,.
,  ospf,     splitting    .
traffic     , although splitting  later vertices .
 path   possible.
algorithm  attempts  construct  cover .
 many   customer vertices  covered .
potential facility locations   good  .
definition . say   customer vertex   t-good.
      good potential facility locations .
  . t-bad otherwise.,     parameter .
 algorithm.
  experiments,  ran  algorithm  .
 . . .   . .,  output  better result.
  designed  nearly optimally cover  tgood customers via  union  .  , leaving  tbad customers,  ,   covered via  greedy.
algorithm.
 first step   algorithm   choose one.
good potential facility location   t-good customer.
vertex , without choosing  many vertices  total.
   ,     set  good potential.
facility locations  , except   add     .
  potential facility location .,   definition.
 .good,.   good  .   definition.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 t-good  must  . . .  want  choose.
 small set   potential facility locations  .
 .  . .   t-good customer vertices .  .
words,  want    hits .intersects.   sets.
. finding  minimum-cardinality suchx   classic.
hitting set problem   family .   t-good.
customer vertex.
 greedy algorithm  hitting set produces.
 feasible solution  size   . . lnn times .
optimal,    number  sets   instance.
., .,    application    . .
practice, however,  greedy hitting set heuristic.
typically returns  set  size much closer  .
  optimal, often   single-digit percent .
optimal.   first step   construct  set  .
applying  greedy hitting set algorithm  .  .
t-good customer vertex.  fact,  situation  even.
better .  will see shortly    . . ., .
 greedy hitting set  size .log .
next,   t-good customer vertex , choose .
potential facility location      . ,  .
 . . . . .  , definitely set  . .   easy  see.
  . .  .  .
  . ,   shortest  .  paths leave .
via   arc. call  arc  . ., ., defining .
implicitly. ,    hand,  . ,   . .
   therefore already covered   . since  .
going  cover  t-good nodes   .     ,.
 needn. worry   covering  .
 now ,   t-good       ,.
 least one chosen potential facility location  . ,.
  need two.  find  second  follows.  .
 customer vertex ,     set  potential.
facility locations  .     shortest  . .
paths avoid , together        potential.
facility node. . vertex  .  .      .
 ., . . dist., . . dist., .   set  .
empty,   instance  infeasible . clearly  .  .
 case,    potential facility locations  , .
will   shortest path      contains  .
  two  facilities  cover   setwise-disjoint.
fashion.  suppose    ,    empty.
 surprising fact      . ,  pair.
., . covers ,  immediate consequence  lemma.
. .
recall    t-good  . ,  .  .  .  ,.
  may assume   . .  following lemma,.
proved , will allow   compute  extremely.
useful lower bound   optimal cost.
lemma .  solution   covers  t-good.
nodes must contain  least one facility node   .
  t-good    . .
thus  solution  must contain  hitting set.
   family .  t-good   . .  .
next thing    find one,  using  greedy.
hitting set heuristic. fortunately,     size.
  optimal hitting set  lower bound  opt,  set.
.   feasible solution,   feasible hitting set, .
 show  lemma . .   . . ., .
resulting union  .    particularly good solution.
  restricted problem,  least  comparison .
 complexity results  saw   last section .
solutions   complete sdfl problem.
algorithm  finishes  using  greedy algorithm  extend  solution .   t-good nodes.
  solution   full sdfl instance. since  .
typically  t-bad nodes,  step typically adds .
nodes. finally,  minimalize  resulting solution .
 greedy.
 completes  description  .
proof  lemma .  , choose t-good  .
  .    feasible    .  . . choose.
  .  .  . . hence  .  . .  implies .
   facility node.   equal  ,   .
  facility node,     ,  hence  . .
 , . hence  shortest  .  path uses.
arc ., . now    ., .,  ., . denotes.
 set  vertices   shortest .  path.  .
 true       ,  hence    .  .
 ,    ., .  ., .,  ., . . cover .
.  .  ,  . . cover , either.   .
infeasible,  contradiction.
hence  size   solution covering  t-good.
nodes  greater   equal   size   smallest.
hitting set   family .  t-good   . . .
.  t-good   . . based  lemma .,.
 know   size hmin   smallest hitting set.
  lower bound   optimal solution size  .
instance  sdfl.   easy  set   integer program.
 determining hmin,   turns   cplex.
finds  problems much easier  solve   full.
sdfl problem. thus    code  save .
hitting set instance   file,   turn  fed.
 ampl.cplex,  .quickly. solves  optimally.
 lowerbound figures   results section  .
paper  computed   way, taking  maximum.
  . .   . . . .one   used.
optimal ampl.cplex-solved hitting set solutions.
instead  greedy solutions  implementing , .
   made running  algorithm  .
complex process  one   longer   worst-case.
polynomial-time bound. moreover, given  good .
 solutions already ,   probably  .
 worth  effort. note  since  lower bound.
  take t-bad customer vertices  account,  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
probably weak  cases   many  nodes.
lemma . given   ,  hitting set  .
.  t-good   . .    .   cover.
   t-good customer nodes .
proof. choose  t-good .   .  .  ,   .
 facility node  hence . .  .  covers . .
 may assume   . ,  .  . hence  . .
since  . ,     .  shortest paths use arc.
., .  hitting set  contains  vertex  . .
  .    .  ,  . . hence, .
 . .,  definition    shortest .  path.
uses arc ., .  claim     .  shortest.
paths actually avoid   vertices .except .  .
  .  shortest paths,  hence ., . .  . .
covers . .  definitions    ,  . .
  true    .  shortest path .  .
 .  shortest path . shared  vertex   ,.
    first vertex . .  .    .
  prefix      .     .
 length   prefix      .  .
key point. hence     shortest . .
path  uses arc ., .,  contradiction. hencex.
covers   t-good customer nodes.
 opt. denote  optimal solution   sdfl.
problem restricted   t-good customer vertices.
lemma .   performance .guarantee.   .
spoke.
lemma .   . . .,  . .  .log .
opt.
proof. assume    least one t-good customer,.
 otherwise . .  . . .   claim holds trivially.
 lemma .,  optimal solution   restricted.
problem must contain  hitting set   sets  .
   t-good customer vertex   . . thus,  .
results  ., .   . . . . .  .opt.
  use   argument  . ., since .
constructingx  restricted attention  good potential.
facility locations,  opt. need    restricted.
however,  different argument applies.   choice.
 ,  know    t-good vertex , . .
. . . . . therefore,.
.
  t-good . . . .
. .,    potential facility location  must .
  least .   sets. consequently,  greedy.
choice must hit  least  many sets.  essentially.
  argument,  must hit  least .  .
remaining unhit sets  time  makes  choice, .
 must  completed constructing  hitting set .
   . . log. . steps. since    least.
one t-good vertex,  must  opt. . .,  .
lemma follows.
. optimal solutions using mixed integer.
programming. set cover  pairs   modeled   simple mixed integer linear program .mip.,.
 allows   leverage general purpose commercial.
software  solving  problems.  mip formulation   boolean variable     . , .
 . .    chosen   cover.  addition,  .
 real nonnegative variable ,.   pair ., . .
.not-necessarily distinct. elements  , subject  .
constraints  ,. .   ,. . . . note .
 together imply  ,.   positive  .
   . equal . .,    chosen cover.
 addition    following constraints, one .
  .  ,  order  guarantee   chosen set .
 cover.
.
,.,,. ,. . .
 goal   mip   minimize.
.
. . .
feasible solution   given mip corresponds  .
feasible solution . .    scp  vice versa, .
.   set  cover objects     . .
 used ampltm  turn  scp instances .
mip instances  called version .  cplextm .
solve .  mip approach proved practical .
surprisingly large instances, enabling   find optimal.
solutions    two   instances   test set.
 . . . .  detailed experimental results will.
 summarized  section .
. triple generation.   follows,   .
   numbers  vertices  arcs   graph.
.   applications,  may assume   . .
  relatively small constant , given  structure.
 real-world data networks.   also expect .
 sizes   sets   customers    potential.
facility locations   proportional  .
 triple ., ., .    scp instance corresponding   given instance  setwise-disjoint facility location   . , ., . .  ,   shortest.
path    . shares  vertex    .
 shortest path    .  naive way  test.
    construct,   ,  set  .
vertices  shortest paths    ,   testing.
whether  . . .  sets  conceivably .
 size proportional  , yielding  running time .
  proportional  . .,   best  .
say   running time    algorithm  .
  .
fortunately,    easy observation    .
contains  vertex   ,   contains .
vertex    neighbor  . thus  may restrict.
attention   sets   vertices adjacent   .
  shortest paths  .  compute  sets.
 first construct  shortest path graph    .
 vertices  time . log .,    .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
neighbor    identify  sets   contain .
  .-time search   tree.   pair.
,  ,  intersection test    performed .
time .outdegree., yielding  overall running time.
  . log . . . . .  .
assumptions   underlying graphs.
  pathwise-disjoint problem,  naive algorithm  even worse, since   given triple , ., .,.
 may  exponentially many paths  potential.
length .  compare.   must   clever.
 first observe    actually reduce  test.
  simple network flow problem, obtained  adding.
new arcs  .  .   new vertex , giving .
vertices capacity one,  asking whether    flow.
 value .    . next,  observe    .
particularly easy flow problem,    solved .
linear time  starting   shortest path   .
 via .   looking   augmenting path. finally,  observe ,  fixed  shortest path.
 .  constructed  residual graph,   actually solve  network flow problems   pairs ., .
 parallel   single breadth-first search.  overall running time thus becomes . log . . .,.
  .   assumptions.
. network test instances.
 tested  algorithms   synthetic  realworld instances.  two classes modeled different.
types  data networks   distinctly different.
characteristics, enabling   test  generality  .
methods.   section  will discuss  type .
instance,  compare  structural properties  .
resulting testbeds.
. synthetic lan.wan instances  synthetic instances  designed  reflect  structure .
large real-world local-  wide-area networks .lan.
 wan.   sized     study .
scalability   algorithms   solutions  produce.   generated via  following four-step.
process.
.  transit-stub skeleton graph  generated using.
 georgia tech internetwork topology models.
.gt-itm. package .  generated . graphs.
  parameter settings  yielded . . .
., ., ., ., ., ., ., . . value  . .
  indirect result  one. choice   allowed.
input parameters.
. traffic demand  generated   pairs .
vertices   skeleton graph using  gravitational.
model .described .   shortest path.
metric.
figure .  transit stub network  three transit.
domains  ten stub domains. one stub domain homes.
  transit domains .  . two stub domains .
linked   stub  stub edge.
.  determine link capacities  ospf link.
weights    traffic   routed  .
resulting network using  ospf routing protocol.
.
. given  desired numbers  customer  facility location vertices,  sets     randomly generated,   .   insure feasibility.  .,. denote  set  instances.
 . . . .  . . . . .  .
graph  generated seven instances, one  .
type .,., .,., .,., .,., .,.,.
.,.,  .,.
. transit-stub skeleton graphs transitstub graphs .  hierarchical graphs made   transit vertex components  stub vertex components. .
stub node components   thought   access networks   transit node components make  .
backbone   network. see figure .
 gt-itm package provides  parameterized.
method  generating  graphs randomly.  constructs undirected graphs,    view  directed graphs  arcs ., .  ., .  place  every.
edge ., .  constructed graphs consist   transit domains,  containing  average   transit.
vertices   average   internal edges connecting ,   average ett edges joining vertices .
 domain  vertices   domains.  addition,.
   average   stub domains per transit vertex,  containing  average   stub vertices .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . .      ett est .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
. . . . . . . . . .
table . measured parameters  generated transit-stub.
graphs.
 internal edges, along   average  est edges.
connecting vertices   stub domain  transit vertices.  addition,  program adds additional edges .
necessary  insure   graph  connected,  .
  occasionally adds edges  different stub.
domains .  happened ,  one   .vertex graphs. see .   description   random.
process  produced networks   form  guarantees    connected.
 generated . graphs   eight different sets.
 parameters yielding increasing values  . . note.
  number  vertices    explicit parameter.
  graph generation process,  rather   function.
  values    parameters,  helps.
explain  fact   values  . .   increase.
uniformly.  package also   allow  direct.
input     ,  instead asks   probability.
  pair  vertices   transit domain.stub  .
edge.    graphs  set  probabilities .
.  ., respectively.  table .  present .
measured averages   parameters   value .
. . note   edge ., .   generated graph.
 represented   two directed arcs ., .  ., .
  derived network.
. traffic demands  traffic demands .
created via  randomized .gravitational. method. .
first generate random numbers ., . . ., . .
 vertex , ,   pair  vertices ., .,.
compute dist., .,  shortest length . edges.  .
path    .  dmax   largest  .
distances. ,   ordered pair ., .  distinct.
vertices,  choose  random number  . ., .  set.
 traffic demand      .
 . .
dist.,.
.dmax . . . . . .
. ospf routes given  skeleton graph .
 traffic demands,  apply  algorithm  .
 computes link capacities  corresponding ospf.
weights    traffic   efficiently routed.
 ospf weights  become  basis  determining  shortest ., lowest-weight. paths  .
pairs  vertices,   set  paths   pair ., .
 represented implicitly   graph consisting .
 union    edges contained   paths.
. customers  potential facility locations     skeleton graphs,  generated.
seven networks, differing   choices   sets .
   potential facility locations   customer.
vertices.  synthetic instance testbed thus contains.
. different networks   value  . .,   total .
. networks.
. real-world isp instances  real-world instances   testbed  derived  five proprietary tier-. internet service provider .isp. backbone.
networks  used actual ospf weights.  networks.
ranged  size   little   . routers .
nearly .,.,    . .  . . edges.
.similar   range   synthetic instances. .
shall denote   ., ., ., ., .
.,   number following     number.
 routers, rounded   nearest multiple  .
 constructed . instances     four.
smaller topologies, starting   case    .
 .  .   instances also   .  ,  .
  random sample  roughly ., .,  .  .
vertices.   combination   topology  .
set ., ., .,  .   sample size,.
 generated five distinct instances, based  different.
random choices  .
  largest network, .,   .
 detailed information   roles played  .
routers,  constructed  instance  took .
roles  account. access routers served   customer.
vertices   potential facility locations consisted.
  access  aggregation routers .modeling .
situation   measurement hosts   .
connected directly  backbone routers.
. instance properties  synthetic instances.
reflect  structure  real-world lans  wans, .
consist  many, relatively small .-connected components,  largest averaging  .   vertices.
.  . . . .  contrast,  tier-. isp.
instances consist  one  large .-connected component, containing  .   vertices  average,  small .-connected components hanging  .
.  results   isp instances yielding substantially  triples   synthetic ones   .
size.  example, .  roughly four times  many.
triples   .,. instances  . . . .
 choice  arc weights also   effect .
 instances.  optimized weights   syncopyright . .  siam .
unauthorized reproduction  prohibited.
.
thetic instances lead  relatively  shortest-path ties,.
   pathwise-disjoint instances average  .
 triples   corresponding setwise-disjoint instances.  weights   isp instances  constrained   variety  factors  addition  traffic.
balancing,  yield far  ties.   result, .
pathwise-disjoint instances  average  roughly .
 triples. ,   synthetic instances,  set  .
edge weights equal, rather  optimizing ,  get.
even  ties   extreme results.  number.
 setwise-disjoint triples drops   .  average,   number  pathwise-disjoint triples averages.
.   . .   number  .
triples  weights  optimized.  also observe.
  number  triples grows worse  quadratically   number  vertices   synthetic class.
.,.,     least  quadratic blow-up .
 isp instances,   number  triples  .
approaching . million.
. summary  experimental results.
 section evaluates  algorithms  three areas.
. accuracy.  accurate   approximations.
provided     algorithms greedy, genetic  .  opt  known,  compare.
 opt,  otherwise   hh-derived lowerbound.
. execution time.  fast   algorithms. .
times  report   runs   sgi shared.
multiprocessor machine  . . ghz itanium.
.ia-. processors  . gigabytes  memory.
. algorithm run used   single processor.
. solution quality .cost reduction.  first two.
measures address  quality   algorithms.
 one addresses   tell   .
applications. even  optimal solution will  .
enough  justify  proposed monitoring scheme.
 .     provide  significant savings.
  default solution  simply takes .
customers .   instances  .
facility locations.   likely  yield  reliable.
measurements.  also consider  much .
improvement  obtainable  going  .
setwise-disjoint   pathwise-disjoint versions .
 problem.
. accuracy  synthetic instances  table.
.,  present  average values   lower bounds.
computed    heuristic   . classes .
synthetic instances.  provides  idea  .
class . . . . . . . .
average values  lowerbound.
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
number  instances solved  mip.
.,. . . .     .,. . . .     .,. . . . .    .,. . . . .    .,. . . . . . . . .,. . . . . . . . .
.,. . . . . . . . .
average value  opt.lowerbound.
.,. . . .     .,. . . .     .,. . . . .    .,. . . . .    .,. . . . . . . . .,. . . . . . . . .
.,. . . . . . . . .
number  instances,  .,  .
lowerbound  known  equal opt.
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
.,. . . . . . . . .
table . lowerbound versus opt  synthetic instances.
solution values vary depending  class  value .
. .  table also reports  many   . instances.
  type   mip code  able  solve within.
 .-hour time bound.  . . . .,  eventually.
solved  four missing .,.  .,. instances,.
although  longest .,. took slightly  .
 week. note, however,  .   . solved.
instances took less  . minutes.   class.size.
combinations   mip solved  . instances, .
also present  average amount    optimal.
solution exceeded lowerbound.
  lower bounds   good.  shown .
 table,  average values  opt . lowerbound.
never exceed .     cases  . . . .
  still result  fairly large percentage differences.
  cases  opt  small .  .,.
 . . . .,    cases   . . .,.
 percentage gap  less  . also,  shown.
  table,  lower bound  often optimal even.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
  larger values  . .  mip fails.  .
able  conclude  whenever one   heuristics.
finds  solution  matches  lower bound, .
happened  .   instances   mip.
failed, bringing  total number  instances  .
optima  known  .  .  gap .
lowerbound   best solution known begins .
widen  . . . ., although      point.
know   apportion  blame   quality.
 lowerbound    heuristics.   follows,.
 standard  comparison  accuracy will   true.
optimum    known,  lowerbound  .
 true optimum   known.  shall call  .
.lower bound.  opposed  lowerbound.
 strength  lowerbound might seem surprising, given   corresponds   size  just one .
 two disjoint hitting sets   put together .
  heuristic. however,  first hitting set tends.
  quite small,  recall    solution .
 significantly smaller   sum   sizes  .
two hitting sets, given  final minimalization pass .
deletes redundant vertices   cover. however, .
quality   bound  depend     high.
proportion  t-good customer vertices,   average percentage   customers   t-good .
 . . .  dropping  . . increases   instances . .  .     . . . .
 .
 instances   type studied ,   .
heuristics come  close   lower bounds.  .
 contrast   complexity results  suggest .
 polynomial-time heuristic   well   malicious instance designer. leading  pack, greedy.
found  optimal solution    instances  .
 known,  found  best solutions  know  .
   instances, averaging .   lower.
bound   instances  . . . .,   individual class average excess exceeding . . ignore.
results   instances  . . . .,   seem.
 easy.   solved  mip  . seconds  less,.
 greedy. takes  fraction   second  always.
found  optimal.  corresponding percentages .
basic greedy, based  taking  median result .
 . runs  greedy.,  .  .
 genetic, based  just one run,   .
 .   ,   .  . .
 three cases,  worst results   class .,.
 . . . . none   three latter algorithms.
dominate    others, although genetic  .
viewed  marginally  best,     worst .
genetic finds solutions better    greedy.
. times,    beaten . times.  comparison .
,  score  .  . greedy beats  .  .
 similarly mixed story holds   corresponding pathwise-disjoint instances,   .
greedy. finds  optimal solution whenever  .
known,   never beaten      heuristics. note  although  theory justifying  .
applies   setwise-disjoint case,  still   run .
pathwise-disjoint instances,  still produces reasonable solutions.   longer produces valid lower bounds,.
however,    instances   evaluate .
heuristics. excess  optimal except   instances.
 mip succeeded   feasible amount  time.
 results  greedy., although  potentially measure  tail   distribution,  actually.
quite repeatable .  none   . synthetic.
instances   value   .best-of-. runs occur  fewer  .   runs.   assume .
distribution mirrors  actual distribution,  .
probability  failing  find  best    .
. . .     confident  .
results  genetic, since ,    running.
times involved,  rely   value   single run. .
shall, however, investigate  issue   full paper.
. execution times   began  study,.
 main concern   evaluate  proposed monitoring scheme,  hence  emphasis   measuring solution quality,  less concern  running time.
consequently, none   implementations . .
 time   include greedy.  particularly efficient.  remains  case   , .
part,  genetic.  , however, reimplemented.
greedy.    heuristics  originally implemented   different co-author,  involved slightly.
different tie-breaking rules   implementation  .
underlying greedy heuristic.  three implementations.
consequently   yield entirely consistent results.
  code  adapted  just run  greedy.
heuristic.  current version  greedy  implemented  explore  differences,  consequently.
 designed  efficiency   mind. moreover,.
typically .     running time  spent .
reading  input  setting   initial data structures, making  performance  multiple runs  .
 instance quite cost effective  leading   add.
greedy.   algorithmic mix.
see table .,  lists  algorithms. average.
running times   largest synthetic instances, .
 . . . .  . . . .,    seven.
instance classes.   full paper,  will report .
re-implemented versions genetic   using .
new greedy implementation.  expect   .
 time competitive  single-run-greedy. based.
 preliminary experiments, re-implementing genetic.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
triple greedy.
class gen . .  genetic.
. . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
. . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
.,. . . . . .
table . average running times  seconds   .
ghz itanium processor  setwise-disjoint instances.
triple generation   pathwise-disjoint instances.
takes roughly twice  long   setwise-disjoint ones,.
  ratio growing slightly  . .
 also speed   significantly, although .
improvement may    dramatic. note, however,.
 even   current implementations,  results.
suggest  greedy.     fast enough.
  practical even  much larger instances .
studied ,   triple generation code will .
add  substantial overhead.
. cost reduction.   section  consider.
 savings  heuristics  provide  simply.
choosing  cover consisting   set    customer.
vertices .always  feasible solution since  instances .
  .  ,   default solution  network path.
monitoring     use  proposed monitoring.
scheme.   given class  savings   appear.
 vary strongly  . . therefore,   simplify.
things  report   single average improvement.
  class,  shown  table .   present.
 average percentage reduction  cover size produced.
 greedy.,  well   reduction   .
obtained    find covers matching  best lower.
bounds   instances.    seen,  savings .
substantial.  smallest average savings generated .
.setwise-disjoint. greedy.  roughly .  .
largest  .  addition,  table shows  .
reduction   obtain , instead  considering .
setwise-disjoint version   problem,  used .
pathwise-disjoint solutions.  improvements  .
moderate,   latter  improve   former.
set-disjoint path-disjoint.
class greedy.  greedy. .
.,. . . . .
.,. . . . .
.,. . . . .
.,. . . . .
.,. . . . .
.,. . . . .
.,. . . . .
table . percentage reduction  cover size compared.
 . . means  best possible improvement.
  setwise-disjoint case, given  lower bound .
 optimal solution   case. . means .
percentage   greedy. pathwise-disjoint.
solution improves   setwise-disjoint solution.
 .   . instances,    class .
average beats    setwise-disjoint upper bound.
 overall average improvement  .,  works.
  almost saving  full facility.   .
improvement   obtained    willing  settle.
 arc- rather  vertex-disjoint paths,  might.
make sense   monitoring application,  .
 relevant lemmas  still apply. arc-disjointness.
provided  improvement  .   . instances.
. results  real-world isp topologies.
 results   . instances based  actual isp.
backbone topologies  similar     synthetic instances, although,   shall see,  .
  significant differences.  mip code  .
 able  solve   instances  . . . ., .
 case  ones based  .  .,  .
median running time  . seconds   maximum .
. minutes.   also able  solve   .,.
instances based  ., although  maximum .
 . hours,   solved four   five .,. .
instances,  times ranging form . hours  . days.
  instances mip solved,  gap  .
optimal   hh-based lowerbound  larger.
   synthetic instances.  averaged .
versus .   synthetic instances  . . . .
.   solved . instances.  none  .
. real-world instances left unsolved  mip   find.
 solution  matched lowerbound,  opposed .
.   .   synthetic instances.  decline.
  quality  lowerbound  possibly .
  significantly fewer . .-good customers.
     synthetic instances, presumably.
  real ospf weights generated  shortest.
path ties. overall  average  . versus .
  synthetic instances, ,   instances .
approximately . vertices, . versus . .
.   just .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
   synthetic instances, greedy. found.
 optimal solution   instances  mip solved.
 also continued   robust, never finding  best solution value fewer  . times. however,   longer.
found  best solution   instances,  beaten.
 genetic  one . instance     .
. instance,    large   initial genetic implementation  handle.  addition,  averaged .   best lower bound,  opposed.
 .   synthetic instances, although,  suggested ,  may    fault  lowerbound.    beat genetic  . instances .
  . .genetic outclassed  .  .
one , however, surmise  greedy. may.
 running   gas  . . increases.   one .
instance    beaten  genetic,   find.
 better solution  high probability   replace.
greedy.  greedy.,.   increase.
 running time  .  . minutes,  compared .
. hours taken   original genetic implementation.  re-implemented genetic may  much .
competitive, however, since  number  calls  makes.
 greedy will probably  significantly smaller .
.,.   .,   realistic real-world instance, greedy.  totally outclassed.  finds .
solution  size .  . minutes, whereas greedy.,.
 takes roughly   time, finds   solution  size . indeed,  greedy solutions  .
ever found,    .,. runs,  bigger .
. . preliminary experiments,  re-implemented.
genetic algorithm also finds solutions  size . .
takes . hours,  time    substantially.
reduced   optimize  implementation. parameters,   resulting running time  unlikely  .
competitive   similarly re-implemented , .
 likely take less   minute.
  cost reduction,  heuristics provided even.
greater savings   numbers </doc>
<doc title='alx11_08_chend.txt'>
approximate map matching  respect   fre.chet distance.
daniel chen . anne driemel . leonidas . guibas . andy nguyen .
carola wenk .
abstract.
 extend recent results using curve simpli.cation .
approximating  fre.chet distance  realistic curves.
 near linear time  map matching.  problem .
matching  curve   embedded graph.  show .
 theoretical bounds   running time   previous result still hold   one   curves  simpli.   course   approximation algorithm.
 enables  extension   case  map matching.
  assumption   graph  .-low density.
  constant .  present experimental evidence .
 assumption  implement  extended approximate matching algorithm.  show   performs.
well  real world data,   gps traces  road.
networks  urban areas.  particular,   able  perform matching tasks  took several hours  .
exact matching algorithm    second.
. introduction.
given  polygonal curve . . ., . .    embedded graph     edges embedded  straight line.
segments,  consider  problem  .nding  path.
    closest  .  respect   fre.chet.
distance.  problem  become increasingly important   past  years due   proliferation.
 gps tracking devices  applications.   .
studied   ., ., .   theoretical .
experimental results   obtained. previous theoretical bounds  running time   quadratic .
 worst case,  hence  unsuitable  large, real.
world road maps.
 ., . wenk  . implemented  practical weak.
.computer science department, stanford university, palo.
alto,  .
.danielc,guibas.stanford.edu, tanonev.stanford.edu.
.department  information  computing sciences, utrecht.
university, netherlands, anne.  work  .
supported   netherlands organisation  scienti. research.
.nwo.  rimga.
.department  computer science, university  texas .
san antonio, usa, carola.utsa.edu.  work  .
partially supported   national science foundation grant.
nsf career ccf-.
fre.chet distance based map matching algorithm. although   examples  results  comparable.
  obtained using  fre.chet distance,  weak.
fre.chet distance  two curves  still  arbitrarily smaller   fre.chet distance. gps traces.
  self-intersecting loops,  instance  highway.
intersections,  follow  .zig-zag. shape,  instance.
 climbing  mountain.  shapes   .
matched truthfully   weak fre.chet distance. motivated   recent result  approximating  fre.chet.
distance  two polygonal curves  near linear.
time .,  present  new algorithm  map matching.
 runs  near linear time  realistic input data.
 also present  practical implementation   algorithm  running times   dramatically better  previous .strong. fre.chet distance based algorithms.  strength   approach lies   .
theoretical guarantees  practical running times.
. input model.  follow  approach  ., .,.
.  applying simple  realistic input models .
place bounds   running time  algorithms. .
particular,  assume   input curve .  c-packed,.
see .,   embedding    .-low density, see.
.  also implement  algorithm  calculate .
low density constant .  show experimental evidence.
 real world maps  .-low density   reasonable.
constant .  formal .nitions   input models,.
refer  section .
. organization.  section .,  .  problem, revisit  .nition   input models low density  packedness, provide experimental justi.cation.
  input assumptions,  review foundational.
work.  section .,  explain  essential ideas  .
map matching algorithm  provide  proof  theoretical running time bounds   input assumptions.
 section .,  summarize  experimental results.
 compare  performance   algorithm  .
 previous algorithms   weak fre.chet distance.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. preliminaries.
. input model.  input   algorithm  .
polygonal curve .     line segments  .
embedded graph  . .,.   vertices equipped.
  straight line embedding  .   .,.
 vertices  . ., . . . , .  embedded  points.
., . . . , . .    edge ., . .   embedded.
  straight line segment , . vivj .   theoretical.
bounds,  assume  addition  .  c-packed, .
.ned .
definition . .c-packed curve.  curve .  cpacked    ball ., .,  holds  ., . .
.
   fairly general  realistic assumption .
curves,  discussed  .  also assume   .
.-low density,  .ned .
definition . .-low-density graph.  graph .
 .-low-density    point    radius  . .,.
 ball ., . intersects   . edges    .
longer  .
 experimentally veri.  maps  real world.
cities  .-low density  constant .  results .
summarized  figure .  computed  low density.
constant  .   map  san francisco. however,.
 remark      road network, .
low density constant  much lower.  ball .
contained . segments  length greater   .
radius happened    degenerate case   many.
lanes  split   separate edges, see figure .
   way  low density input model .
.ned,  values   grow   size  .
considered area within  city.
. computing  low density constant. .
compute  values  figure .,  followed  simpli.
version  algorithm .  .
    edges   embedded graph .
represents  map   city.  algorithm iterates.
  edges  longest  shortest.  .
edge ,  algorithm computes  subset  edges.
 . ,   longer    within distance.
.  ,  .   length   edge .
next,  algorithm computes  maximal number .
 overlapping objects   set  minkowski sums.
 . .  .  .  .  . .,.
    ball  radius . centered   origin.
 value    equal    maximum number .
edges    length  least .    covered.
  disk  radius .
  algorithm iterates   edges .
largest  smallest,  addition   one edge .
increase  current maximum value    one,.
., . .  . . . . therefore,  determine .
value  ,   .cient  test   . . .-set .
 current arrangement  non-empty.  iterating.
  edges  ,  output   set  kn-low.
density.
 runtime   algorithm  dominated  two.
factors.  time  takes  compute  , .
  implemented   range queries,   time.
 takes  compute  . .-set    . .  .
. however,  simple packing argument implies .
. . .    .-low density.
. problem .nition. first,  . .
fre.chet distance.
definition . .fre.chet distance.  two.
curves given  continuous maps . . ., . .  .
. . ., . . ,  fre.chet distance  .ned .
 ., . . inf.
.,.,.
.,.,.
max.
.,.
. .
 ., . range   continuous  monotonically.
increasing functions  . . ., . . ., . . .
 . . .
 note   fre.chet distance  symmetric .
satis.  triangle equality.  variation   fre.chet.
distance known   weak fre.chet distance drops .
monotonicity requirements  .  .  follow .
convention  .  parameterized  . . ., . . .
   split   line segments . . .,.
 assume   line segment  . , whether.
considered   edge   graph    part .
 polygonal curve,  parameterized   natural.
parameterization . . . . . . .  problem.
   .  path .    minimizes  fre.chet.
distance  ., .
. free space.  free space  two parameterized.
objects, .rst .ned  .,   standard concept.
used  many frechet distance computation algorithms.
intuitively,  free space   sublevel set   distance.
function   parameter space   objects. .
fre.chet distance   variants  generally computed.
 following certain paths   free space.
 concretely,  two polygonal curves .  .
 free space  .ned   ., . . ., . .
., . ., . . . . . .    veri.
  ., . . .        monotonic.
path  ., .  ., .  ., .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
city low density.
san francisco .
athens .
berlin .
san antonio .
figure . low density constants .
road networks  .erent cities.
figure .  ball  san francisco .ning  density constant.
figure . free space  .
curve   graph.
. foundational work.  theoretical results.
 built upon   .  . although  results.
include many details   essential  proofs .
correctness,  brie. summarize  basic approaches.
.
 ., alt  . extend  concept   free.
space   case   path . . ., . . ,  .
embedded graph .  notation  description .
 free space   curve   graph   follows.
first,  .
 . ., . . . . ., . . . . . .,.
    vertex   graph  .
, . ., ,.,.
 ,   edge  . ,  free space.
.,.  .     viewed   free space.
diagrams , glued together   one dimensional free.
space diagrams  . alt  . call   free space.
surface.   illustration, see figure .   .
   left endpoint   right endpoint   .
   veri.   exists  path .   .
 ., . . .      exists  path . .
.,.   left corner    right corner.
   .
.
idi. consists  monotonic pathconnected components.  convenience,  call .
paths map monotonic.
 decide whether  map monotonic path exists, .
.rst computes reachability pointers .see section .,.
 encode portions   path    matched.
  edge   graph. ,  sweep algorithm .
performed   sweep increases   parameter   path  events  processed  discovered.
using  reachability pointers.
 ., driemel  . introduce  framework .
speeding  approximate fre.chet distance computations.
 using curve simpli.cation  realistic input models  bound  complexity   free space.  particular,  results yield  linear time algorithm .
c-packed curves.  approach begins  .nding .
linear sized set  approximate distances  .
vertices   curves using  well separated pairs decomposition. ,  binary search   values.
using  decision procedure, .nds  suitable level .
simpli.cation  approximating  solution .ciently.
 section .  show   bounds   complexity   free space still hold   one   curves.
  simpli.,  enables  extension  .
map matching case.
. algorithm.
. decision procedure.  .rst describe  exact.
decision procedure based   algorithm described .
.  will serve   building block   complete.
algorithm.
. computing  relevant free space. .
 relevant free space .,.   set  points.
 .,. reachable      path,.
 necessarily map-monotonic.  note   decide.
whether min.  ., . . .,   need  consider.
 relevant free space .,.
  .,  decompose two dimensional free spaces.
 cells corresponding   free space  two.
segments.  also decompose one dimensional free.
spaces  intervals corresponding   free space.
  segment   point. now,   number.
 cells  non-empty intersection  .,. .
denoted .,. ,    following easy.
lemma.
lemma .  non-empty ., . .
., ,.   computed  ordered lists .
time .,. log .  space .,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
proof. .proof sketch. first,  .  vertices .
    ., .  non-empty  .
time. ,  simulate depth .rst search .
 graph   vertices correspond   cells.
. . ., vivj.  edges correspond  nonempty boundaries   cells.  ensure . .
.,. space,      maintain  corresponding edges  standard one-dimensional search trees.
ordered   cell index along . hence,   .
additional factor  log .  practice, however,  used.
hashing   cell index.
 show    decide whether  exists.
 map monotonic path  .,.    .
   .,. log. time.  follow .
approach  .  .rst computing reachability pointers,.
  solving  problem using  sweep algorithm.
. computing reachability pointers.  .
 ,  .ned analogous    , .
   continuous interval  ,   reachability.
pointers ,.  ,.   leftmost  rightmost.
points, respectively,      reached .
 point     monotonic path  , .  .
illustration, see figure . ,  .
lemma .  , .      .ned .
., . assume  ., ., ., . .
., ,.   computed  ordered lists. ,.
 pointers ,.  ,.  . .  . . . .
 computed  ., ,. time.
proof. .proof sketch. .
., ,.,., ,., . . ., ,.
  decomposition  ., ,.  maximal sequences  consecutive cells  .
., ,., ., ,., . . . ., ,.
  corresponding sizes.
 lemma .  .,  pointers ,. .
,.   . ., ,.   computed .
., ,. time. thus,  pointers   .
  computed .
.
.
., ,. . .
.
.
.
., ,.
.
. ., ,.
. sweep algorithm.  sweep algorithm  .
    ., except  use  sparse lists created.
   previous subsection.  will   following.
result.
theorem .  .   polygonal curve  complexity      graph   vertices  .
edges. ,    algorithm decider.,, .
 decides whether    path .    .
 ., . . .  . . .,. log. time .
. . .,. space.      ., decider.
also returns .
proof. .proof sketch. creating  reachability pointers takes . . .,. log . time.  sweep algorithm processes .,. events   event.
takes .log . time  process.  space required .
dominated     reachability pointers .
use . . .,. space.
. approximate decision procedure.  follow .   framework  turning  decision procedure    .cient approximate decision procedure  .rst simplifying  curves.  version .ers.
    simplify  curve .   leave .
intact.  .rst state  simple .-simpli.cation scheme.
 .
definition . .-simplification.  denote .
simpl., .  simpli.cation   polygonal curve .
obtained  taking  .rst vertex  ., scanning .
.    step  taking  next vertex   .
distance  least .   previously taken vertex.
  easy  see   segment  simpl., .  .
length  least .   ., simpl., . . . , .
following .fuzzy. decision procedure   obtained.
lemma .  .   polygonal curve  complexity .
    graph   vertices  . edges. .

, . . .  parameters. ,   construct .
algorithm fuzzydecider.,, ., 
.  runs  .
.simpl., ., . log. time,  . . .
.,.
 outputs one   following.
.  min.  ., . . .,   algorithm outputs.
reparameterizations  match .  . .  within.
fre.chet distance . . 
.
.  min.  ., . . . . 
.,   algorithm.
outputs .min.  ., . . .
. otherwise,  algorithm outputs either   .
outcomes.
proof. .proof sketch.  proof     .
 .,   use . . .
.  . . . .
.  appeal  theorem .  decide whether.
min.  .simpl., ., . . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
.
,. . ,.
 .
,.,. ,. . ,.
figure . reachability pointers.
just   .,   use  approximate decider.
 guide  binary search   precise way  calling .
twice  .erent parameters.   precise decision.
  possible,   decider returns  . . 
.
approximation directly.
lemma .  .   polygonal curve  complexity      graph   vertices  .
edges.  
, . . .  parameters. ,  .
 algorithm approxdecider.,, ., 
.   . .
.simpl., ., . log. time,  . . .
., returns either.
.  . . 
.-approximation  min.  ., .
. min.  ., . . .
. min.  ., . . .
proof. .proof sketch.  proof     .
 .,   use  fuzzy decider procedure .
lemma .
. bounding  complexity   relevant.
free space. first,  note  following lemma .
.
lemma .  .   c-packed curve, . . ., .
. . simpl., . , .   .c-packed curve.
,  show   complexity   free space.
  simpli. curve   graph .simpl., ., .
 linear   complexity  .    .  .
c-packed curve     .-low-density graph, .
. . .
.
lemma . given  c-packed curve .   edges .
 graph   . edges  ,  holds .
.simpl., ., . . .
 . .
.,.
 . . .
.
proof.  . . ., . . 
.  . . simpl., .
., .  composed  cells ., ,.   .
., ., . . . ,   ., . .   thus ., .  upper.
bounded   number  non-empty cells.  cell.
., ,.  non-empty       points.
 .  , within .   .  charge .
 non-empty cell   shorter   two segments.
 divide  analysis  three cases.
. case .  .  charged.   case, .
consider  ball  radius . . . . . .
.
 . . . .
. around  midpoint .
.  ,  charges . must lie   ball.
   length  least . however,  note.
  ball   covered  .
. balls .
radius .  hence     .
.
 ,. hence,  total number  charges due.
 case .  .
.
. case .  ,  charged  .,. . . .
 use   ball  radius .,. around .
midpoint  ,. , using   argument.
  .,  number  charges  ,   .
. . . . .
.
. case .  ,  charged  .,. . . .
 use  ball   radius .,. . . . around.
 midpoint  ,.  every segment  .  .
length  least .  furthermore  intersection.
  segment   ball   length  least.
. therefore,  number  charges  , .
.
. .
. .,.
. . . . . . .
.
 total number  charges  cases .  . .
.
.
corollary . given  c-packed curve .  .
edges   graph   . edges  ,  algorithm approxdecider.,, ., 
.   algorithm.
fuzzydecider.,, ., 
. take time .
. . .
 . .
. log.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . . 
.-approximation algorithm. critical.
values   values  .  .,    structure  .simpl., ., . might change  allow .
disallow  map monotonic path.    used .
guide  search   fre.chet distance, since  optimal value   coincide  one  .  .
three types  critical values. . vertex-edge critical.
values, . monotonicity critical values,  . simpli.cation critical values. vertex-edge critical values .
simply  distances  vertices  edges, monotonicity critical values   values  .   .
map monotonic path opens    free space, .
simpli.cation critical values   values  . .
simpl., . changes.  note   simpli.cation.
critical values   subset   pairwise distances .
 points.   bound  monotonicity critical values,.
. shows  following important lemma.
lemma .     monotonicity critical value.
,  exists  number    . .  . .
   either  distance  vertices   vertexedge critical value.
 also note  approximate distance selection.
algorithm used  .
lemma . given  set    points,     set.
  pairwise distances. ,    algorithm.
approxdistances. .   compute  . log .
time  set   . numbers      . ,.
 exists numbers , . .     .  . . .
.
 resulting algorithm   described  follows.
algorithm . require. polygonal curve ., embedded graph  . .,.  straight line segment.
edges, 
 . .
ensure.  . 
. approximation  min.  ., .
 returned.
.   . approxdistances. . .  .
. use approxdecider.,, ., .  perform binary.
search    either return  . approximation .
.  interval ., .  min.  ., . lies. .
 returns  . approximation .,  ., . . ., .
.  . . . .
.     vertex-edge critical values .
simpl., .   less   equal  .
. use decider.simpl., ., , .  perform binary.
search    .  interval ., .   .
contain  simpli.cation critical value  vertexedge critical value.
.  decider.simpl., ., , . .
. . . . . .
. else.
. . . . . .
. end .
. . . . .   .-approximation.
. end .
.  . . . . 
. .
. . . . . .
.  . . . .   . ., ., .
. 
. . . .
.  least doubles  .
iteration.
.  fuzzydecider.,, ., 
. returns.
min.  ., . . . . 
. .
. . . .
. else  fuzzydecider.,, ., 
. returns.
min.  ., . . . . 
. .
. ., . . ., .
. else.
. . . .
. end .
. end .
. return .
 lemma ., line . takes time . . log.
. since    size . . ., line . takes . .
. . . log. log. . . time,  corollary .
 line .  true,     simpli.cation critical value  ., .,  otherwise lemma .
  contradicted. therefore, simpl., . .
simpl., ., ,  lemma ., line . takes . .
.simpl., ., . log. . . log.
time  lines .  .    running time.
 line . line . .nds  interval ., .   .
contain  simpli.cation critical value   vertexedge critical value.  lemma .,  monotonicity.
critical points  ., .  either  ., .  ., .
 therefore either .  .   .-approximation .
min.  .simpl., ., .  line .  .  add .
 ensure  . . min.  ., .  argue .
. . . . .min.
.
 .simpl., ., .
. . . .min.
.
 ., . . .
. .min.
.
 ., .
since  fre.chet distance   curve   .simpli.cation    .   know .
. . min.  ., . therefore,   end .
line .,    interval ., .  contains.
min.  ., .    .   .-approximation.
 min.  ., . therefore,    loop, .
 initially   .  hence     .
.log.
. iterations   loop will terminate.  .
 .cult  see   end  .   . . 
.approximation.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 bound  running time,  observe   .
.
.
.
.
. . .simpl., 
., . log.
.
 
.   value  
.
.   ith iteration. .
lemma .,.
.simpl., 
., . . .
. . .
.,.
 since .
. increases exponentially  ,  .
summation term   least linear  .
.,.
 . .
. . .
. log.
dominates  sum     last iteration. .
 easy  check  
. . .
   constant .,.
 therefore,   summarize  runtime  .
following theorem.
theorem . given  c-packed polygonal curve .
complexity    .-low density graph    vertices.
 . edges  ,   parameter 
 . ., one.
 . 
.-approximate  min.  ., .  .
. log. . . . . . . log. log. . . . .
 .
.
. log. time.
. implementation  experiments.
. implementation.  implemented  algorithm  . using   . standard library  hence  code  portable  compiles.
 multiple platforms.  initial implementation.
followed algorithm . faithfully.  implemented.
approxdistances using  well separated pairs decomposition.  implementation followed . original fair.
split tree based approach. however, preliminary experiments showed  .   computation time.
 spent   approximate distance computations,.
  real world data sets  bounded spread,  .
  .cult problem  guess  values. therefore,  replaced lines .  .   heuristic  guess.
 .-approximation. since  data   real world.
data sets,  gps traces never map directly  .
maps,  hence  distances   vertices  .
traces   vertices   map  positive. therefore,  .rst  .   distance   .rst vertex.
  trace   closest vertex   map. ,.
 doubled .  approxdecider.,, ., 
. returned.
min.  ., . . .   fashion,  obtained .
.-approximation   rest   algorithm  implemented  written.
. results. previous implementations  .strong.
fre.chet map matching required several hours  match.
one trajectory   large real world map . therefore,    able  compare  performance .
 algorithm  previous java implementations .
weak fre.chet map matching.  testing platform .
 algorithm   dell precision .   . ghz.
pentium   .  ram running linux  .
testing platform   weak fre.chet matching  .
 computer  running windows.  general, differences  performance may  due   implementation language  platform,  without heavy paging.
   speci. problem,   reasonable  assume  running times .ering  several orders .
magnitude provide evidence  .erences   .
algorithms  perform.
 performed experiments  two data sets, one.
 berlin, germany,     athens,.
greece.  data   subset   data collected.
 used   study  pfoser  . . .
berlin road map  .,. vertices  .,. edges.
  athens road map  .,. vertices .
.,.,. edges.  gps traces  collected  .
 consists  . traces  taxi .eets  berlin.
 . traces  delivery trucks  athens. .
typical sampling rate  .,   determined .
 communication frequency   .eet management.
system.
 table shows  results   comparison.
 implementation   weak fre.chet distance .
 version designed   fast  practice,  hence.
included parameters  allowed  algorithm  cut.
 input curve  shorter pieces  various reasons.
 example,   matched fre.chet distance gets.
 large,  algorithm assumes     outlier.
  vertices  pruned.  parameter  called.
dist threshold   table. furthermore,   time.
distance  two consecutive vertices gets  large,.
 algorithm cuts  curve  shorter pieces .
   make sense  assume   curve .
 vertices   comparable   line segment.
 parameter  called time .   table.
 general,  algorithms performed much slower.
  athens dataset,   traces  much .
noisy   road map used   account  .
construction boom  athens,  hence many roads.
  contained   map.  inaccuracy  .
data resulted   algorithms considering  much.
larger portion   maps  otherwise necessary.
  see  .ect     number  pieces.
 weak fre.chet implementation split  input curve.
.  algorithm     optimizations.
implemented,  still manages   comparable .
performance   weak fre.chet algorithm.  .
weak fre.chet algorithm   curve cutting turned .
copyright . .  siam .
unauthorized reproduction  prohibited.
table . comparison  weak fre.chet map matching algorithms  .   unable    comparison.
  previous algorithm  .strong. fre.chet map matching     able  match traces  .
reasonable amount  time.
 distance threshold,  new algorithm  much faster.
 hypothesize   running times  improve.
even    optimizations  implemented.
. conclusion  future work.
 work provides evidence   simpli.cation approach  .  result  dramatically faster running.
times  practice. map matching  practice often .
much larger input data    simply comparing.
curves,  hence  performance  algorithms becomes much  important.  extension  .
algorithm  map matching   resolves one  .
open problems posed   paper,  also provides .
task    simpli.cation approach  turn .
previously impractical problem  something  .
 solved  less   second.
 current implementation also   .
 </doc>
<doc title='alx11_09_eisnerj.txt'>
algorithms  matching  predicting trajectories.
jochen eisner. stefan funke. andre herbst. andreas spillner. sabine storandt.
abstract.
 consider  following two problems. map matching.
given  sequence  .imprecise. location measurements.
  mobile user moving   road network, determine.
  likely path   network  user .
travelled along. prediction  trajectories. given .
path    mobile user  moved along   road.
network   now, predict   will travel along.
  near future.
 map matching algorithm  simple  efficient.
even  case   imprecise measurements like gsmlocalizations  allows   real-time tracking  .
large number  mobile users  modest hardware. .
proposed path prediction algorithm  equally simple.
 yields extremely accurate predictions    low.
computational cost.
. introduction.
nowadays, almost every cell phone  equipped .
gps   least allows  localization derived .
nearby cell phone base stations.  gives rise .
 plethora  exciting applications  well  research.
questions.
  application point  view, often  .
 interested  higher level location information like.
   mobile user moved along   road.
network. rather   pair  coordinates specifying.
 position  longitude  latitude.  generation.
  higher level location information becomes even.
 challenging   location measurements .
imprecise. gps .  non-military context. typically.
incurs imprecisions   range  several meters. .
gps   available,  example due  obstructions.
 tall buildings   urban environment  foliage,.
localization derived  nearby cell phone base stations.
allows  location measurements   uncertainty .
several hundred meters   kilometers.
  first part   paper  consider .
.universita. stuttgart, institut . formale methoden.
der informatik, . stuttgart, germany. jochen.eisner,.
stefan.funke,sabine.storandt.fmi.uni-stuttgart.
.universita. greifswald, institut . mathematik und informatik, . greifswald, germany.
andre.herbst,andreas.spillner.uni-greifswald.
map matching problem,  , given  sequence .
.imprecise. location measurements   mobile user .
 underlying road network, compute  reasonable route.
  user  traveled along .   words .
aim  matching  discretized  fuzzy trajectory  .
route   road network.   particularly concerned.
  scenario   location measurements .
 imprecise .imprecision    kilometers., since.
  still numerous situations   precise.
location information   available    .
acquired  high cost.
  second part   paper  aim  even.
higher level position information. given  path .
mobile user  moved along   road network   .
current moment, predict   user will move along.
  near future.  call   path prediction.
problem.  contrast  known solutions   problem.
 will compute  prediction   based  .
geometry   known path .using extrapolation. .
directional information implied   underlying road.
network  make explicit use   structure  .
space  shortest paths   network.
    make  assumption   .typical.
behavior   mobile user,   little hope  effective.
map matching  path prediction schemes. , .
example,  mobile user  every crossing chooses .
arbitrary turning,  good guess   actual route.
 user took based  measurements  several.
kilometers  imprecision seems difficult.  appears.
even  challenging  make  educated guess .
  user will   . minutes  nothing  known.
  behavior.    proposed algorithms will.
 based   assumption  users travel  . least.
piecewise. shortest.quickest paths.  seems like .
natural assumption  make since  people tend .
travel   aim  getting   certain destination.
 quickly  possible.   little hope   able.
 track  predict people cruising around unless .
additional information  known.
related work  many applications, map matching.
  online problem,  , location measurements.
   aligned   road map  soon  .
 taken .see . .     version  .
problem.  contrast,   focus  .ine map.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
matching,  ,   sequence  location measurements taken along  route  want  reconstruct .
route. ,  least  principle,  algorithm .
online map matching  also  used  .ine map.
matching,  low accuracy   reconstructed route.
   problem .see . . existing approaches.
 solving  .ine problem directly involve  scoring.
 routes   road network reflecting  well .
sequence  measurements fits   route.  scoring.
  based  .  fre.chet distance . variants.
 . ., .   weighting  road segments according .
 relative position  respect   location measurements .  reconstruct  route often  heuristic.
search   route  optimal score  performed .
see also .   optimal route  found exactly .
integer programming. recently,  .  novel scheme.
 .ine map matching  presented especially designed.
 situations   density  measurements along.
 route  small   level  imprecision  .
measurements    . meters.  will   .
detail   approach  section .
 related work  respect  path prediction.
   aware    found   context.
 dead-reckoning protocols.   mobile user .
 send periodically  position   server. .
 required bandwidth  transmitting  position.
information   issue, predicting  motion  .
user    client.user side  well   .
server side  result  considerable savings  .
transmitting deviations   prediction. different.
kinds  prediction schemes   examined  .
context. linear prediction assumes   mobile user.
keeps  moving along  line given   reported.
position  direction.  already yields quite good.
results.   advanced higher-order prediction.
uses higher-order functions .curves  splines. ,.
 example,  capture  object. movements  .
curved road segment. different   strategies.
 essentially work   open space, map-based.
prediction strategies make use   fact  mobile.
users  often moving along  road network,   person.
walking along  streets   city   car travelling  .
freeway.  map-based prediction strategy tries  match.
 user. position   road   underlying map .
assumes   keeps  moving along  street. .
 intersection  strategy tries  choose  direction.
 mobile user   likely  follow. . gives .
detailed survey  summary   main advantages.
 disadvantages   approaches.  mapbased prediction strategy    now  efficient.
prediction strategy will  used   baseline  .
measure  new prediction algorithms  section .
 contribution  provide simple  sound solutions    map matching  well   path.
prediction problem.   map matching problem .
proposed algorithm yields running times   much.
faster  previous approaches.    speed-up.
 matching techniques become applicable  dealing  large imprecisions   tracking large numbers  mobile users.   single mobile user  new.
measurement   processed   milliseconds, .
 measurements  taken every  minutes, several.
hundreds  thousands  mobile users   tracked.
  single multi-core server.  making use  .
structure   use patterns   road networks, .
path prediction algorithm allows  faithful prediction.
 trajectories   several hundred kilometers outperforming known prediction strategies  terms  quality.
 computational effort   little   large scale.
prediction  mobile users  also possible.
. preliminaries.
. formal problem definitions  road network.
  edge-weighted directed graph  . .,, . whose.
vertices  mapped  pairs  coordinates .usually.
longitude  latitude.  length .   edge .
  road network  often simply  distance .
 end points     also represent  .costs.
  travel time.  location measurement   triple.
., , . consisting  longitude  latitude coordinates.
  , respectively,   radius .  ,  model.
 measurement   circle   degree  uncertainty.
  true location   time  measurement, also.
referred   imprecision,  captured   radius .
 circle.
 input   map matching problem consists.
  road network  . .,, .   sequence.
 . .,., . . . ,  location measurements .
  taken  traveling along  path  .
., ., . . . ,   ,  ,  sequence  vertices .
    edge directed  .     .
  . ., . . . , .    want  reconstruct ,.
 , find  path . . ., ., . . . , .     close.
 , see figure .   simple problem instance.
 input   problem  predicting trajectories.
  road network  . .,, .   prefix  .
., ., . . . ,      path .
. . ., ., ., . . . ,   .
 goal   predict .     known.  , .
want  compute  path . . ., ., . . . , , ., . . . , .
 , see figure .
. quality metrics   problems  want .
quantify  close  reconstructed.predicted path .
   .true. path , . respectively.  adopt .
two accuracy metrics also used  .  ratio  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
total number  ., .
.   total length ., .
 edges       recovered correctly .
.   number  edges   length, respectively,.
 .
. performance metrics  proposed algorithms   based  variants  dijkstra-like graph.
traversals.   ordinary dijkstra,  running time.
 essentially determined   number  dijkstra operations .polls   priority queue. furthermore,.
 underlying graph representation,  implementation language   hardware    algorithms  run crucially influence  experienced running times.  example,  reasonable . implementation   standard desktop  allows   . million dijkstra operations per second.  easier platformand implementation-independent comparison  mostly.
state  running times   algorithms  terms  dijkstra operations.
. contraction hierarchies . one important ingredient  ensure  efficiency   mapmatching algorithm   general technique  speed-up.
shortest path computations.   many speed-up.
schemes like reach ., highway hierarchies .,  transit nodes .  chose   implementation contraction hierarchies . due   simplicity  efficiency.
  contraction hierarchy augments  given road.
network  . .,, .   road network . . .,., .
 adding new directed edges   based   ordering . . ., ., . . . ,    vertices  . essentially.
 vertices  contracted   order  edges .
added   shortest-path distances   remaining network  preserved.
shortest path queries      answered.
 efficiently based   fact   .  exists.
 shortest path   pair  vertices ., .  .
 indices   vertices   shortest path .
monotonously increasing first  decreasing afterwards.
 respect   ordering . therefore,  identify.
 shortest path    ,  bidirectional dijkstra.
algorithm   adopted.  precisely, one  use.
one dijkstra run .forward. starting     second.
dijkstra run .backward. starting  .  forward run.
considers  outgoing edges  lead   vertex.
  larger index   backward run considers.
 incoming edges  come   vertex .
larger index.  two runs   meet   least one.
vertex   shortest path, thus computing  shortest.
path       drastically reduced search space.
thus, one-to-one shortest path queries   answered.
  fraction . .   time   full.
dijkstra   help   augmented . . .,., .
figure .  map matching problem.  .
given  sequence  . . imprecise location.
measurements  want  reconstruct  original .red. path.
figure .  path prediction problem.  .
given  route  mobile user  travelled .
 now  want  predict  route   near.
future.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
  approach   map matching problem,.
however, one-to-many queries play  important role.
. section .  major drawback  using chs.
directly    every target node  new dijkstra.
   started. therefore,  total query time.
might  even worse  just  simple dijkstra  .
original graph  stops   target nodes .
 settled.   remedy,  technique suggested .
batz  .  .   context  time-dependent chs,.
  used.  time-dependent edge costs,  backward.
dijkstra seems difficult,   exact arrival time .
unknown.  batz  . replace  backward dijkstra.
run   breadth first search .bfs., marking  .
step  incoming edges  come   vertex .
larger index.   forward dijkstra run   used.
  slight modification,   edge  considered.
  leads   vertex  larger index   marked. ,.
 edges   marked  performing  bfs .
 set  target vertices, shortest paths   source.
  target vertices   found using one forward.
dijkstra run   targets  settled.  creates .
fair compromise  thinning   search space.
 still  able  settle  target nodes  .
. reach-type edge classification   .
path prediction strategies make use   concept.
 edge reach,  will  explained briefly  .
following.
 observation   travelling long distance,.
one typically uses small roads    vicinity  .
start   destination   trip  .important.
roads  ,  long  used  heuristically.
speed-up  dijkstra search   considering .small.
roads   search   far   start .
destination. relying   given road classification.
.freeway, highway, local road, track, . . . .   search.
  shortest path   guarantee optimality  .
computed path, though. gutman  .   first.
 formalize  idea .    vertices instead.
 edges,   idea remains  . one defines.
 edge .  vertex.   important . high reach.
  lies   middle   long shortest path,  .
formally,   edge  . ., .
reach., . . max.
.,. .
min ., ., ., .
 , maximized   shortest paths  .
contain ., .  essentially take  minimum distance.
  edge  either end    reach.    clear.
whether  reach value   computed efficiently.
.without considering . shortest paths.,  upper.
bounds  computed  quickly.
 computation  dijkstra   accelerated.
using  idea  follows.  dijkstra considers.
 outgoing edge  . ., .   lower bound.
.   distance     final target .
known,  edges  reach . min., . need.
  considered.  idea, together  .
ingredients like edge contractions  led  query times.
    factor  . faster  ordinary.
dijkstra. goldberg  . .  sanders.schulte .
 incarnations   idea,   latter .
interesting   uses  different metric .  one.
defined   edge costs.  determine  . .
middle. means.
 will make use   edge reach concept  .
path prediction strategies.
.  map matching problem.
 ,  ., . . . ,   .ordered. sequence .
location measurements.  will  convenient  view.
    disk   center   radius  .
  reasonable  assume   true location .
measurement   taken lies inside  . example .
 sequence   disks  depicted  figure . thus,.
without  additional assumptions  points.vertices.
  road network inside   candidate points, .
,    location  measurement  .
taken.
figure . shortest path .red. together   sequence.
 disks  representing  imprecise location measurement taken along  path.
. previous approaches used  benchmarking one   conceptually simplest approaches .
map matching, also known  point-to-point matching.
., selects   measurement   vertex . point.
  edge.   road network  . .,. .
 minimum distance   point    concopyright . .  siam .
unauthorized reproduction  prohibited.
.
. .
.
. .  .
figure . .  disk associated   location measurement .  vertices drawn  black dots form.
candidate points associated  . . part   layered graph formed   candidate points.  red.
directed edges correspond  part   reconstructed.
route.
nects consecutive vertices.points  shortest paths .
 road network.     hard  find examples.
  approach will reconstruct  route  .
poorly,    fast   will use    benchmark.
  run time   new method.
 also provide  benchmark   run time.
  sophisticated recent approaches  reimplemented  one presented  .   reconstruction   route  based   layered graph.  .
graph  layer corresponds   candidate points associated   particular measurement. directed edges.
connect candidate points  consecutive layers. .
length    edge results   length  .
shortest path   candidate points   road.
network. concatenating  shortest paths, selected.
according   scoring function, yields  reconstructed route . figure .
 reported  .,   approach   practically feasible  restriction   small number  candidate points within  disk   crucial, since otherwise  run time increases dramatically.  discard.
vertices  edges inside   candidates, assumptions.
  distribution   errors involved  .
measurement    time stamps attached  .
 used.   following  present  simple observation  allows  avoid  discarding  vertices .
edges inside    explicit construction   layered graph altogether ,    time, speeding.
  computation  exploiting directly  fact .
travelers tend  use shortest paths.
.  new approach   , . .  . , denote.
 vertices contained   . introduce  new vertex.
.  directed edges,   length .,  . .
 vertex  . assume   already constructed.
shortest paths piv  .   vertex  .   .
. .  .      shortest paths visits .
disksd., ., . . . , .   order. note    . .
.
.
.
.
 .
figure .   vertex  . .  compute .
shortest path    .  yields  path .
.
.
.red.
 paths  available immediately  construction.
now,  compute shortest paths  .  .
vertex  .  visit  disks ., ., . . . ,  .
 order,    hard  see   amounts .
extending  shortest paths  already   .
  vertices  .  specifically . figure ., .
 . .  introduce  new vertex   directed edges.
    vertex  .  addition,  length.
  edge       length  piv  every.
 . .   compute shortest paths   .
 vertex  . ., denoting  .  path .
vertex  removed.    . . consider  first.
node  .    shortest path .   obtain.
 suitable shortest path piu  .    visits.
 disks ., ., . . . ,    order  concatenating.
 paths piv  .
.
. ,  mentioned  section .,.
 reconstruction   path along   location.
measurements  taken   reduced   sequence.
 one-to-many shortest path queries.
. computational experiments    hard .
see   approach outlined  section . will yield.
  reconstructed path .   breaking .
ties   computation.   approach presented.
 .   vertices  edges contained  .
    discarded.  demonstrate  .
run time  still feasible,  performed  range .
experiments  simulated input data.  underlying.
road network  used   map  germany obtained.
 openstreetmap. containing . million vertices.
 . million edges.  diameter   network.
 . .   network  took  shortest.
path  length .  two fixed vertices .
 base path, generated measurement disks  random.
 bounded radius  distance . consecutive.
disks.  particular,  investigated  impact .
different average sizes  disks .corresponding  gps.
.http.download.geofabrik.osm.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
precision gps gps.
sampling rate . .km-.
point-.-point . .
new . .
new. . .
precision gsm gsm.
sampling rate .km-. .km-.
point-.-point . .
new . .
new. . .
table . comparison   total number  dijkstra.
operations  three map matching methods. point-topoint matching,  new approach without using chs,.
 new approach using chs.  table entries .
averaged  . simulated location measurement sequences along  path  length .  columns.
correspond  different levels  imprecision .gps .
gsm.  different average distances  consecutive measurements.
.  .  gsm .  . measurements.
  different average distances  consecutive.
disks .varying  . meters  . kilometers.
 results   experiments  summarized .
table .    seen   table,  use .
contraction hierarchies drastically reduces  number.
 dijkstra operations ,  gps-sized measurement.
imprecisions even outperforms  simple point-to-point.
matching approach. unfortunately,    able.
 finish   set  experiments also   reimplementation   approach presented  . due .
excessive run times.  give  impression.  average.
number  dijkstra operations  . even  gpssized measurement imprecision  .km-. distance.
 consecutive measurements.
  approach,  total effort one needs .
spend  matching  . long route     million .gsm localization. .hundred thousand .gps localization. dijkstra operations .  seconds.fraction .
 second actual running time   state-of-the-art cpu.
core.  cars move   .,   match.
several thousand .gsm.  several tens  thousands.
.gps. cars   single cpu core.  sub-.k-usd compute server  . cores  hence easily match .
track hundreds  thousands .gsm.  even millions.
.gps.  vehicles  real-time.
  second set  experiments  investigated .
 impact  several parameters   reconstruction.
accuracy   approach.  used . different base.
paths .respectively two  short . ., middle .
.  long . . length. first  investigated.
 impact  different average sizes  disks .corresponding  gps .  .  gsm .  .
measurements.   different average distances  consecutive disks .varying  . meters .
. kilometers.   base path   combination  parameters . average size  disk  average.
distance  consecutive disks.  generated .
random sequences  measurements.   example, .
display  figure .  histogram  distances  .
 base path   reconstructed path   long base.
path, gps-sized measurement imprecisions  average.
distance  consecutive disks  . meters.  results obtained   combinations  parameters .
using  metric  instead    similar. even.
 gsm-sized measurements imprecisions   reconstruct  .  .   base path, see.
figure .
figure .  histogram approximates  distribution   distance   base path   reconstructed path  sequences  measurements generated randomly along  base path.  generate .
histogram . simulated sequences  measurements.
 used   range ., .   metric   divided  sub-intervals  length .  used  path.
 length ., gps-sized measurement imprecisions.
  average distance  consecutive measurements  .
  additional experiment  investigated .
impact   deviation   base path  .
 shortest path  two vertices   network.
  reconstruction accuracy.   end,  base.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
figure .  histogram approximating  distribution .
 distance   base path   reconstructed.
path  gsm-sized measurement imprecisions. length.
  base path  distance  consecutive.
measurements      figure . note  .
 histogram  range   metric   divided.
 sub-intervals  length .
path  chosen    concatenation  five shortest.
paths. along  path  simulated . sequences .
measurements.  shown  figure .,  reconstruction.
accuracy slightly decreases compared  figure ., .
   single shortest path,  stays  .
. prediction  trajectories.
recall  problem definition   problem  predicting trajectories   road network  . .,.  .
given path  . ., ., . . . ,     want  predict.
  continues  ,  ,  want  compute  path . . ., ., . . . , , ., . . . ,   .  .
  hope  good predictions   computed.
typically, people try   waste time  move .
least partially  shortest  quickest paths.   .
 observation  allows   come    prediction  .  start   assumption  people.
 moving   path     shortest path .
      later also consider paths  .
 overall shortest  piecewise shortest-paths,  .
 realistically models  case    way back.
home  work one drops   butcher,  bank .
 bakery.
figure .  histogram approximating  distribution.
  distance   base path formed  concatenating five shortest paths   reconstructed path.
 gps-sized measurement imprecisions.   used.
. randomly generated measurement sequences along.
 base path. note    histogram  range.
  metric   divided  sub-intervals  length.
.
. quality metrics  measuring  performance   proposed prediction strategies  generate random .partially. shortest paths  . ., ., . . . , .
 provide  partial path . . ., ., . . . ,   .
. .  .   input   respective prediction  .
 prediction error will result   mismatch   node.
.     proposed .
.
.   predictor.
  turns ,  error rate   depends.
  choice   prediction strategy  also .
 relative position   .  ratio    .
  natural, since near  end   path,  final.
destination   essentially around . corner. .
measurements    common   large number.
 random paths ,  may obey  limitations,.
 drawn   intention  evaluating  strategy.
  .average. path  .
 expected distance  failure metric uses paths.
   length  maps  quantized relative.
position   path  percent .  . .   expected.
distance   next prediction error along  .
standard deviation.    know  relative.
position   concrete path  use  specific prediction.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
strategy,  metric will tell   long  correctly.
predicted path fragment   expect   position.
 superior strategy naturally exhibits larger distances,.
 fact  optimum value   remaining path length.
therefore  value converges  zero   end  .
path.
 absolute number  errors metric uses  .
quantized relative path position  maps  absolute.
number  prediction errors  occurred  .
relative path point.  superior strategy will  .
exhibit  smaller overall sum   values  different.
strategies also result  different profiles along  path.
note   strategies implicitly assume .
ground truth    path  infinite length,  .
error rate   second half  likely   higher.
 mentioned , though,   natural   .
hard.impossible  make  educated guess  .
future path   close   final destination .
   around  corner.
. strategies  categorize  proposed strategies  two main classes, according   limitations.
   obey  query time.
.ine strategies may employ extensive precomputation   stored precomputation data  restricted.
  linear space bound  regard   size  .
graph.  query time,  .ine strategy  allowed .
spend time proportional   maximum degree  .
graph.  particular, .ine strategies   allowed.
 start complex graph explorations.
online strategies    hand   obey.
  precomputation  storage limitations .
.ine strategies   allowed  perform extensive.
computations  query time,  particular .partial.
dijkstra computations  allowed.
 make  distinction  differentiate .
algorithms   potentially  employed  .
simplest mobile devices    require  least.
 computing power  query time.
  description   employed strategies assume   choose  path  .
., . . . , ., , ., . . . ,    intention .
predicting .,   prediction strategy  given.
. . ., . . . , .,   input . .ine strategy .
given  constant-sized suffix thereof. observe  .
prediction  degree . nodes  trivial   context.
nodes  degree .  therefore ignored.
  point  task  predicting  path trajectory.
breaks    question  estimating  one.
outgoing edge    think     likely.
one  continue  path.
. .ine strategies  .,   straightforward strategy .   refer   baseline strategy.
. . .  proposed.  coming  vertex .
     pick  next edge.vertex  outgoing.
edge  ,.
.
viv.
.
.  minimal change  direction.
compared  . clearly,    .ine strategy.
according   categorization.  intuition behind.
 strategy   shortest.quickest paths tend  .
rather straight.
 slightly  involved strategy   refer.
  simple dijkstra . . works  follows.  .
precomputation step  compute  full dijkstra .
 vertex    network  remember  .
outgoing edge    large  subtree . terms  . .
nodes.  hanging   edge. clearly   .
time consuming  requires  linear space.  query.
time,    node   choose  outgoing edge.
 leading  .  bears  largest subtree .
 shortest path tree  . conceptually   close.
 choosing  edge   likely  target chosen.
uniformly  random   shortest path subtree resides.
 reduce  enormous computational cost .even.
though    easily parallelized  computed .
  days   small cluster also  large networks like.
    whole  europe.,   slightly modify.
 precomputation step  start  unidirectional.
reach-.-based dijkstra  every  .   order.
 outgoing edges   according   longest path.
discovered   searches.  reduces .
precomputation time  orders  magnitudes without.
really affecting  quality   prediction   will.
see.   employed  reach-based search,  refer .
 strategy  simple reach based dijkstra . rbd.
  strategy turned    essentially equal .
 ,   omitted  latter   experiments.
  precomputation time,     range .
  milliseconds per vertex .  standard , .
including  precomputation time   reach .
 information .,  even large networks  .
preprocessed    hours.
 introduced  reach concept, another obvious strategy   simply return  edge  highest reach .see section .    lead back .
.   call  reach based strategy . . intuitively, high reach means important edge whereas low.
reach means unimportant edge.
. online strategies   assumption .
 ground truth path    shortest path  .
  random ,  arguably optimal strategy constructs  shortest path tree . dijkstra. starting  .
  point  time,  known path segment ., . . . , .
 part   shortest path tree,     randomly.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
chosen, picking  outgoing edge    contains.
  nodes   subtree   optimal prediction.
strategy.  call   full dijkstra . . strategy.
apart   quite demanding computationally .
query time . full dijkstra computation.,  strategy.
breaks    path     shortest path  consists  piecewise shortest paths  . think  stopping.
  bakery,  grocery,   butcher   way.
home  work.
 cope   problem,  need  detect .
 path ., . . . ,  leaves  shortest path tree rooted.
  . .   happens  ,  start  dijkstra.
. .
 exhibiting  longest suffix  ., . . . ,    .
reverse order.  subpath   shortest path tree rooted.
 .  , ., . . . ,    suffix .note  .
 abort dijkstra    settled .   different.
subtree   shortest path tree.   start .
.full. dijkstra    use   prediction.  call.
 strategy lazy full dijkstra . lfd. due  space.
restrictions   still somewhat high computational.
demand  query time,  will  report results  .
   following variant thereof.
similar   heuristic .ine strategy  simply.
replace  full dijkstra computation   reach-based.
dijkstra computation  prunes   edges .
increasing distance   source.   long .
 move   path   shortest-path tree  .
reach-based dijkstra started  .,  always pick .
edge leading   .furthest. node.   leave .
shortest path-tree    start  backward reach-based.
dijkstra starting    exhibit  suffix , . . . ,  .
  use  reach-based dijkstra rooted   .
  prediction.  next time  leave .
shortest path tree,   start  search   .
suffix.  strategy .   call lazy reach-based.
dijkstra . lrbd. . allows   adaptivity  case.
 piecewise shortest paths  well  good running.
times due   heavy pruning  edges   dijkstra.
computation.
. results.
quality  two test graphs  based  openstreetmap. data   stripped   features impassable  car.   two resulting graphs  .
 . vertices respectively,  computed  reach.
  edges based   travel time metric  proposed .
.   extensive meta data   osm dataset.
 picked  street type  derive  speeds  individual edges.  larger graph .ger. represents  street.
.  graph  asymmetric edge costs,  run  dijkstra.
  reversed graph.
.http.download.geofabrik.osm.
map  germany,  smaller one .   federal.
state mecklenburg-vorpommern. due   fact .
part   osm data  generated  gps plots, .
road segment  composed   larger amount  degree.
two nodes.  average chain length  . segments.
 .  .  .ger.  corresponds  .
average length  less  one kilometer.  direct.
result .   graphs nodes   degree .
  expected distance  failure metric .
random shortest paths   sampled   length.
 limited   interval  .  . .  .
case  .  . .   case .ger. .
  metric  lower bound  . nodes resulted.
 minimal path lengths  . ,   limited.
upwards   respective graphs diameter  .
 .  .   .ger.
 figure .  absolute number  errors metric.
 employed  . random shortest paths  .
 . random shortest paths  .ger. common .
 strategies .   on-  .ine .   fact .
close   start   end,  prediction quality .
pretty bad,     expected. furthermore .
 surprise. . online strategies  far  accurate.
 .ine strategies. amongst  .ine strategies,.
 baseline predictor . .fares worst   first half,.
leading   total prediction failure rate  . .
.ger.,  ,  .   nodes   path .
degree larger  .  prediction error  occurred.
employing  reach-based dijkstra strategy . rbd.
 obtain much better results   beginning  .
paths  getting worse towards  end, resulting .
 . failure rate overall.  purely reach based.
strategy   uniformly exhibits better performance.
  baseline strategy  except   beginning.
also   rbd,  total failure rate  .  .
natural  combine  purely reach-based strategy .
 reach-based dijkstra strategy   best .ine.
prediction rate. unfortunately,     clear  priori.
 one gets better   .  case  . .
point   around .   path length,  .ger.
  around .   tuning   able .
find mixing parameters    prediction failure.
rate    mixed .ine strategy became .
 online prediction strategies perform much better. given    working  single shortest.
paths ,  full dijkstra strategy . . yields .
almost perfect result   total failure rate  .
.   practical lazy reach-based dijkstra strategy   much worse   total failure rate  .
 general,  results  .  .ger.  comparable.
finally  consider  expected distance .
failure metric,   arguably   intuitive one,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.
.lrbd.
.
.rbd.
. absolute amount  prediction errors   respective relative.
position   path  , sampled  . paths.
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.
.lrbd.
.
.rbd.
. absolute amount  prediction errors   respective relative.
position   path  ger, sampled  . paths.
figure . absolute number  errors metric.  fig.
. . random paths  . graph  sampled.
accordingly . paths   .ger. graph  fig. .
 figure .   strategy   depicted .
expected length   correctly predicted path chunk.
    certain relative position, comparing .
two online strategies   baseline strategy  .
simple reach-based dijkstra .ine strategy.   clear.
  online strategies  far superior   baseline.
strategy.   metric  choice   underlying.
road network makes  bigger difference.  online.
strategies  gaining  significant amount  accuracy.
  .ger. graph,   point   average.
distance   next prediction error  always  .
.   remaining path length, compared  .
  . graph.  contrast  ,  baseline.
strategy. average prediction distance  always .
.   .   .ger. graph compared  . .
 .   . graph.   reach-based .ine.
strategy performs slightly better   still way .
 online strategies.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.lrbd.
.
.
. . sampled paths  . length  .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.lrbd.
.
.
. . sampled paths  . length  .ger.
figure .  expected distance  failure metric.
 limited   remaining path length.  full.
dijkstra strategy shows nearly optimal results.
 real-world scenarios,  trajectories  mobile.
users  often  exact shortest s-t-paths  .
tend   composed  several shortest-path segments.
. work   bakery,    butcher, .
  florist  driving home.  figure . .
present results   problem instances constructing.
 series  .  shortest path pieces.
resulting   overall length  . .  lazy reachbased dijkstra approaches   baseline approach.
 producing characteristic profiles along  shortest.
path piece  limited   distance   actual.
piece ending,    latter approach  far.
inferior  absolute performance.  full dijkstra.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
approach   contrary completely fails  produce.
reliable predictions behind  first shortest path piece.
  available shortest path information  . .
meaningless   .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .
.
.lrbd.
.
limit.
figure . expected distance  failure metric.
 series  piecewise shortest paths   length .
. . . .  .limit. line plots.
 remaining length   actual shortest path.
cost   briefly review  cost  predicting.
trajectories  runtime.  focus   number .
dijkstra operations    determining  real-time.
applicability   algorithms.  count  total.
number  dijkstra operations   performed.
 running  prediction strategies   shortest.
path  . length.
strategy . dijkstra polls.
 offline strategies .
  . . .
 lrbd . . .
table . computational cost per path  different.
strategies  terms  dijkstra polls   .ger.
graph  prediction time. .ine strategies  spend.
constant time   dijkstra poll  runtime,  .
competitive online strategy   lrbd. average .
. random shortest paths  length . .
 good performance   lrbd  table . .
due  two reasons. first,  single reach-based dijkstra.
visits   small fraction   nodes compared.
  full dijkstra, furthermore,   prediction.
requests trigger  reach-based dijkstra computation.
 concretely, .   prediction requests  .
experiment   answered using  already existent.
shortest path tree.    remaining ., .
reach-based dijkstra    started, resulting  .
total number  polls  shown  table .
strategy  lrbd  total   whole path uses.
less  one tenth   dijkstra polls  .
necessary   full dijkstra   network .
equals  strategy     much worse  .
piecewise-shortest paths, though. ,   assume.
 car  drive   . . .  trip takes .
. hours.,  single core  perform predictions  .
 ten thousand vehicles    time. hence.
    expensive compute server  . say.
. cores,   easily predict trajectories  one.
million vehicles  real-time.
. extensions  far    considered .
problem  predicting  path.  natural extension .
 compute  mapping time. .,  , predict .
 time one expects  mobile user    .
position.    take  account  existing.
speed-limits   road segments   predicted route.
 well   observed driving speed within  known.
trajectory.
. applications, combinations  .
  community driven openstreetmap project.
 become  serious contender  provider  accurate road map data, commercial vendors like navtec.
 teleatlas still   edge   comes  higher.
level data like traffic flow  traffic density. acquisition   data  difficult, though,  requires either.
access  roadside equipment  traffic census  cooperations  mobile phone network providers. .
proposed map matching algorithm  simple enough .
widespread employment  cell phones  community.
members seems feasible .even  devices without gps.
allowing  large scale acquisition   traffic data.
one immediate application  path prediction.
methods    context  dead-reckoning protocols.
  mobile user   periodically send  position .
 server.   required bandwidth  transmission   issue, predicting  motion   user .
  client.user side  well   server side .
result  considerable savings   transmitting deviations   prediction   shown  . .
 improved prediction method,  savings  .
even  increased. navigation systems,  particular  ones built-in  car manufacturers,  become.
.always-on. devices,  even   target   given.
  user   route planning takes place,  acquire  current position. accurate path prediction.
routines allow  device  call attention  points .
interest  lie   predicted route. examples .
gas stations, restaurants, shopping malls, parking lots.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 also areas  difficult road conditions  traffic jams.
 combination  map matching  path prediction also makes  lot  sense,  particular  .
mobile device   equipped  gps.   given.
sequence  location measurements  map matching.
routine identifies  initial path,    continued.
via path prediction routines.  map matching .
 imprecise location information tends   inaccurate   first    last  measurements,.
one  discard  parts  employ  path prediction routines   remaining path fragment. .
   basis   rudimentary navigation system.
 works  based  gsm location data.
one apparent danger   fact  cell phone.
providers   help  map matching  path prediction techniques  access  massive amounts </doc>
<doc title='alx11_10_doerrb.txt'>
dependent randomized rounding.  bipartite case.
benjamin doerr. marvin .nnemann. magnus wahlstro.
abstract.
 analyze  two existing algorithms  generate.
dependent randomized roundings   bipartite edge.
weight rounding problem together  several newly.
proposed variants   algorithms.
   edge-based approach  gandhi,.
khuller, parthasarathy, srinivasan .focs . .
 bit-wise approach  doerr .stacs .  give .
simple derandomization .guaranteeing   rounding errors   randomized versions achieve  positive probability.
 experimental investigation  different types .
random instances show , contrary   randomized rounding problem  disjoint cardinality constraints,  bit-wise approach  faster   edgebased one,   latter still achieves  best rounding errors.  propose  hybrid approach ,  terms.
 running time, combines advantages   two previous approaches.  terms  rounding errors  seems .
fair compromise.   cases,  derandomized versions.
yield much better rounding errors   randomized.
ones.
 also test   algorithms compare  used.
 solve different broadcast scheduling problems . suggested  gandhi  . since  needs  random.
decisions  just   rounding process,  need .
partially re-prove previous results  simplify  corresponding algorithms  finally derive  derandomized.
version. ,  derandomized versions give significantly better approximations   randomized versions.
 tested  algorithms  data taken  .
wikipedia access log.   maximum throughput.
version   problem,  derandomized algorithms.
compute solutions    close   optimum.
  linear relaxation.   minimum average.
delay version, gandhi  . gave  ., .-bicriteria.
algorithm, .,  algorithm  produces  .-speed.
schedule   average delay   expectation.
.supported   german science foundation .dfg. via .
priority program .spp. . .algorithm engineering., grant .
.
.max-planck-institut . informatik, saarbru.cken, germany.
.universita. des saarlandes, saarbru.cken, germany.
  worse     .-speed optimum.  .
problem variant,   performance guarantee  .
algorithms certainly holds,  find   simple greedy.
heuristic generally produces superior solutions.
. introduction.
randomized rounding, introduced  raghavan .
thompson ., .  one   key primitives .
randomized algorithmics, see also . given  number.
 . ., . .    fractional part  .
arbitrary real number.,  call  binary random variable.
  randomized rounding  ,  . . . . .
algorithmically speaking,  round    one .
probability equal  .
 simple idea becomes  strong   .
many numbers   rounded.   . ., . .
    independent randomized rounding  .
. ,    randomized rounding  , mutually.
independent   .  ., . . . ,  . ., . .
weights.      way  rounding.
keep  expectation  weighted sums   variables.
unchanged,   .
.
 aiyi. .
.
 aixi,  .
addition so-called chernoff bounds show   high.
probability  actual value   weighted sum  close.
  expectation.  example,   . . .  .
.
.
.
aiyi .
.
.
aixi. . .
.
. . .
.
.
. dependent randomized rounding  last.
ten years saw  number  randomized rounding results.
  variables   rounded independently.
. ., ., ., ., ., ., .  ideas allow  better.
adapt  rounding procedure   particular problem.
one  interested .  course,  care    taken.
 chernoff-type large deviations bounds  needed, .
 often assume independence   variables.
 first step  use  ideas   find suitable.
methods  generate randomized roundings  satisfy certain dependencies, called hard constraints. .
 ground-breaking paper  srinivasan . provides .
method  generate randomized roundings  satisfy.
 global cardinality constraint,  ,  requirement.
  sum   numbers remains unchanged .assuming    integral   first place. naturally,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. easily extends  disjoint cardinality constraints.
  extended   bipartite edge weight rounding problem, described ,  gandhi  . ., .
 substantially different rounding method   settings,  given  ., .
theoretical analyses show similar results  .
approaches  many settings.  led  authors start.
analyzing  rounding methods   algorithm.
engineering view-point ., ., starting  disjoint.
cardinality constraints.  experimental results show.
quite clearly  generally  rounding errors .
soft constraints,   expressions like . aiyi .
 aixi.,  superior   derandomized versions .
 algorithms,   particular better   approach.
 srinivasan .,  derandomized   authors, .
  approach  doerr .  holds   terms.
 rounding errors  running time.
.  work   paper,  continue  line.
 research  regard randomized rounding  .
bipartite edge weight problem.   problem, defined.
properly   next section,   asked  round.
 weights   edges   bipartite graph, .
maintaining  total weight incident   vertex.
 thus  two sets  disjoint cardinality constraints,.
 means    interaction  .
constraints. many problems  assignment-type lead.
 constraints like , .,  broadcast scheduling.
problems regarded  gandhi  . .
 makes  experimental investigation interesting   bipartite edge weight rounding problem, .
 fact   best known theoretical analyses .
 two rounding algorithms give quite different running times.  stems   pessimistic assumption.
  analysis   algorithm  gandhi  . .,.
namely   cycles  paths along   weight.
 changed   length   .     clear.
  resulting weaker running time guarantee  .
algorithm  . really leads  worse running times .
practice.
 get  better understanding   general working principles,  extensively test   random instances  different types.  also propose  hybridization   two previous algorithms.    indication    behave  .real. instances,  implemented  broadcast scheduling algorithms  gandhi.
 . ., derandomized ,  tested   data.
stemming   wikipedia access log.
  nut-shell,  findings   follows.  .
random instances,  observe   superior running.
times suggested   theoretical estimates   bitwise approach  real.  difference   observed.
running times, however,  significantly smaller  .
corresponding difference   running time guarantees.
 hybrid approach manages  combine strengths .
 two predecessors   fastest   broad range .
instances.    tracking  running times, .
also structural information like  often edges .
  visited   algorithms,  gain insight  .
 effects occur.
concerning rounding errors   random instances,  approach  gandhi  . . remains .
strongest, similarly  previously observed also  disjoint cardinality constraints .
  broadcasting setting,  gandhi  . .,.
 consider two different objective functions, namely.
maximum throughput  minimum average delay. .
 cases,  present complete derandomizations, .
,  derandomize   rounding procedure  .
 random decisions made   algorithms. .
 minimum average delay case,  requires giving.
 new proof   approximation properties  .
algorithm  gandhi  .   cases,  also.
find   rounding procedures,   particular .
derandomized versions, perform well compared  .
guarantees. however,   maximum throughput.
algorithm finds solutions  close   optimum .
  relaxation,  algorithm  minimum average.
delay  beaten clearly   tests   simple greedy.
heuristic.
throughout   broadcasting applications, .
observe  new hybrid algorithm    fastest .
well  producing  smallest errors.
. algorithms   bipartite edge weight.
rounding problem.
  . ., .   bipartite .undirected. graph.
 edge weights  . . . since   .
interested   rounding aspect,  shall assume .
 weights   ., .   . . . .   . . .
  .  ,   . . .  .  . .  call.
. .
.
.   fractional degree  .
 bipartite edge weight rounding problem asks.
  rounding .  .  changes  fractional.
degrees  less  one.   words,  .
. . .    .   . . .  .
 .  . solving  problems   used  transform.
 fractional solution   problem  assignment-type.
constraints   integer one,  shown  ageev .
sviridenko ., ., . examples include  maximum.
coverage problem,  maximum k-cut problem .
given sizes   parts,  several scheduling problems.
., .
pipage rounding  key idea  solve  problems.
 given  ageev  sviridenko . denote  . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. .  .  . .  set   edges  non-integral.
weight.  . . .,. suppose  . contains .
simple cycle  . ., ., ., .,  described via .
sequence  edges.     . . ., . .
 alternatingly adding  subtracting . . .
edge weights   keeps  edge weights  ., ., .
moves  least one edge weight  .  . note .
   change  fractional degrees.  may.
     maximal simple path.   case,.
 fractional degrees   end-vertices may change,.
however,  never  beyond  floors  ceilings.
consequently, repeating  pipage rounding step  .
 . . times,  end   integral edge weights.
.  edge-based approach occasionally, .
addition  aim  keeping  rounding errors.
small.    mean    given linear expression.
. .
.
 axxi,  want  .  small.  .
easy  see  reasonable bounds   expressions.
   guaranteed  .  depends  variables.
 index   ,  .  .  simplify  notation,.
 shall always assume   paper   coefficients.
      .  .  allows  identify .
simply   subset      .  .
 first  show  solutions   bipartite edge.
weight rounding problem exist keeping  additional.
rounding errors small,  gandhi  . . .
 showed      way  randomly round .
edge weights .   always mean  . . . .
 holds    . .    way   variables.
.  negatively correlated    .  .  .
result  panconesi  srinivasan .,  allows .
use  classical chernoff bounds   sets  random.
variables.
 algorithm generating  randomized roundings   fact quite easy.   randomized version.
  deterministic pipage rounding algorithm given.
. note    cycle  path  . .
 two possible values ., .    used. .
 opposite sign,  .  . . .  . . .
now choosing . . .  probability . .
. . .  probability . . .  performing  current pipage iteration   ., gives .
required randomized roundings .  involved proof.
 . shows.  shall call   edge-based approach.
 generate randomized roundings   bipartite edge.
weight rounding problem, since   iteration .typically. exactly one edge becomes integral.
.  bit-wise approach  different approach.
 solve  bipartite edge weight rounding problem .
presented  .  crucial observation   .
 edge weights   previous approach  equal.
 .,   single pipage iteration  make .
edge weights   cycle  path integral.   .
exploited  follows.
assume   edge weights   finite binary.
expansion  length .,  ,    .   .
. . . write  . . . .   . .
binary length . . .  . . ., . . compute.
 randomized rounding .  .    set.
 . .
.
 . .
. ,   binary length . . .
repeating  procedure . times altogether also gives.
 randomized rounding   bipartite edge weight.
rounding problem  negative correlation   sets.
,  .  .  return   slightly technical detour.
  binary expansion,  approach  .
.typically superior. running time  . . edgebased approach   running time  .,  .
  average cycle length,    absence   bound.
 . one   assume .
.  hybrid approach  now propose  new.
algorithm  computing randomized roundings  .
bipartite edge weight setting,    hybrid .
 two previous ones. one iteration consists  .
following.  now  .   graph consisting .
 edges    least significant bit .among .
edge weights. equal one.  compute  cycle  path.
 previously  .  choose  random .   .
edge-based approach.
   seen  performing  edge-based.
approach,   taking  account edges  .
least significant bit equal  one,  using  bit-wise.
approach,  choosing  . taking  account .
true edge weights     last bit.
  easily seen   approach combines advantages   previous ones.  particular,   iteration  one edge weight becomes integral   edge.
weights  part   rounding step   binary length reduced. consequently,  running time.
guarantees  .  .  valid.
since  proof  gandhi  . .   specify.
  choose  cycle  path  since  cycle.
chosen    algorithm also   cycle .
treated identically   setting  gandhi  . .,.
one  easily see   hybrid rounding algorithm.
computes randomized roundings   bipartite edge.
weight rounding problem    rounding iteration .
cycle    path  used.
 restriction   cycles   solved via .
simple preprocessing.   end,   first note.
  three rounding algorithms presented  far will.
always find cycles   fractional degrees   integral.
.simply    case . never  vertices  odd.
degree.   also straight-forward  see   adding.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.two additional vertices    . . . additional.
edges  appropriately chosen edge weights,  .
make  bipartite graph   integral fractional.
degrees . add one vertex   bipartition class, .
edge       vertex   opposite.
class  weight    .old. vertex obtains .
integral fractional degree,  finally  edge connecting.
 two new vertices  giving  .simultaneously,.
since  fractional degrees  equal fractional part.
 desired fractional degree.
note   preprocessing   done  time.
.,     affect  order   total running.
time.  thus   following.
theorem .  hybrid rounding algorithm computes randomized roundings   bipartite edge weight.
rounding problem  time .mmin., . satisfying .
 large deviation bounds   edge-based  bitwise approach.
 typically     gain   order.
 magnitude   running time,  hope  .
course   new algorithm proves   faster .
experiments.
. derandomization  randomized rounding algorithms proposed    derandomized using .
classical pessimistic estimators.   easily applied.
  ., .-case   bit-wise approach. however,.
 rounding errors obtained via  derandomization.
 worse compared  classical randomized rounding,.
  errors   different iterations add .
  geometric series.
 .  showed  also  rounding approach.
 srinivasan .,  predecessor   edge-based.
approach  disjoint cardinality constraints,  .
derandomized via  classical pessimistic estimators.
 argument .without proof given . easily extends.
  edge-based approach   bipartite edge weight.
rounding problem.  thus obtain   direct.
derandomization   bit-wise approach,  .
addition admits better bounds   rounding errors.
theorem .  edge-based rounding algorithm .
 derandomized using  classical pessimistic estimators   analogous way  done   setting  disjoint constraints  .  bit-wise approach  .
derandomized via   pessimistic estimators. .
derandomizations lead  rounding errors   sets .
 guaranteed  chernoff bounds known  independent randomized rounding.
  second statement,  removed  previously.
inferior constant factors   rounding errors  .
bit-wise approach.   following,  talking .
derandomizations   bit-wise approach,  shall.
always mean  improved version. since  hybrid.
approach   particular implementation   edgebased approach, theorem . immediately yields .
derandomization   hybrid approach  well.
. experiments  random instances.
  first set  test instances,  chose different kinds.
 random instances.  underlying graph,  took .
following random bipartite graphs.   cases,  .
denote  graph   . ., .  . . .
    random edge set.   . . . .
 . . .
random bipartite graphs   edges.   kind,.
    random subset  exactly  edges .subject.
  bipartiteness requirement.    bipartite.
analogue   classical random graph model ,.
  random graph, naturally,  vertex  .
expected degree   . .   less  ., .
deviations   actual degrees   expected ones.
become quite significant. particular,  typically see.
isolated vertices.
regular random bipartite graphs.   reason,.
  aim  graphs  small average degree,  .
 appropriate  regard random regular bipartite.
graphs. since   difficult  generate uniformly.
 random,  regard  following type  regular.
random bipartite graphs.     degree  aim.
. starting   . .,  repeat  times  following.
procedure.  repeat generating random matchings.
 .  .   sample one  contains .
edge already present    add  matching  .
clearly,  resulting graph  regular  degree .
almost regular random bipartite graphs. already .
   large constant,  previous construction .
 time-consuming.  therefore resort   variant.
  just take  union   random matchings. .
 birthday paradox,   . .
.
.,  average degree.
  still  . . .   . .,  variants .
.almost. regular random bipartite graphs  connected.
 high probability.
 edge weights   rounded  chose numbers.
. uniformly  random  ., . given  rounding .  .,   interested   rounding.
errors . . .   sets ., ., . . ., .
    subset   edges  . . .  .  . .
incident   single vertex .  determined  sets.
., ., . . .  choosing    .   fixed number.
 . random subsets  .
. running times  discussed   introduction, one question  particular interest   running.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.algorithm error pipage rounding iterations edge visits path.cycle lengths time . .
edge-based . .,. .,. . .
bit-wise . .,. .,. . .
hybrid . .,. .,. . .
. .-regular random bipartite graphs  . vertices.  randomized algorithms get rounding error .
algorithm error pipage rounding iterations edge visits path.cycle length time . .
edge-based . .,. .,. . .
bit-wise . .,. .,. . .
hybrid . .,. .,. . .
. almost .-regular random bipartite graphs  . vertices .,. edges  average.  randomized.
algorithms get rounding error .
algorithm error pipage rounding iterations edge visits path.cycle length time . .
edge-based . .,. .,. . .
bit-wise . .,. .,. . .
hybrid . .,. .,. . .
. random bipartite graphs  .,. edges  . vertices.  randomized algorithms get rounding error.
.
table . performance   derandomized algorithms.  randomized algorithms   similar structural data,.
running times . times lower,  rounding errors  shown   captions.
times   different algorithms,   seems likely.
  pessimistic estimates done   theoretical.
analysis   approach  .   observed  .
actual run.
 will present  data   derandomized.
variants   algorithms . throughout .
experiments,  structural observations .number .
path.cycles, number  edge visits, average cycle.path.
length.   randomized variants   similar .
 corresponding values   derandomized setting,.
  running times  smaller   factor  .
.,   relative comparison   different approaches  similar  among  derandomized variants.
 measured  running times   six rounding.
algorithms  different types  random instances. .
algorithms   implemented  equal care .
.  running times  measured  amd.
dual processor . ghz opteron machines.  numbers.
  averages  . runs,   algorithms .
run  exactly   instances.  results .
displayed  table .  figure .  addition  .
actual running times,  also state  number  pipage.
rounding iterations   total number  times .
edge weight  changed. since  implementation .
 path  cycle finding procedure    equally.
often  edge  found       weight changed,.
 latter   good machine-independent estimator .
 running time.
 data depicted  figure .  indeed see .
superlinear increase    running time  .
number  edges visits   edge-based approach,.
whereas  bit-wise  hybrid approach rather show .
linear dependence   number  variables.  reason    edge-based approach  general values.
  variables needs  iterations  round  numbers.
  iteration roughly needs time proportional .
 length   cycle.path used   pipage rounding. hence  edge-based approach suffers  .
increasing path.cycle length.  simple regression looking   best-fitting . approximation   curves.
  running times   number  edge visits indeed indicates  different order  magnitude.  .
number  edge visits,  .-value  ., .  .
 bit-wise, hybrid  edge-based approach, respectively.   actual running times,  corresponding.
.-values  ., .  . note   extra.
factor  roughly  stems   fact  computing  pessimistic estimators   complexity roughly.
proportional   number  rounding errors  want.
 keep small,    settings  linear  .
 return,  course,  bit-wise approach suffers.
  length   binary expansion, whereas .
length   paths.cycles  irrelevant.
 data  table . also shows   new hybrid.
algorithm  generally faster    two. .
effect  significant   substantial   caused .
simply imitating  faster   two previously known.
algorithms.   run   algorithms also .
  preprocessing   hybrid,   typically.
decreased  performance.   particular,  .
  reason   hybrid algorithm  superior.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
 .
 .
 .
 .
 .
 .
.
.
 .
.
 .
.
.
 .
isi.
.
number  vertices.
edge-based  time.
bit-wise  time.
hybrid  time.
edge-based  edge visits.
bit-wise  edge visits.
hybrid  edge visits.
figure . running times  edge visits  .-regular random bipartite graphs  different graph sizes.  algorithms.
shown   derandomized variants.
  data given,  feel    identify.
two reasons   good performance   hybrid.
algorithm.  many instances  two ways  making.
progress .rounding edges  reducing bit-length. seem.
 combine nicely.   visible   reduced.
number  iterations needed, indicating  compared.
  edge-based approach indeed  average number.
 edge weights fixed  one iteration  larger  one.
however,  hybrid approach  also significantly.
faster   .-matching instances,   hybrid.
 edge-based approach need close   iterations.
  observe   average path.cycle length.
 much smaller  running  hybrid approach.
since   graph class typically  one edge .
fully rounded per iteration,  running time  approximately proportional   cycle length.  reason .
 cycles  shorter seems      regarding edges  weight   one   least significant bit,  instance becomes even sparser, making.
shorter cycles  paths .  appropriately, cycles.
going   vertices added   pre-processing.
 section .  likely.
. rounding errors similar   dependent randomized rounding  disjoint cardinality constraints,.
 edge-based rounding approach produces  lowest rounding errors among  derandomized algorithms.
since  three algorithms use   pessimistic estimators,  find  hard  come    convincing.
explanation   phenomenon.
 randomized algorithms produce  similar.
rounding errors .   .-regular random.
bipartite graphs, .   almost .-regular.
random bipartite graphs, .   dense.
random bipartite graphs.,     significantly.
larger .  around twice  large.   .
derandomized algorithms.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. broadcast scheduling.
one setting  bipartite edge weight rounding.
 found application  broadcast scheduling problems .   problems,  server   set .
pages  ,  receives requests  page broadcasts. usually, time  divided  discrete time slots,  .
server   broadcast one page .  bounded number  pages. per time slot.  makes  problem.
non-trivial     particular page  broadcast,.
 simultaneously satisfies  requests   page,.
  one request. possible optimization goals include maximizing  value   satisfied requests, .
minimizing  maximum   average delay  .
request experiences    satisfied.
gandhi  . . consider two   goals, .
maximum throughput   minimum average delay.
versions.   former setting, requests  deadlines.
     longer  satisfied.   setting, gandhi  . present  .-approximation. .
 latter setting,  give  ., .-bicriteria approximation,  ,  .-speed schedule . schedule broadcasting two pages per time slot.   expectation.
incurs  average delay  greater   smallest.
possible delay   .-speed schedule.   results.
remain  strongest   respective direction. however, several  variants   considered  .
literature, see, ., ., .
  section,  present fully derandomized versions   algorithms  gandhi  . .,  report.
  results  experiments   apply  .
broadcasting instances derived  wikipedia access.
logs.  log files  downloaded  .
. brief algorithm description  algorithms.
  section  follow   basic pattern .
producing  rounding problem   broadcasting.
problem instance.   sketch  outline  .
algorithms,  subsequently provide proofs  .
derandomizations.  general,  details  complete.
descriptions,  refer  gandhi  . .
 usual,  start   optimal fractional solution   natural lp-relaxation   problem. .
particular,  will contain  fractional schedule ypt , denoting  fractional broadcast  page   time , .
  every time slot pages   total weight  .
 one  broadcast.  fractional schedule  .
converted   bipartite edge weight rounding problem instance   following manner.  create  bipartite graph  . ., .,  . . ., . . . , .
represents  time slots,   edge incident  vertex  represents  page  broadcast  time . .
vertices . will represent windows, grouping  .
page   fractional broadcasts   consecutively .
sets   ,   .  possible exception  .
first   last windows.   window,  will .
broadcast exactly .  ,  edges incident  .
window represent fractional broadcasts ypt summing .
exactly one. note   variable ypt may  split .
  one window  attain . thus, rounding.
 edge .,.
.
 .  one represents  decision  .
transmission  page  associated   . window.
will occur  time .
  first window,  random value  . ., ., .
shift value,  chosen,    sum   values.
  incident edges ., splitting  last fractional.
transmission ypt   window  two  necessary.
 .,  random selection   shift value .
essential   approximation guarantees.
. derandomizing max-throughput broadcasting  mentioned, gandhi  . . give  .approximation   max-throughput broadcasting.
problem.  algorithm follows  scheme described .
 previous section.  will give  derandomization,.
including   selection  shift values .  begin .
sketching  argument   probabilistic case.
consider  single request    page ,  first.
possible broadcasting time   deadline .  variables ypt relevant    spread    two windows    .
.
.,   request  satisfied  .
integral solution     one   corresponding.
edges  chosen. assume  simplicity   relaxed.
solution satisfies  completely. ,  total value .
 relevant edges  window     random variable .
 depends  ,   remaining edges,   value.
 . . ,  incident  window  .   .
rounding procedure,   make  statement  .
joint probability  either   windows ends .
satisfying  request. however,  probability  .
first window satisfies  request,   exclusiveness.
  events   window,  exactly ,   .unconditional. probability   second window satisfies .
 . . . thus  estimate  probability   request  satisfied  max., .   linearity  expectation,  expected weight   satisfied requests.
  final broadcasting schedule   least .  .
total weight   requests. ,  refer  . .
proof. .  request   fractionally satisfied  .
fractional solution,  likewise,  probability  .
   randomized rounding   request .
satisfied   least .   fractional satisfaction.
 now show   arguments   turned.
  derandomized form   result.
theorem .  weighted max-throughput broadcasting problem   deterministic .-approximation.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.proof.  ytp   optimal solution   lprelaxation.   request ,  weight .,  .
  set  edges relevant   incident   first.
associated window   function   shift , .
 .   remaining relevant edges.  . .
. . max. ,. .,    .
weight  edge ,   estimation   expected contribution     value   rounded schedule. finally,   .   sum  .   requests  .
page .    hard  show, first,    make .
deterministic choice  optimize  value   . .
 page,  second,    use  sum   .
  pages   guide  rounding algorithm.
  first,  simply observe   .  .
piecewise linear function,  events occurring  every point   request  gets associated  exactly one window. thus,  suffices  compute  .
  . points,     number  requests.
. becomes  points    satisfies  constraints.
  second, imagine    replace.
 function .   linear function .
.
. matching  value, specifically  either .
.
.
 .
.
.,   .
.   sum   replacement functions.   .   completely linear.
function,  since  pipage rounding   linear adjustment one   two candidate points . will satisfy  . .  . .  . clearly,  . .  .
. derandomizing minimum average delay.
broadcasting  now turn   derandomization.
  minimum average delay broadcasting problem.
recall    version, requests   deadlines,.
every request must eventually  satisfied,  .
objective value  optimize   average . total.
delay incurred   requests.   result, .
first sketch  alternative proof   analysis  .
randomized algorithm   minimum average delay.
broadcasting problem given  gandhi  . . .
 use  results  tools   proof  give .
complete derandomized version   algorithm.
 randomized algorithm   minimum average delay version given  .   slight modification.
  previously described one.  modification consists    fractional solution given   lprelaxation  doubled ., every variable ypt  multiplied  two.   division  windows  .
construction   bipartite graph begins.  critical.
property   guarantees    every request ,.
  consider  variables ypt  contribute   incurred delay   fractional solution,    one.
window   bipartite graph  consists exclusively.
  edges.
 now argue     need  randomly.
chosen shifting value  .  take  value  .
.including  convenient choice  one.  still obtain.
 expected average delay      large .
 value   . besides simplifying  algorithm,.
 will   basis   derandomization.
proof   shifting value  leads   randomized.
.,.-approximation algorithm.   shifting parameter   chosen arbitrarily. consider  single request .
 edges relevant     edges   starting.
time,   point    edges sum    total value   least one   .unscaled.  solution.
 edges will  spread    three windows.
  graph. call  ,  ,   ,  corresponding sets  relevant edges , ,  .   .
 total value  .
since  total value    one,  will  satisfied.
via  edge   . .   .  . ,  . .
 probability     earliest edge satisfying .
 edges  , . equals ,  consequently .
probability   edge   satisfies .
 remaining mass . .  lies     .
unknown distribution, except  . . , since.
 latter   probability   corresponds  .
broadcast   requested page.  . .  . .
now  .   delay caused   event.
  edge    earliest edge chosen  satisfy.
 .defining . . .   lies   first time slot .
 satisfy  request .   expected delay  .
.
.
. . .
.
. xed. .
.
. .
recall   contribution     value  .
 .
.
.
using elementary observations like .
.
. . .
. . , . .  . .  .iii.  fact  .
 . ,  .   always  . . .,  derive.
. xed. .
.
. .
.
.
similarly, using.
.
.  . . . ,  derive.
. . .
.
.
.
.
since,  definition, . . . .     . ,.
 last two inequalities show   expected delay.
caused       contribution    optimum.
 derandomized algorithm   minimum average.
delay problem.  use   argumentation  show.
 derandomization also   minimum average delay.
problem.
theorem .  weighted minimum average delay broadcasting problem   deterministic ., .approximation.
proof.  explained ,    need  derandomize  choice  , since    chosen arbitrarily.
 thus suffices  present  function   serve .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.random  optimal .
instance method time . . value . time . . value .
small greedy . . . . . .
small randomized . . . . . .
small bitwise, derand. . . . .
small edge-based, derand. . . . .
small hybrid, derand. . . . .
small lp-relaxation . . . .
large greedy . . . . . .
large randomized . . . . .
large bitwise, derand. . . . .
large edge-based, derand. . . . .
large hybrid, derand. . . . .
large lp-relaxation . . . .
. results   max-throughput experiments.
instance. small instance. large.
method time . . value . time . . value .
lp-relaxation . . . .
randomized . . . . . . .
bitwise, derand. . . . .
edge-based, derand. . . . .
hybrid, derand. . . . .
greedy . . . . . .
. results   minimum average delay experiments.  lp-relaxation  .-speed,.
  algorithms .-speed.
table . broadcast scheduling results.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. references.
 guide   rounding process.  , consider.
 worst-case bound   distribution .  implicit    paragraphs.  distribution will.
match   edges ,  will assign mass . .
edges , without exceeding    individual edge.
 . thus,  weight  .   constitutes  .packing.   mass   end  window  .  .
  corresponding function value   request . although    linear, depending   non-trivial way.
  edges  ,  ,    max-throughput.
case,  bounded   linear function   fractional.
assignment .
consider thus  particular fractional assignment ,.
  . . .,  .  described.  .
  unique edge     .   integral.
.   edge exists,  .   last edge  .
  . . .  .   edges   .
 . . .     seen   .
. .
. .
.
 . .,  . depending linearly .
 weight  edges    .,   upper bound.
 .
.
. experimental results since    able.
 find truly real-world instances   two broadcast.
scheduling problems discussed ,  generated two.
instances  different size using data   wikipedia.
access statistics .,   expect  show similar.
characteristics  instances showing   broadcast.
scheduling problems.
 random subset  frequently accessed pages serves.
  set  allowed pages.  time events  every.
third .small instance.  second .large instance. hour.
  .-day period      allowed pages .
requested  weight equal   number  accesses.
  hour.  deadlines   request  chosen.
equally   . .
 results   max-throughput experiments.
 given  table . recall   proof .
theorem .    two aspects,  levels,  .
derandomization. one   choice   page shift ,.
   done randomly  deterministically, .
   use   derandomized rounding process.
 report   table  combinations   aspects.
since  randomized rounding algorithms behave .
similarly,  data    collected  one line.
 find , perhaps surprisingly,  proper.
choice    almost  powerful  effect  .
outcome   experiment  using  derandomized.
rounding process.  also find   combination,.
  aspects  derandomized, produces .
good results,   close   lp-optimum.
 comparison,  also include  simple greedy.
heuristic,   every time slot broadcasts  page.
  satisfy  largest weight  unsatisfied requests.   max-throughput problem,  algorithm  comparable   randomized rounding approaches,   clearly inferior   derandomizations.
 results   minimum average delay problem.
 given  table . remember  ,  smaller.
value  better.  lp-relaxation shows  .-speed.
optimum,   remaining data   .-speed schedules.
   seen   table,  .randomized.
algorithms find  resonable approximation   .
optimum .clearly better   approximation guarantee. also,  derandomization improves  .
randomized solutions. however,   solutions .
  competitive,  compared   .-speed schedule produced   simple greedy heuristic.   seems.
   problem .  least  type  instance.,.
 approach via bipartite edge weight rounding  .
 good idea.
</doc>
<doc title='alx11_11_gellertt.txt'>
. vehicle scheduling  conflicts.
torsten . gellert . felix . .nig .
abstract.
systems  rail-mounted vehicles play  key role  many logistics applications,   efficiency   operation frequently   significant impact   overall performance.
  surrounding production environment.  theory, assigning transport requests   vehicles   systems.
 scheduling  execution amounts  finding  tours.
  common line,  tours may never cross  .
 time.dynamic collision constraints need   respected.
 goal   minimize  makespan   given set  transport requests.
 establish  model capturing  core challenges .
transport planning problems   type  relate  .
 models  literature.  proving np-hardness .
 basic version   problem,  large part   paper.
 dedicated  devising various fast heuristic algorithms.
suitable  practice.  present computational results.
regarding  performance   algorithms proposed .
several classes  problem instances.
. introduction.
 many logistics applications, transport requests  conducted  parallel  several vehicles moving along  fixed.
shared pathway. examples include cranes mounted .
 common rail, like gantry cranes loading  unloading.
containers  intermodal transportation,  forklifts moving.
along  narrow passageway  large warehouses.  .
transportation systems, simultaneous execution  certain.
transport requests may lead  conflicts, ., may  impossible since vehicles  pass   .   keep.
certain safety distances.
assigning transports  vehicles  sequencing transports   vehicle constitutes  interesting case  .
multi-vehicle routing problem.   one-dimensional.
character   transportation system simplifies routing .
 single vehicle, scheduling conflicts complicate  problem.  proving  minimizing  makespan   execution  transports   transport systems  np-hard,.
 develop  number  distinct fast heuristic algorithms.
suitable  practice.  evaluate  compare  performance  different classes  instances representing use.
cases  different application areas.
.berlin institute  technology, department  mathematics, e-mail.
.gellert,fkoenig.math.tu-berlin.
 one-dimensional transport systems  conflicts.
occur frequently  case studies   operations research.
literature,  work   first  propose  problem formulation general enough   useful   wide range  applications. instances  different application areas may differ.
significantly  flavor,   experimental results provide.
valuable insight regarding  fitness  different solution approaches  .
. problem formulation.
  instance  . vehicle scheduling .d-vs., .
 given  family   transport requests . jobs. ,  .
vehicles  conduct .   .   specified   start.
 end points   line, . ,.  .,   vehicle  .
 initial position  . ,  . ., . . . ,.  assume  .
vehicles travel along  line  uniform, . unit speed.
 length   job  .  . . . .
 solution   partition     subfamilies ., . . . ,,.
together   start time      . .  execution .
 transport may   delayed  preempted, .,  .
 . , vehicle  needs    position .   time    arrive.
 position .   time  . .  objective   minimize .
makespan, ., max .   . . .
  vehicles reside   line   fixed order  may.
never pass  , detours may  necessary  vehicles.
 times  order  make room  others. hence,  called.
evasion jobs  corresponding start times  included  .
solution.  comprehensive example  given  fig. .
 solution  feasible   jobs  evasions  .
executed  schedule without vehicles passing  .
  sake  unambiguousness,  assume . .
vehicles spend  possible waiting time   schedules.
 late  possible .,   start point   next job,.
respectively. note     require safety distances,.
   feasible  two vehicles  occupy   position.
   time.
related work   . ., .d-vs becomes  special.
case   traveling salesman problem .tsp. .
fits  characterization   polynomially solvable special.
case  gilmore  gomory .  generalization  .dvs  . .   vehicle travels   undirected graph.
instead   line,  transport requests  ordered pairs .
nodes,   well-studied  np-hard stacker crane.
problem .scp. ., .  ., also  k-scp   vehicles.
 studied,  conflicts  vehicles   part  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
.
.
.
.
. direct tours   jobs.
.
.
.
.
.
jevasion.
.
.  inserted evasion job removes.
 collision.
figure . four jobs   conducted  two vehicles. one .
 blue,  one   red jobs, respectively.  straightforward schedule  clearly lead  conflicts .
 vehicles .left. however, instead  waiting   start.
position  job .,  red vehicle  clear  way  .
 vehicle.  resulting schedule  depicted   right,.
  call  additional movement   red vehicle .
evasion job.
model.
 ., also heinrichs  moll study one-dimensional.
transport systems  conflicts.   model, however,.
start times   jobs  part   input,   ask .
 jobs   feasibly assigned   vehicles.  relate.
 problem  covering line segments  angle-restricted.
curves  show   question   decided  polynomial time  shortest path computations.  mention.
galvanization lines  steel production   application.
moreover, one-dimensional transport systems occur frequently   subproblem  logistics case studies   operations research literature, predominantly  container logistics.  quay crane scheduling ., ., cranes loading .
unloading  ship move   common rail,  sets  transport requests  precedence constraints need   served.
 certain points.   works,  focus lies  higher.
level planning problems like  deployment  cranes .
storage blocks ., .   integrated optimization  loading  storage operations .   comes   actual.
scheduling  cranes   rail,  approach commonly used.
assigns cranes  disjoint sections  solves single crane.
problems ., .  include  evaluation   approach.
  results  sect. .
hardness  order  prove np-hardness  .d-vs .
 fixed number  vehicles  . .,  give  reduction.
 np-complete partition .   instance   .
latter,   given  set   numbersa. ., . . . ,. .
.,.,  . ,   question  whether    subset.
.
. . .aian .
.
.
.
figure . .d-vs instance constructed   instance .
partition.
. .  .  . . given  ,  will construct .
instance   .d-vs    optimum makespan  .
 .        yes-instance.
 instance  contains four special jobs .,., .,.,.
.,., .,.,  . jobs .,., .,.,  . ., . . . ,, see.
fig. .   illustration.  initially position two vehicles.
 .,  may moreover assume .   . .   . .,.
  keep  . . additional vehicles occupied  time.
.  initially positioning   .   adding  jobs.
. ,. .   . ., . . . ,.  hardness result now.
follows immediately   following lemma.
lemma .    yes-instance       .
solution  makespan .
proof. first assume     yes-instance,   .
denote  subset    .  . .    ,.
 assign jobs .,.,.,.  one vehicle  jobs.
.,.,.,.    .   vehicle executes jobs.
.,.,.,.    . first,   jobs .,.,.,.
  easy  verify     feasible solution .
makespan .
conversely, assume    feasible solution   .
makespan .  trivial lower bound   makespan   .
 sum  job length divided   number  vehicles, .,.
.
.
. .
.,.,.
. . .
   solution ,  vehicle  cover  distance.
without executing  job. consequently, one vehicle must execute jobs .,.,.,.,    jobs .,.,.,.,.
    case  makespan  .   exceeded.
moreover, jobs .,.  .,. must  assigned  .
 vehicle    . ., . . . ,. hence,  makespan  .
   realized  one vehicle  assigned  subset .
 jobs .,.  total length .,   must   yesinstance.
theorem . . vehicle scheduling  np-hard .
 fixed number  vehicles  . .
remark .  proof makes use   fact  vehicles.
 allowed  move simultaneously, .,   occupy .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 position    time.    circumvented,.
however,  delaying one vehicle   small . . .,.
increasing  makespan   solution  . . . due .
 integrality  weights   partition instance, .
reduction remains valid.
. algorithms.
 describe three types  fast heuristic algorithms .
.d-vs.  major objective   design  fitness  .
production environment  fast runtimes  imperative.
every approach follows  distinct algorithmic idea  thus.
leads  different results   various sets  test instances.
  report  sect. .
 major challenge  .d-vs  avoiding conflicts, .,.
ensuring  different vehicles. routes never cross .
.   end  pursue two different techniques. .
 algorithm described first,  schedule transports  .
vehicles simultaneously  explicitly prohibit conflicting.
routes.   latter two approaches,  decompose .
problem  subproblems   solve   single.
vehicle,    done exactly  time . logn. .
 assembling  final solution   different.
parts, conflicts  avoided implicitly.
. insertion  antichain constraint  first algorithm  .d-vs  based   characterization  feasible.
solutions  follows  results  .  job   .
associated start time     conveniently represented  .
line segment   plane.  one dimension,  line segment spans  job. spatial dimension . . .,   .
 duration . .   . . .  vehicles travel  unit speed,.
 line segments   slope  . see fig. .  .
illustration   job   space-time-diagram.
quite obviously,   feasible solution,  subfamily .
. jobs  start times    least two   jobs.
  performed one       vehicle.
necessary condition   solution   feasible.  ., .
authors essentially prove   condition  also sufficient.
 formally,  . denote  binary relation  jobs.
 assigned start times ., . . .,   ., . . ,  .
denote      performed   different vehicle .
,   latter vehicle   reside   left   vehicle.
performing .   words,  line segment  ., . .
non-empty intersection  . .
definition . .antichain graph.   . ., . . . , .
  assignment  start times  jobs  . .  directed.
graph . . .,.  called  antichain graph  ., . .
., . . . . .
lemma . .   family  jobs  assigned start.
times ., .,  .
.    scheduled  start times    vehicles. .
 cycle-free  diam. .
.
.
job .
. .
. .
 . .
. .
 .
  . . .
.  . .
figure . line segment representation   job  .
associated start time     space-time-diagram. job .
partitions  plane  four regions.  vehicle executing.
  time     move  region  . . , .
 region . . afterwards.    hand, .
vehicle  ever enters region . .  . .  never.
execute   time  .
.  time .,  solution   constructed .
 ,     proven     exist.
 essentially,  algorithm  .d-vs merely needs .
compute feasible start times  ,   assignment  jobs .
vehicles   needed evasion moves   computed accordingly.  leads   following idea   algorithm.
take  jobs  ,    fixed order set  start time.
 insert  resulting node   antichain graph . .
start  . . .  always choose  earliest start times.
 avoids  cycle   path  length greater    .
see alg. .   formal description   procedure.
 insertion order,  use  order given   start.
times   optimal solution   single vehicle .
  computed easily.  boost  performance  .
approach   cost   higher runtime, meta-heuristics .
local search algorithms   used  modify  insertion.
order.   variant   algorithm,  perform local search.
  neighborhood defined  simple swaps  positions.
  possible pair  jobs, immediately moving   .
neighboring solution     better makespan.  present.
results  sect. .
mixed integer program  antichain graph also motivates  mixed integer programming formulation  .d-vs.
 fractional variables  job start times,  integer variables  needed  order  formulate feasibility constraints.
 terms   resulting antichain graph.  omit  detailed.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
algorithm . insert.
require. instance .,.  .d-vs, insertion order  , initial.
positions .
ensure. solution  .d-vs.
. .enforce  given initial positions  .
. tstart . . ,.  . ., . . . . .
. . .empty antichain graph.
.   . .  . .
.  . i-th job   . select  next job via  permutation.
.  . . .
.  . . . . .insert new node   graph.
.  . , .  added  tstart .
. .add  new edges   antichain graph.
. . . . . . ., . . . . .  . .
. . . ., . . , . .
.  diam.   .   cycle  .remove .
edges  increment  time variable .
. . . ., . . , . .
. increment     least one   current.
relations.
   .   hold  longer.
. else .adopt start time    feasible.
. add . , .  tstart.
. end .
. end .
. end .
. return solution  .d-vs given  tstart.
.
. . . . .
figure .  positive cluster  width three. point . .
contained  three jobs   cluster, .  none.
description   model ,   instances   twenty.
jobs  two vehicles   solved employing state-ofthe-art solvers.  bigger instances, feasible solutions .
found,   useful lower bounds.  particular,   .
able  identify  optimal solution   test instances .
sec. .
. clustering   second approach,  key idea .
 treat   vehicles like one vehicle  capacity . .
cluster jobs going    direction  fill  capacity.
 well  possible  solve  scheduling problem .
clusters  one vehicle exactly. finally,   vehicles execute.
 solution  parallel,     .potentially .
 . jobs   cluster  scheduled  one    vehicles.
 following definition  illustrated  fig. .
definition . .cluster.  subfamily  .   jobs .
called  positive .negative. cluster  width    jobs .
  positive .negative. direction   point   line.
 contained      , .,.
.  . .  .  .  .  . .  .  . .
.
.  .  .  . . . . .  . . .
moreover,  start  end points   positive .negative.
cluster   defined .
. . min.
.
. .
.
max.
.
. .
.
.
. . . max.
.
. .
.
min.
.
. .
.
.
definition . .clustering.  partition  .
., . . . ,.   family  jobs   clusters  width.
  called  k-clustering  .
 algorithm first finds  k-clustering,  defines .
job jci . .,. .   resulting cluster , .
finally solves  resulting smaller instance  .d-vs .
one vehicle exactly.  executing  resulting solution.
   vehicles  parallel,  jobs   cluster .
 handled simultaneously.  formal description  .
algorithm  given  alg. .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
algorithm . cluster.
require. instance .,.  .d-vs.
ensure. solution  .d-vs.
. . . k-clustering   jobs  .  . . .
. . . k-clustering   jobs  .  . . .
. sol. . optimal solution   .d-vs instance .,.
 . . . jci . . .
.  . . . .
. find  cluster  .  belongs  .
. set  start times   jobs    .   start time.
   sol. plus . . .
. end .
. return start times  partition ., . . . , defined .
.,.
clearly, clusters  cover  point   many.
jobs  possible .  .  utilize  available vehicles well.
 compute positive .negative. k-clusters  first sorting.
 positive .negative. jobs  increasing .decreasing. order.
  . . , starting   empty clustering, .
consider  jobs   order  insert  job   .
first cluster      increase  width beyond .
. disjoint domains   core,  last heuristic mimics  rule  thumb used frequently  scheduling .,.
gantry cranes   common rail  practice ., .  .
available vehicles  assigned   disjoint sections  .
line,   transport requests  lie completely inside.
one section  assigned   corresponding vehicle. ,.
 resulting subproblems  one vehicle   solved exactly. however, transports across section borders demand.
special care,  section borders need   chosen wisely .
 balance  vehicles. work loads  well  possible.
 restrict  choice  initial section borders  start.
 end points  jobs  aim  balance  amount .
work, .,  sum   lengths  .partial. jobs  lie.
  section.  precisely,  minimize  maximum.
difference  two sections . work   performed.
   done  simply evaluating    quadratically.
many possibilities.
starting   initial partitioning   line  .
sections,  algorithm repeatedly schedules  jobs inside.
 domain   single vehicle  merging adjacent.
domains  obtain new subproblems.  procedure .
described formally  alg. .
. worst case performance  now briefly discuss .
worst case performance   heuristics. maybe surprisingly,   able  construct one family  instances.
demonstrating   constant approximation guarantee.
holds     algorithms.  specifically,  prove.
  performance ratio    algorithms   inalgorithm . disjoint.
require. instance .,.  .d-vs.
ensure. solution  .d-vs.
.  . . . . . find  partition   storage .
disjoint domains.
. create empty sets ., . . . ,.
.   . . .
.   . .  .  . treat  domain   .
. solmin . . .saves  solution   smallest.
makespan.
.   .   .  vehicles currently  .
. sol. . optimal solution   jobs   .
vehicle .
.  makespan.sol.makespan.solmin. .
. solmin . sol.
. . .  .stores  vehicle used  solmin.
. end .
. end .
. . . . . .  . .
. set start times  . .  . .  values  solmin.
. add evasion jobs     . .  . , . .
wait  . finished  last job.
.  . . .  . . .remove  processed jobs.
. end .
.  . . . . .  .
. .
.
.
. . merge pairs .
neighboring domains .
. end .
. return start times  partition ., . . . ,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
stances constructed   better  . .,    .
number  vehicles.
consider  .d-vs instance comprising  nearly identical long jobs,   nearly identical copies   family .
. identical short jobs.  jobs share  common point,.
making  harder  conduct   parallel. precisely, .
define  . . .  .
 . . .  . .,.  . .
.  . .,.  . .,.
  small . . .  large ,   vehicles .
initially positioned  . .,  . .   . .  . . see.
fig. .   illustration.
optimal solution  optimal solution   . .  shown.
 fig. .   jobs    direction,  minimum.
time needed  travel   endpoint  one job  .
start point   next clearly    included  .
makespan   solution  least .  vehicles  fully.
utilized   remainder   time. hence,  optimal.
makespan .
topt . . . .
cluster    hard  see   heuristic cluster will.
produce  schedule similar   one shown  fig. .
recall   algorithm computes  clustering  adding.
 job   first constructed cluster  current width less.
 ,  jobs  considered  nondecreasing order.
  start points. consequently,    . ., . . . ,.,.
 jobs   will form  cluster  jobs   scheduled.
 parallel.   cluster corresponds   job  .
.  . .,.  . .,   makespan   solution .
tcluster . . . . .
disjoint  defining disjoint domains   served  .
single vehicle,  long jobs .  . .,.  . . must .
scheduled one    . already  definition  .
approach,   impossible  create domains resulting  .
schedule    processed concurrently. hence,.
. . .
  lower bound   makespan attained  algorithm.
disjoint.
insert recall   order jobs  inserted   schedule  algorithm insert depends   optimal solution .
 single vehicle. now note    instances constructed,.
 optimal makespan   . .   decomposed  .
time needed  travel  position .   start point .
 job,  length   job ,   time  get back.
 position . since  vehicle   required  return.
  initial position   end   schedule, however,.
 makespan   reduced   time needed  travel.
  end point   last job   schedule  position.
. consequently,  solution  schedules  long job.
.  . .,.  . . last  optimal  one vehicle.
now consider  . .   possible insertion.
sequence.  schedule computed  insert resembles.
 one  fig. .   first . . short jobs  .
single long job,  assigned start times  earliest possible.
since  form  chain  length . .   antichain.
graph, however,   long job   inserted  .
schedule   first long job  finished processing.
hence,  start times   next jobs  offset   least.
.  leads   makespan .
tinsert . . . . . . .
  complete schedule.
ratio   cases,  heuristics may compute  solution.
 makespan  least.
theuristic .  . .
hence,  ratio   makespan   heuristic solutions .
 optimal makespan .
theuristic.
topt.
.  . .
. ,.
 converges  .  . .
interestingly, cluster  compute  optimal solution.
  initial cluster contains  similar jobs. similarly,.
insert  find  optimal solution  well   uses .
right insertion sequence.  demonstrates   initial.
clustering  cluster  well   insertion sequence .
insert  indeed crucial ingredients   algorithms.
however, different approaches may  needed  yield good.
practical results   one hand,   better theoretical analysis   . also note   simple k-approximation.
algorithm  .d-vs  given  computing  optimal solution  one vehicle  leaving . vehicles idle.
remark . instances   arbitrarily large family .
jobs    behavior   generated  adding.
multiple copies   current family  jobs.
. computational study.
 now evaluate  performance   algorithms .
different application scenarios.  stating numerical.
results,  give  brief description   instances used.
. instances  generated five distinct sets  instances.
containing random transport requests, designed  model use.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
. . .
. tour obtained   algorithms.
.
.
. . .
. optimal solution.
figure . comparison   solutions obtained  cluster.
 disjoint .left.   optimal solution .right.  .
bad example instance  . vehicles.   optimal solution,.
 identical jobs  done  parallel .,   assigned.
identical start times.  yields  makespan  roughly.
. . .
cases  different applications.   set  instances,.
job lengths  chosen uniformly  random  one  .
following ranges measured  percentage  storage length.
., ., ., .,  .  set.
comprises twenty instances containing . jobs , .
 ran  algorithms   instance   . .,.,.,.
vehicles.
. results tab. . compares  makespans obtained .
 algorithms   different sets  instances, respectively.  state numbers  alg. .   extension .
alg. .   perform local search   insertion sequence  described  sect. .  basic algorithms. runtimes  extremely fast .well  one second   instances.,   extended local search algorithm naturally.
  increased runtime  roughly one minute per instance.
column . contains  average makespan  .
twenty instances   set   algorithm, normalized .
 best basic algorithm. result.  next two columns state.
 number  instances    algorithm performed.
best,   slower local search algorithm   taken.
 account   latter column.   sake  brevity, .
 quote results   . .   . . vehicles,   .
 . .,. fall    expected.
  short jobs .tab.,  disjoint domains algorithm .disjoint. consistently outperforms   approaches    well  many vehicles.    .
.,  insertion algorithm  local search .insert .
comes close.  slightly longer jobs .tab.,  begins .
change.  . .,  advantage  disjoint   .
basic algorithms narrows,  insert . already outperforms   twelve   twenty instances.   vehicles,  solution quality  disjoint deteriorates,  .
clustering algorithm .cluster. performing best   .
basic approaches.
  following, cluster consistently beats  .
basic algorithms .tab. .,  disjoint remains competitive   medium length jobs   . . even  .
basic insertion algorithm .insert.  never  best,  performs reasonably well   sets  instances. moreover.
insert .,   added local search, computes  best.
average solutions   instances     short.
jobs .tab.
finally,  tab. .,  compare  reduction .
makespan achieved  increasing  number  vehicles.
  algorithm  different sets  instances,  state.
 average speedup factors achieved  multiple vehicles,.
., . means  average makespan   halved .
compared   optimal tour  one vehicle. obviously, .
  upper bound   speedup   vehicles.
now,  inherently different natures   algorithms.
become visible.  disjoint achieves  best speedup.
  short jobs   number  vehicles,  performs.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
table . makespan comparison  instances  job.
lengths .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
table . makespan comparison  instances  job.
lengths .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
table . makespan comparison  instances  job.
lengths .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
table . makespan comparison  instances  job.
lengths .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
average .best .best  .
disjoint . . .
cluster . . .
insert . . .
insert . .  .
.  . .
table . makespan comparison  instances  job.
lengths .
 poorly  average  longer jobs .tab.  .
jobs cross domain borders,  less efficient  approach.
becomes.
    shortest jobs, cluster consistently.
achieves  best speedups .tab. especially  instances contain  long jobs,  algorithms utilizes extra transport capacity  form  additional vehicles .
effectively. algorithm insert  delivers acceptable.
speedups across  instances .tab., however outperforming cluster    short jobs   . .,.
. conclusions.
  paper,  proposed three  fast heuristic algorithms  . vehicle scheduling.  computational.
results demonstrate    straightforward approach.
 scheduling vehicles within   disjoint domains .
 suitable  instances   short jobs   vehicles,   performance deteriorates quickly  increascopyright . .  siam .
unauthorized reproduction  prohibited.
.
job length .  . .  . .  . .  . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
table . reduction  makespan   optimal tour .
one vehicle  using algorithm disjoint.
job length .  . .  . .  . .  . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
table . reduction  makespan   optimal tour .
one vehicle  using algorithm cluster.
job length .  . .  . .  . .  . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
table . reduction  makespan </doc>
<doc title='alx11_12_chimanim.txt'>
 sdp approach  multi-level crossing minimization.
markus chimani. philipp hungerla.nder. michael .nger. petra mutzel.
abstract.
 present  approach based  semidefinite programs.
.sdp.  tackle  multi-level crossing minimization problem. thereby,   given  layered graph .,  graph.
vertices  assigned  multiple parallel levels.  ask .
 ordering   nodes   levels  ,  drawing  graph  straight lines,  resulting number .
crossings  minimized. solving  step  crucial  .
probably  widely used graph drawing scheme,  socalled sugiyama framework.
 problem  received  lot  attention   .
field  heuristics  exact methods.   long time, integer.
linear programming .ilp. approaches    exact.
algorithms applicable  least  small graphs. recently, sdp.
formulations   special case  two levels  proposed.
 dominated  ilp  dense instances.
  paper,  present  new sdp formulation .
 general multi-level version ,  two-levels,  even.
stronger   aforementioned specialized sdp.   sideproduct,  also obtain  sdp-based heuristic  .
practice always gives .near-.optimal solutions.
 conduct  large set  experiments,   randomized   real-world instances,  compare  approach.
  state-of-the-art ilp-based branch-and-cut implementation.  sdp clearly dominates  denser graphs,  .
ilp approach  usually faster  sparse instances. however,.
even   sparse graphs,  sdp solves  instances.
 optimality   ilp.  fact,    single instance.
 ilp solved,   sdp  . overall,  experiments reveal   sparse graphs, one  usually try .
find  optimal solution   ilp first.   approach.
  solve  instance  optimality within reasonable.
time,  sdp still   good chance   .
 able  solve larger real-world instances .
reported ,   also able  evaluate heuristics .
 problem.   paper      traditional.
.institute  computer science, friedrich-schiller-university  jena,.
germany, markus.chimani.uni-jena. markus chimani .
funded   carl-zeiss-foundation juniorprofessorship.
.institute  mathematics, alpen-adria universita. klagenfurt, austria,.
philipp.hungerlaender.uni-klu.
.department  computer science, university  cologne, germany,.
mjuenger.informatik.uni-koeln.
.department  computer science, technische universita. dortmund,.
germany, petra.mutzel.tu-dortmund.
barycenter-heuristic .showing   leaves  large gap  .
true optimum.   state-of-the-art upward-planarization.
method .showing    usually close   optimum.
. introduction.
multi-level crossing minimization .mlcm.   important.
task  automatic graph drawing. hierarchical graphs .,.
directed acyclic graphs.  mostly drawn   framework suggested  sugiyama  . . ,  vertices.
 assigned  levels .corresponding  horizontal layers.,.
essentially fixing  y-coordinates   vertices. , .
graph  transformed   proper multi-level graph  .
edges  subdivided    edge connects two vertices  adjacent layers.  aim   multi-level crossing.
minimization step   reorder  vertices within  levels.
   number  crossings  minimized   edges.
 drawn  straight lines. finally,  position   vertices  assigned  keeping  leveling   ordering.
  vertices.  alternative paradigm  sugiyama. approach  based  upward planarization . also   setting, finding optimal solutions  mlcm   interest .see.
section .
 practice, mlcm  often reduced   sequence .
.-level crossing minimization problems   one level.
 fixed. many heuristics ., .  well  fpt algorithms .   suggested   restricted problem,.
  far variants   simple barycenter  median.
heuristics belong   best  practice ., . general.
mlcm  np-hard, even   restriced variant . .nger.
 mutzel .  shown   restricted problem .
 reduced   linear ordering problem    solved.
using  integer linear programming .ilp. approach. combined   branch-and-bound method,  solved .-level.
mlcm instances    . vertices   smaller level.
 optimality.  alternative exact approach  solving .level mlcm, based  semidefinite programming .sdp.,.
  suggested  buchheim  . .  model.
 problem   quadratic linear ordering problem .
 turn   reduced   maximum cut problem. .
suggest new ilp-  sdp-based algorithms exploiting .
observation.  experiments show   sdp-based.
branch-and-bound algorithm outperforms various versions.
 ilp-based branch-and-cut algorithms,   able  solve.
.-level instances    . vertices per level  optimality.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
within reasonable computing time.
 first ilp formulation  general mlcm  .
suggested  .   time, generic ilp solvers  .
 able  solve practically relevant instances. healy .
kuusik extended  ilp formulation  constraints arising.
  so-called vertex-exchange graph .   first.
time    able  solve  practically relevant.
instances  mlcm  optimality .
contribution.  suggest  new sdp-based approach.
 mlcm  prove  polyhedral advantages  .
known ilp models.  two levels,  semidefinite relaxation  stronger   one considered  .  use .
primal-dual interior point method  solving  semidefinite relaxation leading  lower bounds   optimal value.
 mlcm.  extensive computational experiments  .
large benchmark set  graphs show   new approach.
 combination   sdp-based heuristic  often provides optimal solutions.   able  compute optimal solutions  graph instances   literature   .
 solved  optimality .
 also compared  approach   standard ilp.
formulation, solved via branch-and-cut within  generic ilp.
solver. surprisingly,   sdp approach dominates .
denser graphs,  ilp turns     fast  sparse,.
practical instances.  solves almost  instances  .
rome benchmark set,  standard graph drawing library. yet,.
 experiments show   sdp approach solves .
instances  optimality   ilp approach, although .
former   combined   branch-and-bound scheme.
 also suggests  new heuristic  mlcm based  sdp.
 clearly outperforms  classical heuristics.
 obtained optimal solutions  graphs  interesting size,     first time evaluate heuristic solutions.  show   upward planarization approach.
  close   optimum concerning  given leveling,.
    true   standard barycenter heuristic.
  studies,  collected  large benchmark set  leveled graphs, available  http.www.uni-jena.
.research.pubs.mlcm.html.
  following,  will always consider  proper level.
graph  . .,.,  vertex set  .
.
.  edge.
set  .
.
.   .  . .   .
denote  .  set  vertices  level  . .  .
 destinations  edges adjacent  vertex   level .
 ask   ordering   vertices . drawn  .
respective level.    number  crossings .
straight-line edges  minimized.  notational simplicity,.
 will assume   vertices  uniquely numbered.
.increasing  level., starting  .
. ilp formulations.
mlcm   natural formulation   quadratic linear program  . variables .  introduce binary variables.
. xrij . ., ., . .  . , ,  . ,  . .
 shall  .  vertex  comes    layer , .
. otherwise .,  comes  .  may use .
substitution xrji . . . xrij  . .  .  . .
 following .-cycle constraints describe linear orderings.
  layers   given proper level graph.
. . . xrij . xrjk . xrik . .,.
. .  . , , ,  . ,  .  . .
 rule   existence  directed .-cycles  .
sufficient  insure     directed cycles. hence.
 feasible binary solutions . . describe complete.
acyclic digraphs   layers. minimizing.
.
.
.
.
.,.
.xrijx.
.
 . .
.
jix.
.
 .
  constraints .  . therefore solves mlcm.
  linearize  objective function  introducing binary.
crossing variables.
. crij, . ., ., . .  . , ., ., ., . . .
 shall  .   edges ., .  ., . cross  .
otherwise.  bind  crossing variables   linear.
ordering variables,  need.
. . crij, . . . xrij . crij,,.
., ., ., . . ,  . .
. . crij, . . . xrij . . . crij,,.
., ., ., . . ,  . .
    vector collecting  variables xrij   . .
  vector  crossing variables,    total number.
 crossing variables   graph.    formulate.
mlcm   binary linear program .
. . min.
. .
.
.
.,.,.
crij, . ., . . icr.
.
.
icr. . . ., . . ., .  satisfy ., ., .
replacing  integrality conditions  . bounds.
gives  linear relaxation denoted  .  objective.
value zlp.  exact algorithm using .   introduced  .nger  mutzel .    extended.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 .  .   algorithms perform best  sparse.
instances . . . .see .   higher densities  gaps.
 .    bounds become  large  efficient pruning  branch-and-bound  branch-and-cut algorithms.  fact,  setting   variables  .,  .
always.independently   instance.obtain  feasible.
fractional solution  zlp . .  prevent ,  propose  fix  single linear ordering variable  .  .,  break.
 symmetry without loosing  optimal solutions. yet .
practice  obtained relaxed solution still gives   weak.
bound.  will investigate    detail  section .
thus    desirable    tighter approximation available   cases.
.  semidefinite program.
  section  concentrate   lower bound computation  mlcm  analyzing matrix liftings  ordering.
problems.   purpose   convenient  transform .
linear ordering variables xij  variables taking  values.
.  .
. yrij . .
.
 . ., . .  . , ,  . ,  . .
 leads  inequalities equivalent  .
. . . . yrij . yrjk . yrik . .,.
. .  . , , ,  . ,  .  . .
 .   shown  one  easily switch .
 ., .  ., . formulations  bivalent problems.
   resulting bounds remain    structural.
properties  preserved.
. lower bound. semidefinite relaxation  matrix.
lifting approach takes  vector  collecting  variables yrij.
 considers  matrix  . yyt .  object  interest.
now .
pqc . conv . yyt .  . ., .,  satisfies . .
 relax  nonconvex equation  . yyt . .  .
constraint  . yyt . .,   convex due   schurcomplement lemma. moreover,  main diagonal entries .
 correspond  . ,  hence diag. . . ,  vector .
 ones.  therefore conclude    . pqc satisfies.
.  . yyt . ., diag. . . .
 simplify  notation,  introduce.
.  . .,  . .
.
. .
 .
.
,.
 . . dim. . . .
.
.
.
.
.
  . .zij. .
 case  .yyt . .  . .hence,  following basic.
set  contains pqc .  submatrix   corresponding .
 .,.
.  . .  . diag. . ,  . . .
 order  express constraints    terms   ,  .
  reformulated  quadratic conditions    .
denote  product yrijy.
.
  .
,.
,. using  . ., .
 . gives .yrij . yrjk . yrik. . .  natural way .
 quadratic reformulation   equation   square .
sides, , since . . ., simplifies .
. ,rij, . ,rij, . ,rik, . .,.
. .  . , , ,  . ,  .  . .
 .   shown   equations .formulated .
 ., . model. describe  smallest linear subspace .
contains pqc .  formulate mlcm   semidefinite.
optimization problem  bivalent variables,    given.
 .,     symmetric matrix  order . assigned.
 count  number  crossings   given feasible.
ordering .
theorem . mlcm  equivalent   problem . .
min . .,. .  . iqc ., .
iqc . .  partitioned   . .
satisfies .,  . ,  . ., . .
  drop  integrality condition  ,  get .
following basic semidefinite relaxation .sdpb.  mlcm.
.sdpb. min . .,. .  partitioned   . .
satisfies .,  .  .
   obvious ways  tighten  relaxation.
.sdpb. first    observe   ,  therefore ,.
 actually  matrix  ., . entries   ordering.
formulation. hence  satisfies  triangle inequalities,.
defining  metric polytope.
.
 .
.
 .
. . . . . . . .
. . .
.
. zijzjk.
zik.
. . ,.
. .  .  .  . .
. .
 note   polytope  defined  .
.
.
.
.
.
.
.
. . facets.   used  triangle inequalities   max-cut polytope  ., ., .  basic relaxation .sdpb.  therefore  improved  additionally.
asking   .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
another generic improvement  suggested  lova.
 schrijver  . applied   problem,  approach.
suggests  multiply  .-cycle inequalities .  .
nonnegative expressions .yslm.  .yslm.  results.
  following inequalities   . . ,  . , , ,  . ,.
 , .    .  .    . .
.
. yslm .
yrij . .
.
 . yrik . ,sij, . ,sjk, . ,sik,.
. . . yslm,.
. . yslm .
yrij . .
.
 . yrik . ,sij, . ,sjk, . ,sik,.
. . yslm.
  overall .
.
.
.
.
.
.
.
.
.
.
.
.
. .
.
. .  inequalities  .
define.
 . .  .  satisfies . .
 summary,  get  following tractable relaxation.
 pqc , part   .without  matrix cuts . .
 investigated  .  bipartite crossing minimization.
problems,  .  single-row layout problems, , including .,  .  general quadratic linear ordering problems.
.sdpi. min . .,. .  partitioned   . .
satisfies .,  . ,  .,  .  .
 close  section  relating .sdpb. . therefore.
also .sdpi.   linear relaxation .  mlcm .proof.
  appendix.
theorem .  basic semidefinite relaxation .sdpb.
together   constraints . . yrij. . . . . . .
therefore also .sdpi.   least  strong   linear.
relaxation .
.  facets used  separation  omit .
proofs   following theorems.    found .
 appendix.  know  .  pcr. .
conv.icr. . .  full dimensional.  first.
relate pcr.  pqc .   present various classes.
 facet-defining inequalities  pcr.  show .
.sdpi. contains .   former,  consider .
lifting .  pcr  extending  variable vector  .
incorporate  possible crossing variables,    vertex pairs  adjacent layers  associated costs . ., .
 adding upper bounds   variables. formally, .
 . ., , , . .  .    .   . .   . .
   . .,  consider  constraints.
. cij, . xij , cij, . xkl, cij, . .xij.xkl.
  ., , , . .  . considering  extended variable.
vector ,  define.
. . conv., . satisfy ., ., ., . . ., .
theorem . pcr. contains .,  projected.
onto  common variables. .  pqc describe .
 polytope, modulo transformation .
corollary . facet-defining inequalities  pcr.
 valid inequalities  pqc .
proposition . .     cycle    qclaw  .  following inequalities  valid  pcr.
.,.,.
cij, . . .,.
.
.,.,.
cij, .
.
.
.
.
.
. . .
.
 even.
.
.
.
 odd.
.
    set consisting   pairs  edges  .
. except  pairs  edges   either  within.
 lower part   .-claw.  following inequalities .
facet-defining  pcr.
.,., ., .
cik. . . . .,. .
.,.,.,.
cikjl . .
 , ,  . ,  .  . , , . ., . .  . .
 following inequalities constructed  dome paths .
facet-defining  pcr.
xrij . .xrik . xrjk . crij, . crjk, . .,.
.xrij . .xrik . xrjk . crij, . crjk, . .,.
.xrij . xrik . xrjk . crik, . crkj, . .,.
.xrij . xrik . xrjk . crik, . crkj, . .,.
xrij . xrik . .xrjk . crji, . crik, . .,.
.xrij . xrik . .xrjk . crji, . crik, . .
.
theorem . .sdpi. satisfies . except.
.   . .  odd.
corollary . .sdpi.   least  tight  .
together  . except .   . .  odd.
 summary,    inequality types considered .
.sdpi.  required  ensure facet-defining inequalities .
pcr.    hand,   want  sdp relaxation.
. . .   relevant  identifying known facets  pqc.
   efficiency considerations,    use . .  .
computational experiences.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 ensures  known facets  pcr.  .sdpi.,.
   consider additionally clique inequalities  size.
 . . odd   relaxation.  separating   far .
expensive,  supports  model choice.
. solving .sdpi. looking   constraint classes .
 sizes   relaxation .sdpi.,    clear .
maintaining explicitly .
.
. .   constraints .
  attractive option.  therefore consider  approach.
suggested  .  adapt    problem. firstly, .
 aim  maintaining  constraint  .  .,  .
. . diag. . . explicitly,    achieved .
standard interior point methods, see  instance .
  constraints  dealt  lagrangian duality.  notational convenience,   formally denote .
.-cycle equations .   . . . . similarly .
write .    . . . .  consider  partial.
lagrangian dual defined   lagrangian.
., ., . . .,. . . .
 dual function  thus given .
., . . min.
.
., ., . .
. . . min.
.
. ., .
   hard  verify  .sdpi.  strictly feasible.
points,  strong duality holds    solve  relaxation .
. max.
.,.
., .
 function   well-known   convex  nonsmooth.   given feasible point ., .  evaluation .
., . amounts  solving  problem  .
  experiments,  use  primal-dual interior-point.
method,  also provides  primal optimum .,. yielding  subgradient   .   subroutine available .
evaluates    element   subdifferential   , .
 straightforward  get  approximate minimizer   using subgradient optimization techniques,    bundle.
method . since  methods  rather weak local.
convergence behavior,  limit  number  function evaluations  control  overall computational effort.  fact.
 evaluations constitute  computational bottleneck .
  responsible    .   required running time.
. upper bound computation standard heuristics .
also  metaheuristics perform quite poorly  mlcminstances  sizes   interest ., . therefore  apply.
 heuristic  exploits information obtained  .
bundle method   following way. initially,  consider.
 vector .,  encodes  feasible, random ordering .
 layers.  algorithm stops  . executions. .
step . .    heuristic solution.   duality gap.
  closed   heuristic,  continue  .
bundle iterations   retry  heuristic .retaining .
last vector .
.   .   current primal fractional solution .
.sdpi. obtained   bundle method. compute .
convex combinationr . . ., using.
 random . . ., . compute  cholesky.
decomposition .  .
. apply goemans-williamson hyperplane rounding .
   obtain  . vector  . .
. compute  induced crossing number .  . .
. goto step .
.   satisfies  .-cycle inequalities. set . .  .
goto . else. modify   changing  signs  one.
 three variables   violated inequalities  goto.
step .
. computational experience.
due  licensing issues  overall cpu time  conducted.
 experiments  two different machines.  sdp computations  conducted   intel xeon . .dualcore.  .  ram, running debian .  algorithm.
 runs  top  matlab .
 comparison,  also considered  newly written ilp.
implementation .along  lines  . using branch-andcut. thereby  triangle inequalities  separated  .
fly, instead  adding    initially.    specifically separate  inequalities   ones described .
proposition .   observed  .  even though.
 number  branch-and-bound nodes decreases,  additional effort needed  identify violated constraints.even.
  simple cycle types .  .leads  overall.
increased running times.  also evaluated  ilp variant.
without separation.   approach resulted clearly worse.
running times,   report   code  separation.
 experiments  conducted   intel xeon .
.dual-cpu, quad-core.  .  ram, running debian.
.  . code uses cplex . . default settings.
  . framework.
 codes  run  .bit mode, restricting  .
effectively . ram. note    second machine.
 well   implementation language .   highly.
tuned commercial . solver   expected   faster.
  sdp counterparts. herein     much.
interested   exact running times,    order .
magnitude.     assume   setting .
achieve   comparison,  will  fact see   sdp.
.  . execution,  perform step . .    quite.
expensive,  refrain  executing   often.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
approach outperforms  ilp approach despite  setting.
 restrict  sdp approach  . function evaluations  ., .,   convergence process   bundle.
method mostly slows    point, independent.
 problem size .  every fifth function evaluation .
search  newly violated constraints   current primal.
point.  add  constraints  violation . .  .
bundle  additionally remove constraints  relatively.
speaking small associated lagrangian multipliers . .
. . .mean.   critical operation   first-time initialization   dual variables,   choose  initial.
.  .
.initial duality gap.
. total constraint violation . . violation  constraint .
. graphs  varying densities  argued  .
lp-gap becomes  large  dense instances,  order .
allow practically efficient ilp methods  succeed  .
cases.  argument  supported   known results .
two-layer crossing minimization . hence  start  .
considering  synthetic benchmark    control.
  density parameter.  generated  set  instances.
  . ., . . . , . layers   . ., . . . , . vertices.
  layer.   combination    ,  consider.
random instances  densities  . ., ., . . . , ., .,.
.
.
.
.
edges per layer,   possible edges .
equal probability   selected.   triple ., , .,.
 report  average  . generated instances.
table . summarizes  results   representative.
values  , , .  restricted  ilp approach  . hour.
 computation per instance.  observe   solved.
instances always require less  . minute .except  four.
instances  ., ., .  . minutes, respectively.  .
unsolved instances  gaps  still  large  . hour.
 progress stagnates.
 surprisingly,   observe   graph density.
   important   sdp.   sparse .
dense graphs allow  sdp  find solutions quickly, even.
   instances    complicated cost structure.
. . .   solved within seconds.    hand,.
 ilp approach  applicable    sparse graphs.
  solve  instances   . . thereby    .
order  magnitude faster   sdp. yet,  solves  .
single instance   . . within . hour.
regarding  two-level case,  note   similar.
approach . using  weaker sdp relaxation   able .
solve   . . instances.  ilp approach suggested.
 . considered . random instances   . .,  .
.,  . .  also tested   still available instance  , observing equivalent behavior   random.
instances.
. effects  including  matrix cuts  also already demonstrated.
 exemplary instances  ., subsection .
. real-world graphs motivated    results .
now turn  attention  commonly used benchmark sets .
 area  graph drawing,   considered graphs .
relatively sparse,  investigate  algorithm  deeply.
 instance sets described   said    least.
similar  real-world instances.   knowledge   .
first time   instances  tackled   context  .
exact multi-level crossing minimization.
rome graphs.  rome graphs, originally proposed  .,.
 obtained   basic set  . real-world graphs. .
collection contains .,. instances  . vertices.
 . edges , although originally undirected, .
 unambiguously interpreted  directed acyclic graphs, .
proposed  .
north dags.  north dags   introduced.
  experimental comparison  algorithms  drawing.
dags .  benchmark set contains .,. dags collected  stephen north   slightly modified .
 battista  .  graphs  grouped  . sets, .
set  contains graphs  .  . arcs   . ., . . . , .
 instance sets contain regular graphs,   .
proper level graphs.     regularly used .
benchmarks  sugiyama style drawings,  consider two.
different leveling approaches.
gknv.  indicated   introduction,  first step  .
traditional sugiyama approach   level  given graph.
  multiple strategies  decide   leveling. .
 experiments,  consider  optimal lp-based algorithm .   context,   also evaluate traditional.
multi-level crossing minimization strategies.   tables.
,  will also give  number  crossings  obtained   level-wise barycenter heuristic .sweeping .
 level   solution    improve.
upl. recent algorithms  combined  first  .
second step  sugiyama. framework  obtain  upward.
planarization algorithm . thereby,  planarization .
  crossings  computed without  need  levels.
afterwards,   fitted   smallest leveling allowing .
specified crossing configuration .,  order   applicable.
 sugiyama. third step.  will also consider  layering.
obtained   approach,   allows  much smaller.
number  crossings  practice.  also allows  .
deduce  .thinking inversely.  upl approach gives .
.near-.optimal number  crossings  respect   finally.
computed layering.
results. recall   matrix dimension .   .
depend   original number  vertices . edges.,  .
 derived proper level graph, ., also   number .
artificial vertices   vertex distribution   number.
 layers. hence  algorithm will  mostly dependent.
 . rather   original size. figure . shows .
dependency   different metrics.  calculated.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
sdp ilp.
 . . . . . . . .
 , . , time , time , time , time , time , time , time.
.
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
.
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
.
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
.
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
.
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
., . ., . ., . ., . ., . ., . ., . ., .
table . sdp  ilp approaches  random graphs  representatively chosen values  ,   . . denotes .
number  instances solved  optimality .  . ,.time. gives  average time . seconds.   solved instances.
  ilp,  instance   . .   solved.
 graphs  . . .  . . .   rome .
north instances, respectively,  summarize  results .
table .  benchmark instances, except   small.
graphs,   sparse.  average density   considered.
instances  . . .  ., ., .,  . .
 combinations, rome-gknv, rome-upl, north-gknv,.
 north-upl, respectively.   ilp approach, .
applied  time limit  . hours   instance  . .
.,  . hours  . . .  ilp time limits.
 chosen    sdp approach always finished .
  . function evaluations within  time, ., .
ilp approach   least  much cpu time   sdp.
approach.
table . summarizes  experiments.  first  .
surprising result    approaches   fact  successful   real-world instances,    instances.
  remain unsolved  either   approaches. .
accordance   finding   random graphs,  observe   ilp  usually faster. yet  also observe.
  sdp  stronger  respect  overall solvability.
 solves  instances except  . north-gknv instances.
 ilp approach fails  . graphs, including  aforementioned .   algorithms fail,  sdp approach.
obtained tighter pairs  upper.lower bounds. . .
.  contrast   ilp. .  . .
conclude   sparse graphs one  usually try .
ilp first.   fails  prove  optimal solution within.
. large computation times   leave time   rome instances  . . . . .,   restricted    .
diverse north graphs.
reasonable time,  sdp approach   good chance  succeed   hard instances.
analyzing  distinct benchmark sets,  observe .
 traditional leveling  crossing minimization heuristics.
leave plenty  room  improvement  considering.
 minimum number  crossings.  contrast  ,.
 graphs leveled   upl approach  allow much.
smaller improvements.  fact,  shows   upward.
planarization approach . gives near-optimal solutions .
 respective leveling.  also observe   fact  upl.
produces   smaller levels  requires less crossings.
 beneficial   exact approaches.  solve  upl.
instances,   gknv instances  harder.
. polytopes   instances  literature .
close  experimental study  looking   instances  interest. often, one considers  graphs modeling  incidence relation  faces .corner, edge, .dface,.   .lp-.polytope,  hence   interested .
drawing  within  sugiyama framework.  graphs.
 naturally  dense. table . shows    solve.
 instances  long   dimension   matrix .
within reasonable bounds.  observe   sdp approach  clearly beneficial   ilp. even  polytopes.
   solved  optimality  either approach, .
bounds obtained   sdp  clearly stronger.
 also considered  instances   graphviz.
gallery .    recently suggested  . .
 report   non-trivial instances.  observe .
 ilp implementation gives comparable running times.
   . thereby  approach  much simpler.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
optimal, imp optimal,  imp. ilp.
. . .  .std. diff .max. tlb tub . tlb tub . .opt time.
.
.
.
.
.
.
 . . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
.
.
.
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
.
.
.
.
 . . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
.
.
.
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
. . . . . . . . . . . . . .
table .  results   sdp approach  real-world benchmark instances   . .  results  split  four.
categories. whether   sdp found  proven optimal solution .optimal.,  whether  solution  better  .
one   respective heuristic .imp. . . improvement. .see benchmark description.  instances  grouped.
 matrix dimension .  intervals  .,  .  less   given number. . denotes  number  instances, .
.std. reports mean  standard deviation   optimal crossing numbers, .diff .max. gives  average  maximal.
difference   optimal   heuristic solution. tlb  tub give  average time . seconds.  compute .
lower bound .via  relaxation .sdpi.   upper bound .via  rounding heuristic described  subsection .,.
respectively.  also give  number  instances  solved  optimality   ilp approach .opt.  well  .
average solution time    instances.
 observation validates  finding  .  already.
suggested  additional separation routines need  pay .
 practice. finally  report   traditional real-world.
instances . .  . .   latter,  prior.
publications  considered  subgraph consisting  three.
layers, due   graph. complexity.   first time,.
 also report optimal results   full graph .depicted.
 fig. .    observe   sdp approach .
beneficial  considering   complex instances.
. conclusions.
 presented  systematic investigation  comparison .
different exact approaches  mlcm.  demonstrated .
 semidefinite relaxation provides essentially tighter lower.
bounds   linear programming relaxation. although.
computing  former relaxation   time consuming,.
 experiments demonstrate   pays   practice. .
 sdp approach  relatively independent   graph.
density,    surprising   sdp approach clearly.
dominates  ilp approach  dense graphs. yet,  also.
showed   sdp approach  beneficial  sparse, realworld benchmark sets.
   recent, yet unpublished conference paper,.
gange  . . suggested  sat-based approach  compared    reimplementation  .  concluded .
 ilp dominates  sat-based alternative.  experimental performance   ilp, performed   comparable  .intel xeon ., shows analogous results  .
ilp implementation.   , ., seen  comparing.
 running times   graphviz instances,  proposed.
  paper.  random graphs considered   paper.
 . vertices per level  . levels.
although  necessary   experiments,  want.
 note   sdp approach   combined  .
branch-and-bound scheme  guarantee  optimal solution.
upon termination, even   sdp lower bound  .
induce  optimum. furthermore, .sdpi.   .
tightened  multiplying multiply pairs  different .-cycle.
inequalities   pentagonal inequalities, . .
  course  developing  sdp algorithm,  also.
obtained  seemingly strong sdp-based upper bound heuristic.  heuristic never resulted  worse solutions  traditionally used heuristics, often improving  solutions .
optimality. even   layering obtained  suit  result.
  layer-free upward-planarization heuristic,   regularly able  find even better solutions.  allowed  .
prove many optimal solutions  conjunction   tight.
sdp lower bound.  think   new heuristic ,.
  fast  compute,  already  promising new tool.
 obtain good solutions even  instances    large.
  full sdp approach. although beyond  scope  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
sdp ilp.
type instance   . . tlb tub time prev ilp time.
polytopes.
tetrahedron . . . . . . . .
octahedron . . . . . . . .
cube. . . . . . . .  . .
</doc>
<doc title='alx11_13_decastrop.txt'>
simple  efficient distribution-sensitive.
point location  triangulations.
pedro machado manha.  castro. olivier devillers.
abstract.
 analyze, implement,  evaluate  distributionsensitive point location algorithm based   classical.
jump . walk, called keep, jump, . walk.   batch.
 query points,  main idea   use previous queries .
improve  current one.  practice, keep, jump, . walk.
 actually   competitive method  locate points .
 triangulation. regarding point location   delaunay.
triangulation,  show   delaunay hierarchy  .
used  answer,   hypotheses,  query   .
.log . randomized expected complexity,   .
 previously located query  . indicates  number.
 simplices crossed   line segment .  delaunay.
hierarchy  . logn. time complexity  . memory.
complexity   plane,   certain realistic hypotheses  complexities generalize   finite dimension. finally,  combine  good distribution-sensitive behavior.
 keep, jump, . walk,   good complexity  .
delaunay hierarchy,   novel point location algorithm.
called keep, jump, . climb.   best   knowledge, keep, jump, . climb   first practical distributionsensitive algorithm  works   theory   practice.
 delaunay triangulations.
. introduction.
point location  spatial subdivision   classical problem  computational geometry . given  query.
point    partition   d-dimensional space .
regions,  problem   retrieve  region containing .  paper addresses  special case  .
spatial subdivision   simplicial complex, also called.
triangulation.
 two dimensions, locating  point   solved.
 optimal . space  .log . worst-case query.
time  quarter   century ago  kirkpatrick. hierarchy .  three dimensions, optimal point location remains  open problem .  .log . .
 best worst-case query time one  guarantee, .
.supported  anr project triangles anr-.-blan-.
 .gion paca.
.current address. inria sophia antipolis . .diterrane.,.
france. e-mail. .pedro.machado, olivier.devillers.inria. .
turns     still possible  improve  query.
time   average case  successive queries .
 spatial coherence.  instance, spatial coherence occurs .   queries follow  specific.
path inside  region, .   method .,  poisson surface reconstruction ., . uses point dichotomy.
 find  solution   equation,  .iii.  geographic information systems,   data base contains  huge geographic area,   queries lie .
 small region  interest.   last twentyfive years, computational geometers borrowed  .
classical one-dimensional framework ., ., two ways.
 take  spatial coherence  account  point location algorithms. . using  entropy   query.
distribution ., .,  . designing algorithms .
  self-adapting capability, . algorithms  .
distribution-sensitive ., .
entropy. entropy-based point location assumes.
  distribution   set  queries  known. .
  well-known entropy-based point location data.
structures  two dimensions. arya  . .  iacono .,  achieve  query time proportional  .
entropy   distribution, linear space,  . log .
preprocessing time.  algorithms  asymptotically optimal . however,  many applications .
distribution  unknown. moreover,  distribution .
query points  deliberately change  time. still, .
 possible    better complexity   worstcase optimal  queries   close   .
distribution-sensitiveness.  point location.
algorithm  adapts   distribution   query .
called  distribution-sensitive point location algorithm.
  distribution-sensitive point location algorithms.
  plane exist. iacono  langerman . .
demaine  . .  achieve  query time .
 logarithmic  terms   distance  two.
successive queries   special distances. however.
 space required   linear,  preprocessing.
time   . log .
walk. despite  good theoretical query time .
 point location algorithms , alternative algorithms using simpler data structures  still used .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
practitioners. amongst  algorithms, walking .
 simplex  another using  neighborhood relationships  simplices,   straightforward algorithm.
   need  additional data structure besides  triangulation . walking performs well .
practice  delaunay triangulations,    nonoptimal complexity .
building  walk. building   simplicity.
  walk,   jump . walk .  .
delaunay hierarchy . improve  complexity .
retaining  simplicity   data structure. .
main idea   two structures   find  good.
starting point   walk  reduce  number .
visited simplices.  particular,  delaunay hierarchy.
guarantees  randomized expected .log . worst-case.
query time   delaunay triangulation   plane.
furthermore,  methods based  walking extend.
well   finite dimension ., .,    true.
  aforementioned optimal algorithms.  .
realistic hypotheses,  delaunay hierarchy guarantees.
 randomized expected .log . worst-case query time.
even  delaunay triangulations   d-dimensional.
space. delaunay hierarchy  currently implemented.
  fast location policy   computational.
geometry algorithms library ., ., . .cgal.
contribution.   paper,  propose several.
new ideas  improve point location  practice. .
 hypotheses verified  .real point sets.,  also.
obtain interesting theoretical analysis.
 section .,  introduce  distribution condition.  region    triangulation  satisfies .
condition   expected cost  walking   along .
segment inside     worst case proportional .
 length   segment.  section .,  provide.
experimental evidence   realistic triangulations.
verify  distribution condition   whole region.
inside  convex hull.
 section .,  relate  condition  .
length   arcs   greedy spanning tree embedded  ,   revisit jump . walk   .
make  distribution-sensitive.  modification  called.
keep, jump, . walk.   different setting, haran.
 halperin verified experimentally .  similar.
ideas   plane gives interesting running time  practice.  section .  give theoretical guarantees ,.
  conditions,  expected amortized complexity  keep, jump, . walk      expected complexity   classical jump . walk.  section ., experiments show  keep, jump, . walk,.
  improved performance compared   classical.
jump . walk  .  well. despite  simplicity,   .
competitive method  locate points   triangulation.
 section .,  show  climbing  delaunay hierarchy   used  answer  query  .
.log . randomized expected complexity, .
   point   known location  . indicates  expected number  simplices crossed  .
line segment . climbing instead  walking makes.
keep, jump, . walk becomes keep, jump, . climb,.
 appears  take  best   methods  .
theory   practice.
table . gives  succinct summary  previous works.
  contributions.
. walking   triangulation.
.
figure . visibility graph.
first,   define  visibility graph . , . .
 triangulation    points  dimension   .
query point . . , . . simply     .
ambiguity.   directed graph .,.,    .
set  d-simplices   ,   pair  simplices ., .
belongs   set  arcs   .  .  adjacent .
   supporting hyperplane   common facet.
separates  interior  .  . see figure . .
two simplices .  .    ., . . , .
say  .   successor  . now,  visibility walk.
consists  repeatedly walking   simplex .  one.
  successor     simplex containing  .
found.  walking strategy describes   successor .
chosen.
 following two walking strategies  considered.
  work. .  straight walk   visibility walk.
  visited simplex intersects  segment .
 .  stochastic walk   visibility walk .
 next visited simplex,   simplex .,  randomly.
chosen amongst  successors  .  .
 straight walk   worst-case complexity lincopyright . .  siam .
unauthorized reproduction  prohibited.
.
jump keep, jump delaunay keep, jump,.
. walk . walk hierarchy . climb.
., . .section . . .section .
distribution-sensitive  yes  yes.
expected query complexity . . .log . .log .
time  answer . queries .  . .  . .  . .  .
table . overview  paper. contributions. new results   paper   boldface,  ranges  time.
correspond   performance obtained  several different scenarios.  details   experiments  available .
section .
ear   number  simplices .     delaunay.
triangulation  points evenly distributed   finite.
convex domain     close   domain boundary,  expected number  simplices stabbed   segment   . . ., ., ., . current results .
 complexity   stochastic walk  weaker.  .
known   stochastic walk finishes  probability . ., though  may visit  exponential number .
simplices .even  .   case  delaunay triangulations,  complexity improves  become linear  .
number  simplices.  evenly distributed points, .
. . complexity  also conjectured  stochastic walk,  remains unproved.  practice, stochastic walk answers point location queries faster  .
straight walk .     current choice  cgal.
  walking strategy ., .,   dimensions .
 .
  paper,  use  straight walk   theoretical analysis .sections .  .,   stochastic.
walk  experiments .section .
. distribution condition.
.
.
.
figure . distribution condition.
.left. . . ., .right. . . .
 analyze  complexity   straight walk .
derived strategies  point location,  need .
hypotheses claiming   behavior   walk  .
given region    triangulation   follows.
distribution condition. given  triangulation scheme .  delaunay, regular, . . .,.
  distribution  points  compact support . . ,  . .   triangulation  .
 points following  given distribution .
built upon  given triangulation scheme, .
distribution condition  verified   exists.
 constant . . ,   function  .  . ,.
    segment  . ,  expected.
number  simplices   intersected  , averaging   choice   sites   distribution,  less  . . . . . . .
one known case   distribution condition.
 verified   delaunay triangulations  points.
following  poisson distribution  dimension , .
. . .,   region . see figure .-left.
 believe   distribution condition generalizes.
  kinds  triangulation schemes   kinds.
 distributions.  interesting case seems   .
delaunay triangulation  points lying   manifold.
 dimension . embedded  dimension .  claim .
 relevant dimension   fact  one   manifold.
.see figure .-right.,  claim  supported  .
experiments .section .  stated   following.
conjecture.
conjecture .  delaunay triangulations  dimension    points evenly distributed   bounded.
manifold .  dimension ., verify  distribution condition inside  convex hull  .,  . . .
. keep, jump, . walk.
. jump . walk.  jump . walk technique.
takes  random sample   vertices . dots .
figure .   ,  uses  two-steps location process.
 locate  query . first,  jump step determines .
nearest vertex   sample  .brute-force. . time,.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
qfigure . jump . walk.
  walk    performed   vertex. .
usual analysis  jump . walk makes  hypothesis.
    delaunay triangulation  points evenly.
distributed. taking  . . gives  complexity .
. ., .
. jump . walk revisited.  classical.
jump . walk strategy ., . uses  set   landmarks randomly chosen   vertices   .  query .
located  walking   closest landmark.  ensure adaptation   query distribution instead  using vertices    landmarks,  keep previous queries.
 landmarks. ,   several possibilities. . .
 use  queries chosen  random  previous queries.
.   use   last queries   set  landmarks.  .iii.   keep   queries  landmarks,  regularly clear  landmarks set  .
batch   queries.
  rule  construct  set  landmarks, .
time  process  query  splits .
. keep.  time .  updating  set  landmarks  needed,.
. jump.  time .  finding  closest landmark.
, .
. walk.  time  .  walk    .
 modification performs surprisingly well .
practice, experimental results  method .  provided  section .  also ensure ,   distribution condition,  expected amortized complexity.
 keep, jump, . walk      expected complexity   classical jump . walk.  order  achieve.
  result,  relate  distribution condition .
 length   greedy spanning tree embedded  .
space. analyses   follows consider  straight.
walk   walk strategy.
. location tree.   . ., ., . . . , .  .
sequence  queries.   new query,  walk .
 start   point whose location  already known,.
.  point inside  simplex visited   previous.
walk. thus   segments , . .  . , formed .
.  starting point   i-th walk toward , .
.  , must  connected. therefore  graph .
formed   line segments    tree spanning .
query points.  call   tree  location tree, .
 length  given  . . . .
 variation   algorithm produces  .
location tree.  particular,  location tree produced  keep, jump, . walk   landmarks, .
 input sequence ,   spanning tree  described.
.  build incrementally  sequence  trees.
   . . . ,  . .  . . . .
 . .qiqj.,   qiqj   shortest length.
  . .  . .   called  euclidean minimum.
insertion tree,   denoted  emit . steele .
proved ,   d-dimensional space,  asymptotic.
length  .emit . . .,   .
theorem . .steele .     sequence .
 points  ., .,  . .,     following.
inequality. .emit . . .,  . . . .
.ddd. .
 constant . looks big,    indeed  pessimistic. theorem . gives  better constant  queries.
evenly distributed inside  unit ball.
theorem .     sequence   query points.
uniformly independent  identically distributed  .
unit ball,   expected value  .emit . .
. . . . . . .   . . ,  . .
.
.tdt   gamma function.
 proof   direct consequence   following.
theorem.
theorem . .,  . . .     sequence .
query points uniformly .   unit ball, denoted.
 bunit,   expected length   k-th edge .
emit .   .
. .length. .
.
.
.
.
.
.
 . .,.
.
.
.
,.
 ., . .
. .
.
. .   beta function.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
proof. .proof  theorem .  theorem ., .
   expected length    i-th edge .
.emit .   unit ball  evenly distributed.
points,     .
.
.
.
.
.
.
. ., .
.
. summing .
expression   . edges,  using  stirling.
identity ., . . .,     exists.
. .,     . ., .emit .  bounded.
 . . . . . . . . . . .  .  small  .
want.
. complexity.  distribution condition ensures  relationship   cost  locating points.
  proximity  points.     triangulation   points following  distribution .
compact support  ,   distribution condition .
verified   region    convex hull   ,  expected cost  locating    finite sequence   .
query points lying     .
. . . . .
.
.
.  . .
.
. . . . .
.
.
therefore,  .   expected amortized.
.
. . . . . complexity   queries.
theorem . given  triangulation scheme . .
delaunay, regular, constrained, . . .,   distribution.
 points  compact support . . ,   .
.,   triangulation    points following .
given distribution  built upon  given triangulation.
scheme,   distribution condition holds inside ,.
 keep, jump, . walk answers point location queries.
  expected amortized .
.
.
.
query time.
proof.  simple list data structure   landmarks leads  . . .  . . .
 noticed   .   expected amortized.
.
. . . . . complexity   queries. choosing  . . completes  proof.
  consider  case   points .
evenly distributed,  jump . walk   expected.
.
.
.
.
query time.   apply . . . .
theorem .,  get   expected amortized complexity  keep, jump, . walk. note  theorem . works  non-delaunay triangulations  well,.
  query distribution,  long   distribution condition  verified. besides,  conjecture .
 verified, keep, jump, . walk  use  sample.
 size  . .
.
.
.
 construct delaunay triangulation  points   hypersurface, .
 .   random points   space. .
particular,    .  .   verified.
experimentally  section .,    applied .
surface reconstruction applications.  full paper .
gives  results   obtain varying ., .,.
  .,   distribution condition.
. climbing    delaunay hierarchy.
  section,  show   delaunay hierarchy .
 made distribution-sensitive   hypotheses.
assume    delaunay triangulation,  classical.
use   delaunay hierarchy provides  logarithmic.
cost   total size    locate  point.  cost.
 reach   logarithmic   number  vertices.
     starting point   query.
given  set   points    space,  assume.
  expected size   delaunay triangulation .
 random sample  size     linear size. .
hypothesis always holds  .,   proved  several.
 situations. points randomly distributed  space.
.    hypersurface ., ., ., .  delaunay.
hierarchy . constructs random samples  . . .
. . . . . . . .    prob. . . .  .
. . .   constant . . .   . .
delaunay triangulations     computed .
 hierarchy  used  find  nearest neighbor .
 query   walking  one level    nearest.
neighbor     level . .   proven  .
expected cost  walking  one level  .  since.
 expected number  levels  log. ,  obtain .
logarithmic expected time  descend  hierarchy .
point location.
  good starting vertex  . .  .  known,.
 delaunay hierarchy   used  another way.
 .  walk starts  . visiting simplices crossed .
segment .  walk  stopped, either   simplex.
containing   found,    simplex   vertex .
belonging   sample .  found.   walk stops.
 .  found,   new walk  . starts  .
along segment .  process continues recursively.
   level ,   simplex    contains  .
found. see figure . finally,  hierarchy  descended.
   usual point location. theorem . bounds .
complexity   procedure.
theorem . given  set   points ,   convex.
region  . .,    delaunay triangulation   random sample  size   .
.  expected size .,.
. satisfies  distribution condition   .
. . .   constant .,.
  expected cost  climbing  descending .
delaunay hierarchy   vertex    query point ,.
 lying  ,  .logw.,     expected cost.
  walk        delaunay triangulation.
 .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
.
.
. .
.
.
.
.
figure . climbing.
proof. climbing one level. since  probability .
 vertex   belongs  .  .,   .
time  new simplex  visited   walk  new.
vertex  discovered,  expected number  visited.
simplices   detection   vertex  belongs.
 .    . .
.
. .
.
.
.
. .
.
. .
descending one level.  cost  descending one.
level  . ., lemma .
number  levels.   denote  number .
edges crossed  viq  .  distribution condition.
gives  . .viq. . .  .
  polynomial function .,  expected number.
 levels   climb  descending  less .
 . .logw., since  .
 . .vlq. . .
. . . .logw. . .
.  big    omitted. ,  level .
 walk takes constant time.
please remind   section .,  keep landmarks.
 order  improve  classical walking algorithm,.
 leads  keep, jump, . walk. now,  .
natural  improve  climbing algorithm described.
  adding landmarks  .  well,  starting.
 climbing procedure   good landmark. since.
 complexity  climbing  .logw.,  balance .
different costs,  number  considered landmarks.
 also   .logw.  exactly,  look .
landmarks till  number  seen landmarks  smaller.
  expected cost  climbing  walking .
 best landmark   seen. using  hypotheses.
 theorem .,  cost  given  logw . .log. .
. . . . .log. neither .  .
constant   big  need   known  ensure  .
complexity.  approach  evaluated experimentally.
  next section.
. experiments.
experiments   realized  synthetic  realistic models .scaled  fit   unit cube. .
scanned models used . galaad, pooran. hand,.
 turtle  taken   aim.shape repository.
see figure .  hardware used   experiments.
described   sequel,   macbook pro .,. equipped.
  . ghz intel core . processor  .  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
figure . scanned models.
ram, mac   version .  software uses.
cgal .   compiled  . .  options . -dndebug.   triangulations   experiments .
delaunay triangulations.  experiment  repeated.
. times,   average  taken.  walking strategy.
used   section   stochastic walk.
 consider data sets  . described  table .
uniform cube points evenly distributed.
  unit cube.
anisotropic cube points distributed  .
cube   . . . density.
ellipsoid points evenly distributed.
  surface  .
ellipsoid.  lengths .
 ellipsoid axes.
 ., .,  .
galaad,   data sets.
pooran. hand, obtained  scanning  .
 turtle model   physical object.
table . data sets  .
files  different sizes, smaller   original.
model  obtained  taking random samples  .
main file   desired number  points. twodimensional experiments   reported   abstract.    found  .
. distribution condition.  first set  experiments   experimental verification   distribution condition.  compute  delaunay triangulation  different inputs, either artificial  realistic, .
several sizes.  realistic inputs  construct files .
. . . . .
log .
.
.
.
.
.
.
.
log.
 .
.
.
 cube.
 .slop.
 . .
.
ellip.
soid.
 .slo.
 .
 .
.
pooran.
 hand.
galaad.
aniso.
tropic.
 cube.
 .
turtlecylli.
nde.
 .
ope.
 . .
.
figure . .   interesting cases.  .
 ., .  given   slope   .lines. .
various sizes  taking random samples   desired.
size.
figure . shows  number  crossed tetrahedra .
terms   length   walk,  various randomly.
chosen walks   triangulation.  linear behavior.
  dispersion  shown. though,  .
experiment,  walks  deviates significantly .
 average behavior   likely   faster .
slower,    good news.
 figure .,  slope  lines best fitting .
point clouds give  estimation  .   particular.
 .namely  . .    computations .
several ,  draw .  terms   triangulation.
size  figure .
 .  clearly bounded   polynomial  ,.
 curves  figure .  lie   line.
now,   biggest slope  lines tangent  .
different curves,  evaluate  exponent  . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . . . . .
length.
.
.
.
.
.
sim.
pli.
.
.
. points evenly .
distributed  .
 unit cube.
. . . . . .
length.
.
.
.
.
.
.
.
sim.
pli.
.
.
. points following.
 anisotropic.
ditrib.  .
unit cube.
. . . . . .
length.
.
.
.
.
.
.
.
.
.
sim.
pli.
.
.
. points evenly .
distributed  .
 ellipsoid.
figure . distribution condition.
 clouds  points. .  crossed.
tetrahedra  terms   length  .
walk.  number  points sampled .
 model   . . . . . . .
length.
.
.
.
.
.
sim.
pli.
.
.
. points .
pooran. hand.
. . . . . .
length.
.
.
.
.
.
sim.
pli.
.
 . points ongalaad.
points sampled   ellipsoid give . . ., .
  closed cylinder give . . .,    far.
 conjecture .  claims . . . .
points evenly distributed   cube give . . .,.
   far  . . .   scanned.
models,  curves   bit concave,   slope always.
smaller  .  conjecture .  also verified .
 cases, since  distribution condition claims .
 upper bound    exact value   number.
 visited tetrahedra.
. distribution-sensitive algorithms. now, .
compare  performance  various point location procedures. classical jump . walk .,.
walk starting   previous query .last-point.,.
keep, jump, . walk described  section .
., descending  delaunay hierarchy .classical .,  . . ., climbing  delaunay hierarchy .climb,  . . .,  keep, jump, . climb.
.   later,  use  number  log .
landmarks.  consider  following experiment.
scenarios.
scenario  .  scenario  designed  show.
  proximity  queries relates   point location.
algorithms performance.     scanned model.
 . vertices inside  unit cube,  first define.
,   . ., . . . , .,  .
 vertices   closest  .
.  point location strategies  also implemented  .
javascript demo available  .
.  technique described  section .  optimize  number.
 landmarks   justified   maximal number .
landmarks logn  small enough.   models  . points.
 explore systematically . landmarks.
cube center.    large .resp. small., points .
distributed   large .resp. small. region onm. ,.
 form  sequence   .
. points  taking .
times  random point   .repetitions  allowed.
 slightly perturbing  points.  perturbation.
actually removes duplicates  ensure    .
queries  strictly inside  delaunay tetrahedron .
thus prevent many filter failures. figure .-up shows.
 computation times  point location  different.
strategies  function  .
scenario  .  scenario  designed  show.
  spatial coherence  queries relates  .
point location algorithms performance. imagine .
scenario   random walkers ., ., . . . ., .
walking simultaneously    speed inside .
convex hull  ,    step, queries  issued.
  walker position.  random walker starts .
different positions.   walker, one step consists  .
displacement  length .  one   following directions selected  random. ., ., ., .,., ., ., .,.
 figure .-bottom,  compute  time  complete.
 . queries generated  .  . random walkers,.
 different strategies. one single walker means  .
strong spatial coherence. conversely, several walkers.
mean  weaker spatial coherence.
 walk strategy used   experiments  .
stochastic walk.  guarantee honest comparisons,.
 use   stochastic walk implementation  .
 experiments.  stochastic walk implemented .
cgal ., .
 scenario . figure .-up depicts  running time  . queries. one  observe .
keep, jump, . walk actually benefits  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . . . . . .
sparsity.
.
.
.
.
.
.
.
.
.
.
las.
t-p.
oin.
.
delaunay hierarchy.
., .
.
,  .
 .
.
, .
 . .
. .
climb.
.,  .
 log .
. . . . . . .
sparsity.
.
.
.
.
.
.
.
.
.
.
last.
-po.
int.
delaunay hierarchy.
., .
.
.
, .
 . .
.
.
,  .
 .
climb.
.,  . log.
 .
. . . . .
number  random walkers.
.
.
.
.
.
.
.
.
.
.
last-point . walker around . secs.
delaunay hierarchy.
., .
.,  .  .
.,  . .
climb.
.,  . log.
 .
. . . . .
number  random walkers.
.
.
.
.
.
.
.
.
.
.
last-point . walker around . secs.
delaunay hierarchy.
., .
.,  . .
.,  . .
.
climb.
.,  . log .
figure . experimental results. . scenario  .proximity  queries.  .bottom. scenario  .coherence .
queries.
proximity   queries   clearly better .
jump . walk  even better   delaunay hierarchy   portion     queries lie  .
 .   total surface  . taking . landmarks instead  . performs clearly better  .
another experimental validation  conjecture . .
announced  section .  surprisingly, climbing.
 hierarchy  slower  descending  hierarchy.
    locality  improves  locality.
finally, keep, jump, . climb combines   advantages  appears   best solution  practice .
 experiment.
 scenario  .figure .-bottom.  .
single walker,  spatial coherence   strong.
  expect   good result   last-point.
strategy since  highly benefits  previous location without  overhead  maintaining  structure   case.   indeed  happens, .
keep, jump, . walk  keep, jump, . climb remain.
quite close. ,  course,   number  walkers increases,  last-point strategy becomes  longer.
efficient,  keep, jump, . walk.climb still .
good running times.  interesting observation  .
 keep, jump, . walk  . landmarks  .
seem   strongly dependent   number  walkers.
strong locality. consider  set  . query.
points sampled inside  cube  edge size  . . .
., . . . , . .,  centered   center  .
unit cube. figure . shows  average number  visited.
tetrahedra per query point  various strategies.
. . . . . .
cube edge size.
.
.
.
.
.
. .
vis.
ite.
 .
.
tra.
.
.
.
.,  .      . .
.,  .
 log  . .
last-p.
oint.
delaunay hierarchy.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. . . . . .
cube edge size.
.
.
.
.
.
.
. .
vis.
ite.
 .
.
tra.
.
.
.
.
,  .  .
    . .
.
.,.
  . log .
 . .
delaunay hiera.
rchy.
las.
t-p.
oin.
.
figure . strong locality. average .  visited tetrahedra per query   following data sets. . uniform.
cube.  .bottom. ellipsoid.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
  locality  extremely strong  lastpoint  keep, jump, . walk visit less  .
tetrahedra per query point  average. however since.
keep, jump, . walk   check   closest.
landmark amongst  set  landmarks,  last-point.
strategy   best one   situation.  .
cube edge size  bigger  .,  figure .-bottom.
shows  rapidly degradation   last-point strategy.
performance.  last-point strategy    used.
     priori knowledge   query.
distribution.   locality  strong  data sets.
  huge, strategies based   delaunay hierarchy.
visits  tetrahedra  keep, jump, . walk.
however . keep, jump, . climb needs  smaller.
set  landmarks  keep, jump, . walk,  .
weak locality plus huge data sets . degrade .
performance  keep, jump, . climb   classical.
delaunay hierarchy. see figure .-up  theorem .
.  last optimization. structural filtering.
 exactness   walk  certified  exact computations,   classically accelerated  arithmetic.
filtering.  speed-up  walking procedure even ,.
  use  filtering scheme called structural filtering,.
proposed  funke  . .,  works   higher.
level   classical arithmetic filtering scheme. .
 based   relaxation   exactness   predicates. see figure .
 precisely,  correctness   visibility walk.
relies   exactness   orientation predicates. .
filtering mechanism accelerates  exact computation.
  orientation predicate,   remains slower .
 direct evaluation  floating-point numbers without.
certification   sign. structural filtering extends .
classical filtering mechanism   higher level. instead.
 certifying exactness   orientation predicate,.
 process just certifies   returned simplex.
contains  query. since  walk  mostly dependent.
  performance   orientation predicate, using.
 cheaper predicate will improve  whole performance.
  walk. therefore,  two-phases exact algorithm.
  designed.
.  first phase, called  relaxation phase, consists  running  visibility walk algorithm  .
uncertified orientation predicate.  phase either terminates   simplex  returns  simplex, .
visits  number  simplices   threshold .
 returns  current simplex.  threshold mechanism avoids  possible non-termination   relaxation phase.   case,  phase returns  simplex.
.hopefully.   far   solution. see figure .
.  second phase consists  running  visibility.
walk algorithm   certified orientation predicate.
figure . structural filtering.
starting   simplex returned   relaxation phase,.
  solution  found.  will call  phase .
certification phase. see figure .
point locations described   work  compatible   optimization,   obtained around.
. speed-up. see figure . structural filtering.
 point location  triangulations  implemented .
cgal .
. conclusion.
  work,  analyzed, implemented,  evaluated.
methods  improve  performance  point location.
 triangulation  queries   spatial coherence.  believe   methods  good candidates.
 inclusion   cgal library ., .
 starting  work,  best method  point.
location  triangulations  descending  delaunay.
hierarchy.   method handles . queries   .
points triangulation   . seconds  various.
scenarios.   proposed keep, jump, . climb, .
new way  using  delaunay hierarchy,   .
even faster   classical descent.   reasonable.
amount  spatial coherence   queries, running.
figure . improving  structural filtering. . scenario   structural filtering . .bottom. scenario.
  .
time  improved   factor . . figure .-bottom,.
 running times    low  . depending .
 query coherence.    contrasted .
 classical delaunay hierarchy,  achieves around.
.
 methods  compatible   structural.
filtering technique,  allows  ensure robustness .
numerical issues   cheaper way  usual arithmetic.
filtering   predicates.  using  filtering.
scheme,  improved running times   additional.
.
one   main tools   theoretical analysis .
 work   introduction   distribution condition  relates  expected number  tetrahedra.
intersected   line segment   length.  distribution condition allows   analyze algorithms .
  general context  delaunay triangulation .
evenly distributed points.  example,   derive   work   best size  sample .
keep, jump, . walk,   data points lie  .
surface,  .    usual . furthermore,.
 experiments show   distribution condition.
seems  hold  realistic cases.
  theoretical point  view, climbing .
delaunay hierarchy provides  solution   problem.
 distribution-sensitive point location,   much.
simpler  faster  previous data structures ., .,.
 requires  reasonable hypotheses   point.
set.
  final remark,  emphasize  dichotomy.
  straight  stochastic walk.  straight.
walk  used  theoretical analysis  simplicity .
usage  previous results,   visibility walk  used.
 practice since   faster  easier  implement.
 interesting research direction   get  better.
theoretical basis   use </doc>
<doc title='alx11_14_ajwanid.txt'>
engineering  topological sorting algorithm  massive graphs.
deepak ajwani. adan cosgaya-lozano. norbert zeh.
abstract.
 present  .o-efficient algorithm  topologically.
sorting directed acyclic graphs .dags.  provably.
.o-efficient algorithm   problem  known. similarly,  performance   algorithm,   call.
iterts, may  poor   worst case. however, .
experiments show  iterts achieves good performance  practise.
 strategy  iterts   summarized .
follows.  call  edge satisfied   tail   smaller.
number   head.  numbering satisfying  least.
half  edges   dag  easy  find.  random.
numbering  expected    property. iterts.
starts    numbering   iteratively.
corrects  numbering  satisfy    edges.
  edges  satisfied.
 evaluate iterts,  compared  running time.
   three competitors. peelts,  .o-efficient.
implementation   standard strategy  iteratively.
removing sources  sinks. reachts,  .o-efficient.
implementation   recent parallel divide-and-conquer.
algorithm based  reachability queries.  sets,.
standard dfs-based topological sorting built  top.
  semi-external dfs algorithm.   evaluation.
 various types  input graphs, iterts consistently.
outperformed peelts  reachts,   least .
order  magnitude   cases. sets outperformed.
iterts   graphs whose vertex sets fit  memory.
however, iterts often came close   running time.
 sets   inputs ,  importantly, sets.
  able  process graphs whose vertex sets .
beyond  size  main memory,  iterts .
able  process  inputs efficiently.
.madalgo center  massive data algorithmics, department  computer science, aarhus university, aarhus, denmark.
email. ajwani.madalgo. research  supported  part.
  danish national research foundation. travel   conference  supported  ircset.ibm.
.faculty  computer science, dalhousie university, halifax,.
, canada. email. acosgaya.dal. supported  part .
nserc.
.faculty  computer science, dalhousie university, halifax,.
, canada. email. nzeh.dal.  research .
supported  part  nserc   canada research chairs.
programme.
. introduction.
  . .,.   directed acyclic graph .dag. .
 . . . vertices   . . edges. topological.
sorting   problem  finding  linear ordering.
  vertices      tail   edge.
  precedes  head   ordering. linear-time.
algorithms   problem  covered  standard.
undergraduate texts,  topological sorting captures .
problem  finding  linear order  items  activities.
consistent   set  pairwise ordering constraints,.
 arises   number  applications.  problem.
 topologically sorting large dags arises,  example,.
  application  recent multiple sequence alignment.
algorithms .,.  large collections  dna sequences.
topologically sorting large dags  also  important building block   .o-efficient algorithms,.
mostly due   technique called time-forward processing .,   proven useful  obtaining .oefficient solutions   number  problems  requires.
 vertices   graph   given  topologically.
sorted order. time-forward processing solves  following .graph evaluation. problem. given  dag .
 whose vertices   label ., process  vertices .
topologically sorted order ,   vertex , compute  new label .  .   .-labels  .
in-neighbours.  simple example   type  problem   evaluation   boolean circuit represented .
 dag. . assigns  boolean function   vertex,.
turning    logical gate. .   output  .
gate represented  vertex , given  inputs  receives.
  in-neighbours. since time-forward processing.
requires  vertices   dag   given  topologically sorted order   general .o-efficient topological sorting algorithm  known  date, time-forward.
processing   applied   situations  .
topological ordering   vertices   obtained .
using secondary information   structure  .
dag ., ., ., ., .  general topological sorting.
algorithm  massive graphs  greatly increase .
applicability   technique.
two simple linear-time algorithms  topological.
sorting   repeatedly number  remove sources.
.in-degree-. vertices.   perform  depth-first search.
.dfs.   graph  number  vertices  reverse.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
postorder .  approaches access  vertices .
 unpredictable fashion , thus, usually perform one.
random disk access per vertex  processing inputs.
beyond  size  main memory,  data access.
patterns   high degree  locality   key .
. efficiency,   facilitate  transfer  data.
 memory  disk  large blocks.  lack.
 locality   data access patterns   problem .
 graph exploration strategies,    dfs, .
least  directed graphs. due   strong reliance .
 graph exploration strategies  traditional graph.
algorithms, even simple problems,   topological.
sorting, become challenging  massive graphs.
 significant amount  work  focused  developing .o-efficient graph algorithms.  algorithms  designed  analyzed   . model .,.
 assumes  computer  equipped   twolevel memory hierarchy consisting  internal memory.
 .disk-based. external memory.  computation .
 happen  internal memory,   capable  holding  data items.  transfer  data  internal  external memory happens  means  .
operations .,    transfers  block  .
consecutive data items    disk.  cost  .
algorithm   model   number  .  performs  solve  given problem.
 many problems  undirected graphs,  inefficiency  graph exploration techniques   . model.
  overcome  developing alternate techniques.
 solving graph problems    rely  graph.
exploration.  special graph classes,  wide range .
problems, including topological sorting .,.,.,., .
 solved .o-efficiently using techniques  exploit.
 structure   graphs ., planar separators.
 general directed graphs,    hand, almost.
 .o-efficient solutions  even   elementary.
graph problems  known.  currently best general directed dfs  bfs .breadth-first search. algorithms perform . . . logn. . ., .
 efficient  dense graphs  worse  standard.
internal-memory dfs  bfs  sparse graphs. .
techniques  solving problems  directed graphs without graph exploration  known,  even time-forward.
processing   seen  exploring  graph  .
sources toward  sinks.
 lack  provably .o-efficient algorithms .
directed graphs  led   development   number.
 heuristic approaches  solving problems  directed.
graphs .o-efficiently.  notably, sibeyn  . .
proposed  dfs heuristic  performs extremely well.
  vertex set   graph fits  memory .
breaks   larger graphs.  .,  contractionbased heuristic  computing  strongly connected.
components   directed graph  proposed.  .
paper,  propose  algorithm  topologically sorting.
directed acyclic graphs  falls   category .
efficient heuristics.   worst case,  performance.
 poor,   experiments show   performs well.
 practise   efficiently process graphs beyond.
 reach  existing algorithms, including  algorithm.
based   dfs heuristic  .
 rest   paper  organized  follows. .
section .,  describe  new algorithm.  section .,.
 describe three algorithms  considered reasonable.
competitors.  implemented  algorithms .
compared  performance     algorithm.
 section .,  present  implementation details.
 discuss  experimental setup  results. .
section .,  give  concluding remarks.
. topological sorting  iterative improvement .iterts.
 new topological sorting algorithm, called iterts.
throughout  paper,  based   following strategy. given  numbering .   vertices   dag,.
 call  edge satisfied   tail receives  lower number   head. otherwise  edge  violated. .
satisfied subgraph   dag    dag . whose vertex set    whose edge set consists   edges .
 satisfied  .  computing  initial numbering .   corresponding satisfied subgraph . ,.
 proceed  iterations,    computes  new.
numbering .   previous numbering .,.
  goal  increasing  number  satisfied edges.
 computation  .  . ensures  .
satisfies strictly  edges  . thus,  algorithm  guaranteed  terminate, slowly   worst.
case, quickly  practise.
 description   algorithm consists  four.
parts.  section .,  describe   compute .
initial numbering .  section .,  discuss .
computation   iteration.  section .,  analyze  . complexity   algorithm.  section .,.
 discuss  heuristic  led   tremendous performance improvement.
. computing  initial numbering.
throughout  algorithm,  assume    one.
source .      case,  add  new source .
connect      original sources.  compute.
 out-tree  ,  ,  spanning tree .   whose.
root      whose edges  directed away  .
see figure . since   acyclic,   spanning tree.
  obtained  choosing,   vertex  . , .
arbitrary in-edge   included  .
 choosing  arbitrary left-to-right ordering .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
.
. . .
. . .
. .
.
.
. . .
. . .
. .
.
.
. . .
. . .
. .
.
.
. . .
. . .
. .
.
.
. . .
. . .
. .
.
.
. . .
. . .
. .
.
figure . .  dag   out-tree ., shown  bold. .  two preorder numberings  .  one.
 . satisfies  non-tree edges .bold dashed.    one  choose   first numbering . . .
out-tree . chosen   first iteration. .  numbering .
.
. computed  satisfy  edges  . . .
numbering . . computed  satisfy  edges  . , shown  bold. .  numbering . obtained  sorting.
 vertices according  . .   numbering   order.  satisfied subgraph . , shown  bold,.
contains  edges  . thus, .   topological ordering  ,   algorithm terminates.
 out-edges   vertex  .,  compute two.
numberings .  .   vertices  . see.
figures .  .   preorder numberings.
 . . numbers  subtrees   vertex  leftto-right order,  . numbers  subtrees  rightto-left order.   easy  see  one   two.
numberings satisfies  least half   non-tree edges,.
  satisfy  tree edges.  choose  initial.
numbering .    one  satisfies  edges.
 computation  .  easily carried  .oefficiently.  sorting  edges     heads,.
 scan   edge list suffices  choose one in-edge .
 vertex ,      one vertex without.
in-edges, add  new source   connect    .
vertex. thus, .   constructed using .sort.
.,  sort. . .
.
.
 logm.
.
.
.
  .
complexity  sorting  elements .  numberings.
.  .  easily computed  computing .
euler tour  applying list ranking   computed.
tour .,  takes .sort. .   suffices.
 sort  scan  vertex  edge sets    label.
every edge   numbers assigned   endpoints.
 .  .,  count  edges satisfied  .
numbering,  order  choose .  summary, .
initialization step   algorithm takes .sort.
.
. growing  satisfied subgraph.  iteration   algorithm now computes  new numbering.
.   current numbering .   .
satisfies strictly  edges  .   .
 two phases.   first phase,  compute  outtree      numbering .
.
.  satisfies every.
edge      .
.
. . .,    .  .
  second phase,  compute  numbering . . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
processing  subgraph .   satisfied  .
 numbering satisfies  edges  .   .
property  . . . .,    .  .  obtain.
 new numbering .  ordering  vertices  .
according  . .   numbering  vertices .
  order. next  describe  computation  .,.
. .,  .  detail.
computing .
.
.  construct  tree , .
proceed similar   construction  ., choosing one.
in-edge  per vertex  .    included  . .
time, however,  choose   edge   .
.  maximized. see figure . similar  .
construction  .,  construction   carried .
 sorting  edges     heads   scanning  edge list  choose  in-edge   vertex .
 included  . .recall   edge   labelled.
  numbers .  .   endpoints,.
making  easy  identify  in-edge    vertex   maximizes . next  construct .
euler tour    apply list ranking  compute .
preorder numbering  ,   also  topological ordering  .  sort  vertices     order .
 apply time-forward processing  compute,  every vertex  . , . . max., . . .,.
 . denotes . parent  . see figure .
 sorting  scanning   vertex  edge sets.
 ,   application   euler tour technique,.
list ranking,  time-forward processing   take.
.sort. .  total.
computing .
.
.   second step,  sort .
vertices according  .   edges  .
  tails.   apply time-forward processing  . ,   possible  . defines.
 topological ordering  . . definition, .
satisfies  edges  .  every vertex,  compute . . . max. . . . . . .  . .,.
 ensures  . . satisfies every edge  . .
see figure .  takes .sort. .
computing .  prepare   next iteration,  compute .  sorting  vertices  .
 . .   numbering   order. see figure . using  constant number  sorting  scanning passes,  label every edge   numbers  .
endpoints  accordingly classify  edge  satisfied.
 violated.  takes .sort. .
. analysis.    discussion,  follows.
  initialization   iteration   algorithm take .sort. . thus,  . complexity.
  whole algorithm depends   number  . orderings defined  .  .
.
.
.  identical, .
.
.
.
. may  assign unique numbers  vertices  may assign.
numbers greater   .
erations  algorithm executes.  following lemma.
bounds  number  iterations.
lemma . iterts takes    . . iterations .
satisfy  edges  ,     length   longest.
path  .
proof.   vertex ,  l-dist.   length  .
longest path      .  prove  induction.
   . satisfies  in-edges  vertices  .
l-dist. .  . . thus,   denotes  length  .
longest path  , . satisfies  edges  .
 base case,  . .,  trivial  . . .,.
 . . .,    . . hence,  out-edges  .
 satisfied  .,    superset   in-edges.
  vertices   l-dist. . .
 assume  claim holds   . .  need.
 prove    . .  suffices  prove  . .
satisfies  in-edges  vertices   l-dist. .  . .
 .  obtained  ordering  vertices .
. .   numbering   order.  particular,.
. . . .
.
 . implies . . .,  . satisfies.
 edges satisfied  . .
first  prove  . . . .
.
. . .,  .
  l-dist. . . since every in-neighbour   .
 vertex  satisfies l-dist. .   . satisfies.
every in-edge  ,  implies  . . . . .
. . .
.
 .,  , .
.
 . satisfies  in-edges .
 vertices   l-dist. . .  prove  claim .
induction  l-dist.
 l-dist. . .,    .   . . .
. . . . .     source  .
  root  .  . . l-dist. . , .
 . . max., .
.
. however, .
 l-dist. . l-dist. , hence, .
.
. .
. furthermore, . . .
 .   in-neighbour    .
satisfies  in-edges  .  implies  . .
. similarly,   .
.
 . . max. .
. . . . .  . . every in-neighbour   .
 . satisfies l-dist. . l-dist. hence,  .
induction hypothesis   . satisfies .
edge , . . . .
.
. . . . . . .
.
.,.
 . . . .
.
. . .
 complete  proof,  need  show  . .
satisfies  in-edges  vertices   l-dist. . .
consider   vertex ,      in-neighbour.
 .  parent .      chosen  .
. . . hence, . . . .
. . . . . . .  also  . . .
.,  , .
.
 . . .    hand,.
since    in-neighbour  ,   l-dist. . .
, hence, . . . . thus,  edge  .
satisfied  . . since  argument applies   incopyright . .  siam .
unauthorized reproduction  prohibited.
.
. . . . . . .
. subgraph  processing.
.
. . . . . . .
. subgraph  processing.
figure . local topological ordering  memory-sized subgraphs.  ., vertices  arranged  . . solid.
edges  satisfied edges   subgraph, dashed edges  violated edges   subgraph,  dotted edges .
 one endpoint   subgraph,  ,   local.  .,  vertices  rearranged  ensure  .
edges local   subgraph  satisfied.
edges  vertices   l-dist. .  . .,   .
already shown  . . satisfies  in-edges  vertices.
  l-dist. . ,  finishes  proof. .
 lemma ., iterts  guaranteed  terminate,.
    . . iterations.  many graphs, .
longest path  length significantly less   . .,.
guaranteeing  faster termination   algorithm.
even  graphs  long paths,  experiments show.
,  practise, iterts terminates much faster .
predicted  lemma .
. satisfying local edges.   analysis  .
previous subsection,  cost   algorithm depends.
crucially   number  iterations  needs  satisfy.
 edges   dag.   section,  discuss .
heuristic  helped  reduce  number  iterations.
significantly.
 idea   immediately satisfy violated edges.
whose endpoints  .  far apart.   current.
ordering.   end,  add  following step .
sorting  vertices ofg  . .  numbering  .
order  compute .     list  vertices ofg,.
sorted  . .  greedily break   contiguous.
sublists ,., ,., . . . , ,    subgraph ., .
induced   sublist , fits  memory.  load.
  subgraph ., .  memory  compute.
 topological ordering   vertices, thereby producing.
 new ordered list  .,   vertices  ., . .
concatenate  lists  .,., .
.
,., . . . , .
.
,  obtain .
new ordered vertex list  .     compute.
.  numbering  vertices   .  order. since.
two vertices  different subgraphs ., .  .,.
appear    relative order    .
.
 , .
strategy ensures  . satisfies  edges within .
memory-sized subgraph ., .,  also satisfying.
edges  subgraphs ., .  .,.  .
satisfied  . .   words, using  heuristic,.
 edges satisfied  .   superset   edges.
satisfied  . .   illustrated  figure .
 implement  strategy,  label every edge .
   numbers assigned   endpoints  . .
  produce  list   sorting  vertices .
  . ., using  vertex ids  tie breakers. since.
 defines  total order   vertices  ,  suffices.
 inspect  labels   endpoints   edge  determine  endpoint occurs later  .  call .
 high endpoint,    endpoint  low endpoint   edge.  sort  edges     high.
endpoints.   scan    sorted edge list .
partition   sublists ,., ,., . . . , , , simultaneously, construct  edge lists ,., ,., . . . , , .
 graphsg.,., .,., . . . , .,.   scan,.
 considering  vertex   inclusion   current.
sublist , ,  inspect  edges  high endpoint .
  edge     endpoints  ., . .
     low endpoint  succeeds  first vertex.
  ,  ,    determined using  simple.
comparison   labels    . thus,   count.
 edges  scanning  edges     high.
endpoints  add  count   size  ., . .
determine  size  ., . .  ., . . .
size  mostm ,  add   ,   edges  high.
endpoint   low endpoint  ,  , . otherwise.
 becomes  first vertex   next sublist ,., .
,.  initially empty.   proceed   next.
vertex  .
   constructed  vertex  edge.
lists ,., ,., . . . , ,  ,., ,., . . . , ,  .
manner,  load  graphs .,., .,., . . . , .,.
 memory, one graph   time.    graph.
., .,  compute  topologically sorted vertex list.
 .,  memory  append    vertex list .
.
 .
since  cost   procedure  dominated  .
cost  producing  initial sorted vertex  edge lists,.
 heuristic adds .sort. .   cost  .
iteration.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.  approaches  topological sorting.
   approaches  topological sorting .
 worth considering,    either natural  .
proposed  . efficiency  parallelism  mind ,.
thus, may achieve better performance  iterts,.
 least  certain inputs.   experiments, .
compared  performance   algorithms  .
performance  iterts.
. topological sorting using semi-external.
dfs .sets.  classical method  topological sorting   perform dfs   dag  number .
vertices  reverse postorder . using  strategy.
 top   semi-external dfs heuristic  ., one.
obtains  algorithm  topological sorting  .
  efficient  long   vertex set   graph.
fits  memory.
. iterative peeling  sources  sinks.
.peelts. another classical method  topological.
sorting   iteratively remove sources  sinks. .
algorithm starts   graph . . .  ith iteration identifies  sources  sinks   current graph.
.  numbers , sources   ., sinks .
  .   vertices  removed,  produces  new subgraph  whose sources  sinks .
numbered   next iteration.  algorithm terminates  soon   current graph .  empty.
 naive implementation   strategy requires.
one random access per edge  test,   neighbour.
  removed vertex, whether  becomes  source .
sink   result   removal , thus,  .
numbered  removed   next iteration.  .
experiments,  used  following,  .o-efficient.
implementation.
  iterts,  assume  initial dag  .
one source.  start  arranging  vertices  .
  adjacency lists   order  attempts .
approximate  order   numbered  peelts,.
 order   able  identify sources  sinks .
 peeling round  scanning  sorted list instead.
 using random accesses.   end,  compute.
 out-tree    source   section .,  .
label  vertices     in-  out-degrees.
     depths   .  information .
 computed using  euler tour technique  list.
ranking. now  sort  vertices   adjacency.
lists   depths   .     resulting list.
 preprocessed    manner,  start.
 process  iteratively removing sources  sinks.
 ith iteration   process requires four lists  .,.
 ., .
.
.,  .
.
.  inputs.  lists respectively.
contain  sources  .,  sinks  .,  outedges  .   vertices  .
.
.,   in-edges .
.   vertices  .
.
.  lists .
.
. , .
.
. , .
.
. , .
. required   first iteration  easily computed.
 scanning .
now consider  computation   ith iteration.
numbering  sources  sinks   .  .
.
.  .
simple matter  scanning  two lists.  construct.
 .  .
.
 ,  sort  edges  .
.
.   heads,.
  edges  .   tails. now  scan .
.
.
forward.  every edge  . .,  decrease .
in-degree  vertex     one.  . in-degree .
now .,  mark    adjacency list  deleted  ,.
append    . ,  append . out-edges  .
.
 . .
 ordering   edges  ., locating  heads .
 edges  .     matter  scanning  forward.
    found  heads  edges  .
 processing  edges  .   manner, .
process  edges  . similarly,   exception.
  scan .   backward,   decrease .
out-degrees   tails   edges  .
  number  iterations, deleted elements start.
 accumulate  , contributing unnecessarily  .
cost  scanning .  reduce  scanning cost  , .
compact  periodically.   load factor . . . . .,.
 call  sublist   .-sparse     . . .fraction   elements   sublist  marked .
deleted.   iteration,  find  longest .-sparse.
prefix   prefix   scanned   iteration, .
 longest .-sparse suffix   suffix   scanned.
  iteration,   compact  two sublists .
storing  unprocessed elements   consecutively.
  implementation,  chose . . .,  .
determined experimentally gave  best performance.
. divide  conquer based  reachability.
queries .reachts.  .,  parallel divide-andconquer algorithm  topological sorting based .
reachability queries  described.  implemented .
external-memory version   algorithm.
  dag fits  memory,  load   memory.
 sort . otherwise,  apply  following partitioning strategy.  arrange  vertices   random.
order ., ., . . . , .   use binary search  find.
 lowest index    vertices ., ., . . . ,  .
reach  least . vertices   dag.     set.
 vertices reachable  ., ., . . . , .,   .
  set  vertices reachable  .  algorithm.
now recursively sorts  vertices   sets  .,.
 ., .,  .,  .  concatenates  result. see figure .  correctness   strategy .
shown  .   also shown   expected size .
 set  ., making  algorithm terminate .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.
 . . .
 reachable .
., ., . . . , .
 .
reachable .
 .
. . .
 .
reachable  .
., ., . . . , .
reachable .
., ., . . . , .
 .
figure .  five parts   reachts recurses .
expected logn levels  recursion.
 find  set  vertices reachable   set .
  binary search  finds  index ,  use.
 implementation  directed breadth-first search. .
start  initializing two sets  .    . . .
set    current bfs level.  set  .    set.
 vertices already seen   bfs.   proceed.
 iterations.   iteration,  compute  next.
bfs level .   set  out-neighbours   vertices.
      .   set  .  . . .
 . .   next iteration.  repeat  .
 . .   point,  set    set  vertices.
reachable  .  iteration   directed bfs.
procedure   implemented using .sort. .
 set .   computed  scanning   .
set  edges    find  out-edges  vertices  .
  sort  set  heads   edges  scan.
 resulting sorted list    remove  duplicates.
 vertices  belong     list.  result.
 . since  bfs iteration takes .sort. .,.
reachts   efficient   .diameter.  .
graph  low.
. implementation  experiments.
  section,  discuss  choices  made  .
implementations   different algorithms,  environment  data sets  used  evaluate  algorithms,   results  obtained   experiments.
. implementation.  implemented iterts,.
peelts  reachts  .  using  stxxl.
library .,    implementation   .
stl  external memory computations.  sets,.
 used  implementation provided  andreas beckmann .
 used stxxl vectors  store  vertex .
edge sets   graph.  sorting steps   implementation  accomplished using  stxxl sorting.
algorithm.  implementation  time-forward processing requires  priority queue,    used .
one provided  stxxl.
 used  standard construction   euler tour.
  tree,  generates  list  edges incident .
 vertex  duplicating  edge   sorting.
 edge list.   scan   sorted list suffices .
generate  euler tour . thus,  euler tour  easily.
constructed using stxxl primitives.
 list ranking,  used  algorithm  .
ajwani  . . provided  stxxl-based implementation   algorithm  part   undirected bfs.
implementation,   re-used  code.
. test environment.  experiments  run.
     .ghz intel core . processor, .
 ram,  one . .rpm ide disk using .
xfs file system.  operating system  ubuntu.
. linux   . linux kernel.  code .
compiled using . .  optimization level .
  experiments,  limited  available ram .
. .using  mem. kernel option.    timing.
results refer  wall clock times  hours.
. data sets.  tested  algorithms  synthetic graphs chosen  certain characteristics .
  hard  easy  different algorithms among.
 ones  implemented.  also ran  algorithms.
 real web graphs   edges redirected  ensure.
 graphs  acyclic.  number  vertices  .
graphs   .  .,  number  edges.
 .  .  following   list  graph.
classes  used  evaluate  algorithms.
random.  generated  graphs according .
 , model.  ,  generated  edges,.
choosing  edge endpoint uniformly  random.
  set   vertices.  edges  directed.
 lower  higher endpoints.
width-one.  construct  graphs,  started.
  long path   . . edges.   added.
 .  . . random edges according   ,.
model   random graphs.
layered.  graphs  constructed .
.
 layers .
.
 vertices,  random edges  adjacent layers.  generate  graphs,  first.
chose,   vertex   given layer,  random.
in-neighbour   previous layer   random.
out-neighbour   next layer.   added.
 random edges  adjacent layers  increase  edge count  .
semi-layered. layered graphs consist  many moderately long paths    structured, .
makes  extremely easy inputs  peelts.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
semi-layered graphs aim   moderately long.
paths   less structure.  construct .
graphs,  first constructed  . . layered.
dags ., ., . . . ,  consisting  .
. layers .
size . .   added random edges   dags  generating random quadruples.
., , , .   .    .  ,   .
quadruple, adding  random edge  layer  .
  layer    .
low-width.  graphs  constructed  .
 way  layered graphs. however,  number.
 layers  set  ., ., .   case  .
size   layer  set  ., ., . moreover,.
  first phase   construction   graph,.
 chooses one in-  one out-neighbour per.
vertex,  connected  ith node   jth layer.
  ith node   . . . layer, thereby.
starting  ., ., . disjoint paths  length.
., ., .   added random edges .
layers   layered graphs.
grid.  graphs  formed  taking .
.
.
grid  directing  horizontal edges   right.
  vertical edges .
webgraphs.  web graphs  produced  real.
web crawls   . domain,  . domain,.
  data produced    global crawl.
using  stanford webbase crawler.  .
obtained  http.webgraph.dsi.unimi.
since  graphs   necessarily acyclic, .
redirected  edges  lower vertex ids  higher.
vertex ids.
. experimental results.  main goal  .
experiments   compare  algorithms, study .
  affected   structure   input graph,.
 use  results  recommend  algorithm .
use    a-priory knowledge   graph structure.
table . shows  running times   algorithms .
different input graphs.  order  bound  time.
spent   experiments,  used  following rules.
.  algorithm  given  amount  time  least.
. times  time used  iterts  process  .
input.     produce  result   allocated.
time,  terminated .   indicated  dashes .
 table,  superscripts indicating  amount .
time given   algorithm. .  iterts took .
 one day  process  input   consistently.
faster    algorithms  smaller inputs, .
  run   algorithms   input. .
 indicated  stars   table. . since sets  .
semi-external algorithm  . vertices   fit .
.  memory,    run   larger inputs .
   finish   allocated time   smallest.
input  . vertices .   case   input.
types.
. comparison  running times.  .
exception   second random graph instance, iterts.
outperformed peelts  reachts.  expected,.
random graphs proved   easy instances   algorithms,  usually  factor  less  two .
 running times  iterts, peelts,  reachts.
     inputs, peelts  reachts.
  able  process    inputs   allotted amount  time,  , iterts outperformed.
   least one order  magnitude   inputs. peelts  able  process  layered  grid.
graph instances  tried.  grid graphs,  running.
time  still   . times higher   .
iterts. layered graphs   particularly easy input.
 peelts   preprocessing stage   algorithm ends  arranging  vertices layer  layer,.
  also  order    peeling phase peels.
sources  sinks. thus,  peeling round scans exactly  vertices   removed   graph .
 round.  created semi-layered graphs  eliminate.
 effect ,  expected,  performance  peelts.
broke    graphs. reachts performed better  semi-layered graphs   layered graphs. .
believe    result  somewhat shorter shortest.
paths   semi-layered graphs,  made  reachability queries  reachts cheaper.
 results  web graphs presented  surprise, .
reachts  able  process one   graphs  .
times  time taken  iterts,    able .
process  bigger web graphs. peelts   able .
process    graphs   allotted time.  .
surprising   expected  graphs  behave.
similarly  random graphs, particularly given  .
edge directions  essentially chosen randomly. thus,.
 graphs    posed  challenges.
 inputs whose vertex sets fit  memory, sets.
outperformed iterts   inputs,  iterts.
 faster   inputs. width-one graphs turned.
   particularly easy instances  sets. .
 inputs,   nearly two orders  magnitude.
faster  iterts.  concurs   discussion.
 .,    stated   semi-external dfs.
algorithm performs  well  deep dfs trees. .
expected,  comparison  iterts  sets.
changed dramatically   graph. vertex set  .
fit  memory  . sets   able  process.
   inputs within  allotted time,  ,.
iterts outperformed sets   least one order .
magnitude.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 summary,  conclude  sets   algorithm    used  semi-external inputs,.
 iterts   clear winner  larger inputs.
peelts  reachts   competitive  either sets  iterts.
.  effect   graph. structure. recall  section .   running time  iterts .
determined mostly   number  iterations  needs.
 satisfy  edges   graph.   exception.
 width-one graphs   larger semi-layered graphs,.
 number  iterations needed  iterts  low,.
even though  graph structure   impact .
 number  iterations needed. thus,  performance.
 iterts   considered fairly robust  almost.
independent   graph. structure. width-one graphs.
  larger semi-layered graphs posed  greater challenge. however,  upper bound   number  iterations provided  lemma .   .  .
  input graphs  tested,  iterts needed.
less  . iterations     inputs  .
able  process   input instances   reasonable.
amount  time.
sets   considered equally robust  semiexternal instances, even though  benefits  deep.
dfs trees,  already discussed.  contrast, iterts.
benefits  graphs  short paths, even according   pessimistic prediction  lemma . hence,.
iterts  competitive  sets,  instance, .
semi-external random inputs,  sets  significantly faster  width-one graphs.
  algorithms  much  sensitive .
graph structure.  definition, peelts needs  large.
number  peeling rounds  graphs  long paths.
 example,   smallest low-width graph,  .
  vertices   removed  .,. peeling.
rounds,  peelts finished   .  .
rounds  random graphs.  layered graphs, peelts.
also needed  large number .  rounds.
 reason   good performance  peelts .
 graphs    total cost   rounds .
proportional   total number  vertices, due .
 particular order    preprocessing phase.
arranges  vertices.     true .
low-width graphs,   layered graphs  many.
small layers.  reason  peelts   able .
process    large number  peeling rounds,.
   incurred  overhead leading   cost.
 . per peeling round.  overhead  .
 eliminated   graphs, given  knowledge.
  graph structure,   goal    design.
customized algorithms  individual graph classes.
reachts  perform well  graphs .
low diameter  poorly  graphs  long shortest.
paths,    costly part   algorithm .
 bfs-based reachability queries.  intuition .
confirmed   good performance  random graphs.
  poor performance  layered, low-width, .
grid graphs.  example,  maximum number.
 bfs levels observed   reachability query .
 random instances  .,   smallest lowwidth graph led  reachability queries   .,.
bfs levels   algorithm  terminated. .
performance  semi-layered  width-one graphs,.
however, contradicts  intuition. width-one graphs.
 random graphs, apart   one path visiting.
 vertices.   shortest paths   short,.
  algorithm  perform well,    .
manage  process    instances. conversely,.
semi-layered graphs   fairly long shortest.
paths. yet,  algorithm performed fairly well  .
graphs.
.  analysis  iterts. figure .
shows  running time  iterts  graphs  different types  sizes   fixed density.  expected,.
 running time increased linearly   input size.
 layered  low-width graphs,   number  iterations  nearly independent   size   graph. .
random, width-one,  semi-layered graphs,  number  iterations required   algorithm  terminate.
increased   input size, leading   super-linear.
dependence   algorithm   input size.
another interesting factor  consider   quickly.
 satisfied subgraph . converged   whole.
dag . figure . shows  percentage  satisfied edges   function   iteration number  .
largest input   type.    seen,  .
exception  width-one graphs,  algorithm took .
 iterations  satisfy nearly  edges. even  widthone graphs, .   edges  satisfied   .
iterations,  nearly .  satisfied  . iterations.  implies ,  reasonable assumptions.
  ratio   sizes  main memory .
disk,  edges  remained violated  . iterations fit  memory.    helpful  switch  .
alternate strategy   point,  takes advantage.
  fact  order  avoid  large number  iterations.
 satisfy  remaining edges.    succeed .
finding   strategy.
 final comment concerns  effect   local.
reordering heuristic described  section .  .
running time   algorithm.  became clear relatively.
early    heuristic speeds   algorithm.
tremendously.     run iterts without .
heuristic, except     smaller inputs. .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
graph class   . iterts peelts reachts sets.
iterations time . time . time . time .
random . . . . . . . .
random . . . . . . . .
random . . . . . . . .
random . . . . . . . .
random . . . . . . . .
random . . . . . . . .
width-one . . . . . . . .
width-one . . . . . . . .
width-one . . . . . . . .
width-one . . . . . . . .
width-one . . . . . . . .
width-one . . . . . . . .
layered . . . . . . . .
layered . . . . . . . .
layered . . . . . . . .
layered . . . . . . . .
layered . . . . . . . .
layered . . . . . . . .
semi-layered . . . . . . . .
semi-layered . . . . . . . .
semi-layered . . . . . . . .
semi-layered . . . . . . . .
semi-layered . . . . . . . .
semi-layered . . . . . . . .
low-width . . . . . . . .
low-width . . . . . . . .
low-width . . . . . . . .
low-width . . . . . . . .
low-width . . . . . . . .
low-width . . . . . . . .
grid . . . . . . . . .
grid . . . . . . . . .
grid . . . . . . . . .
grid . . . . . . . . .
webgraph . . . . . . . .
webgraph . .,. . . . . . .
webgraph . .,. . . . . . .
table . experimental results. dashes indicate inputs     processed   algorithm  .
allocated time. superscripts indicate  number  days    run  terminated.  superscript  .
means  run  terminated  . hours. stars indicate   experiments   run, following .
rules stated   beginning  section .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 .
 .
 .
 .
 .
 .
 .
 .
.
.
.
.
.
.
.
.
.
.
.
 .
.
.
.
num. edges .
random.
width-one.
layered.
semi-layered.
low-width.
.
 .
 .
 .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.
.
.
.
.
.
 .
.
.
.
.
 .
.
.
rounds.
random.
width-one.
layered.
semi-layered.
low-width.
grid.
webgraph-uk.
webgraph-it.
webgraph-wb.
.
figure . . increase   running times  iterts  graphs  fixed density . . .  increasing .
. increase   number  satisfied edges per iteration  graphs   . .   . .
graphs  . vertices  . edges,  observed .
reduction   number  iterations   .
 .   .  .   result   heuristic.
  exceptions  grid graphs,  took one.
iteration   without  heuristic,  width-one.
graphs,  took . iterations   heuristic .
  terminated  . iterations without .
heuristic.
. conclusions.
 experiments demonstrated  iterts  sets.
substantially outperform peelts  reachts .
 less susceptible  variations   graph. structure.  sets outperformed iterts </doc>
<doc title='alx11_15_stantoni.txt'>
sampling graphs   prescribed joint degree distribution using.
markov chains.
isabelle stanton. ali pinar.
 berkeley sandia national laboratories.
isabelle.eecs.berkeley.edu apinar.sandia.gov.
abstract.
one    influential results  network analysis.
  many natural networks exhibit  power-law.
 log-normal degree distribution.   inspired.
numerous generative models  match  property.
however,  recent work  shown   .
generative models    right degree distribution,.
   good models  real life networks due.
  differences   important metrics like.
conductance.  believe  ,  part,  many.
  real-world networks   different joint.
degree distributions, .  probability   randomly.
selected edge will   nodes  degree   .
assortativity   sufficient statistic   joint degree.
distribution,     previously noted .
social networks tend   assortative,  biological.
 technological networks tend   disassortative.
 suggest   joint degree distribution .
graphs   interesting avenue  study   research  network structure.  provide  simple.
greedy algorithm  constructing simple graphs .
 given joint degree distribution,   monte carlo.
markov chain method  sampling .  also show.
  state space  simple graphs   fixed degree.
distribution  connected via endpoint switches.  empirically evaluate  mixing time   markov chain.
 using experiments based   autocorrelation .
 edge.
.supported   national defense science  engineering.
graduate fellowship. work performed   sandia national.
laboratories, livermore .
. work  supported   doe ascr applied mathematics program.
.sandia national laboratories   multi-program laboratory.
operated  sandia corporation,  wholly owned subsidiary.
 lockheed martin corporation,   . department .
energys national nuclear security administration  contract.
de-ac.
. introduction.
graphs  widely recognized   standard modeling.
language  many complex systems, including physical infrastructure ., internet, electric power, water,.
 gas networks., scientific processes ., chemical kinetics, protein interactions,  regulatory networks .
biology starting   gene levels,   way   ecological systems.,  relational networks ., citation.
networks, hyperlinks   web,  social networks.
 broader adoption   graph models   last.
decade, along   growing importance  associated.
applications, calls  descriptive  generative models.
 real networks.   common among  networks.    differ statistically.   quantify  differences among  networks. answering.
 questions requires understanding  topological.
properties   graphs,   lead  numerous.
studies  topological properties  many .real-world.
networks   internet  social, biological  technological networks .
perhaps   prominent result coming  .
 studies   existence  power-law  log-normal.
distributions  many quantities   particular .
degree distribution.  number  nodes  degree .
 proportional  .  ubiquity   distribution    motivator  many different generative.
models, like preferential attachment,  copying model,.
 barabasi hierarchical model, forest-fire model, .
kronecker graph model  geometric preferential attachment ., ., ., ., . many   models also.
match  observed features,   small diameter.
 densification . however, recent studies comparing.
 generative models  real networks  metrics like.
conductance show   models   match .
important features   networks .
 degree distribution alone   define .
graph. mckay. estimate shows   may .
exponentially many graphs    degree distribution. however, models based  degree distribution  commonly used  compute statistically significant structures   graph.  example,  modularity metric   standard metric  find communities .
graphs ., .  metric defines  null hypothesis.
  structure   graph based   degree distribution, namely  probability   edge .
vertex     proportional  didj ,   .
 represent  degrees  vertices    .  modularity   group  vertices  defined   much.
 structure deviates   null hypothesis, .
 higher modularity signifies  better community. .
key point     null hypothesis  solely based.
  degree distribution  therefore might  incorrect.   result, better descriptive models  critically.
important.
one way  enhance  results based  degree distribution   use   restrictive feature   .
joint degree distribution. intuitively,  degree distribution   graph describes  probability   vertex.
selected uniformly  random will   degree   .
joint degree distribution describes  probability  .
randomly selected edge will   nodes  degree.
  . note    joint degree distribution.
uniquely defines  degree distribution   graph .
 isolated nodes, graphs    degree distribution may   different joint degree distributions.
 example,  assortativity   network measures.
whether nodes prefer  attach   similar  dissimilar nodes.  similarity  defined  terms  .
node. degree,    sufficient statistic   joint degree distribution  measures  different  joint.
degree distribution   one     edges.
  nodes    degree. studies  .
assortativity  networks show  social networks tend.
  assortative,  biological  technological networks like  internet tend   dissortative ., .
 attempting  use  joint degree distribution   metric  designing generative models,  .
important  know  tractable    work .
 primary questions investigated   paper .
given  joint degree distribution   integer ,  .
possible  construct  graph  size    joint.
degree distribution.   possible  construct  generate  uniformly random graph    joint.
degree distribution.  address    problems   paper    theoretical   .
empirical perspective.
contributions.  make several contributions .
 problem,  theoretically  experimentally.
first,  discuss  necessary  sufficient conditions.
  given joint degree vector   graphical. .
prove   conditions  sufficient  providing .
new constructive algorithm. next,  introduce  new.
configuration model   joint degree matrix problem.
   natural extension   configuration model.
  degree sequence problem. finally, using .
configuration model,  develop markov chains .
sampling  pseudographs  simple graphs .
 fixed joint degree matrix.  prove  correctness.
  chains  mixing time   pseudograph.
chain  using previous work.  mixing time  .
simple graph chain  experimentally evaluated using.
autocorrelation.
 practice, monte carlo markov chains   .
popular method  sampling  difficult distributions. however,   often  difficult  theoretically.
evaluate  mixing time   chain,  many practitioners simply stop  chain  .,., .,. .
.,. iterations without much justification.  experimental design  autocorrelation provides  set .
statistics    used   justification  choosing.
 stopping point.
related work.  related work   roughly.
divided  two categories. constructing  sampling.
graphs   fixed degree distribution using sequential importance sampling  monte carlo markov chain.
methods,  experimental work  heuristics  generating random graphs   fixed joint degree distribution.
 methods  constructing graphs   given.
degree distribution  primarily either reductions .
perfect matchings  sequential sampling methods.
  two popular perfect matching methods. .
first   configuration model .  mini-vertices .
created   degree  vertex,    minivertices  connected. given  perfect matching .
 configuration  edges   graph correspond .
 connected mini-vertices.  allows multiple edges.
 self-loops,   often undesirable.  second.
approach,  gadget configuration model, prevents .
problem  creating  gadget   vertex.   .
degree ,    replaced   complete bipartite.
graph ., .  . .  . . .   . .  . .
exactly one node     connected   .
 , representing edge ., . .  perfect matching.
  model corresponds exactly   simple graph.
 models  pictured  figures .  . respectively   appendix.  use  natural extension .
 first configuration model   joint degree distribution problem.
  also sequential sampling methods .
will construct  graph   given degree distribution.
    based   necessary  sufficient.
erdo.s-gallai conditions   degree sequence  .
graphical .,  others follow  method  steger.
 wormald ., ., ., ., .  combine .
construction  sampling parts   problem  .
.
 .
.
.
.
 .
figure .   left,  see  example   configuration model   degree distribution   graph.
  right.  edges corresponding   graph.
 bold.  vertex  split   number  minivertices equal  . degree,    minivertices .
connected.   edges  shown  clarity.
. . .
. . . . . .
. .
figure .  gadget configuration model.  gadget.
 created   vertex    . shown .
one half   gadget   . . vertices,   .
half   . . . ,     degree.  .
gadget  connected     gadget.  perfect.
matching   graph corresponds   graph  .
correct degree sequence.
 quite fast.  current best work  sample graphs.
 dmax . . .  .mdmax. time .
another approach  sampling graphs   given.
degree distribution   use  monte carlo markov.
chain method.   significant work  sampling.
perfect matchings ., .   also  work.
specifically targeted   degree distribution problem.
kannan, tetali  vempala . analyze  mixing.
time   markov chain  mixes   configuration.
model,  another   gadget configuration model.
gkantsidis, mihail  zegura . use  markov chain.
  configuration model,  reject  transition.
 creates  self-loop, multiple edge  disconnects .
graph.    chains use  work  taylor .
 argue   state space  connected.
amanatidis, green  mihail study  problem .
  joint degree matrix  graphical representation.
   connected representation exists . .
give necessary  sufficient conditions    .
problems,  constructive algorithms.  section .,.
 give  simpler constructive algorithm  creating.
 graphical representation   based  solving.
 degree sequence problem instead  alternating.
structures.
another vein  related work    mahadevan.
 .  introduce  concept  dk-series ., . .
 model,  refers   dimension   distribution.
 .   joint degree distribution.  propose.
 heuristic  generating random .k-graphs   fixed.
. distribution via edge rewirings. however, .
method  get stuck     . node  .
degree    state space   connected. .
provide  theoretically sound method   .
finally, newman also studies  problem  fixing  assortativity value, finding  joint remaining degree distribution   value,   sampling.
 random graph   distribution using markov.
chains ., .  markov chain starts   graph.
  correct degree distribution  converges .
 pseudograph   correct joint remaining degree.
distribution.  contrast,  work provides  theoretically sound way  constructing  simple graph .
 given joint degree distribution first,   markov.
chain   simple graphs    joint degree.
distribution   state space.
notation  definitions formally,  degree.
distribution   graph   probability   node.
chosen  random will   degree . similarly,  joint.
degree distribution   probability   randomly.
selected edge will  endpoints  degree   . .
 paper,   concerned  constructing graphs.
 exactly match  distributions,  rather .
probabilities,  will use  counting definition  .
call   joint degree matrix.  particular,  will .
concerned  generating simple graphs   .
contain multiple edges  self-loops.
definition .  degree vector . .   graph.
   vector  .   number  nodes .
degree   .
 generic degree vector will  denoted  .
definition .  joint degree matrix .jdm.  .
  graph    matrix   .,  exactly .
number  edges  nodes  degree   degree .
 .
 generic joint degree matrix will  denoted .
 . given  joint degree matrix,  ,   recover .
number  edges   graph   .
.
.
.
. ,.
  also recover  degree vector   . . .,.
. ,.  term ,  added twice  kdk.
  number  endpoints  degree    edges .
, contribute two endpoints.
 number  nodes,   .
.
. .
count   include  degree . vertices,  .
  edges   joint degree matrix. given .
 ,   easily get  degree distribution .
joint degree distribution.    . . .ndk .
 ., . . .mjk,. note   .   quite .
marginal   ., . although   closely related.
 joint degree matrix configuration.
model  propose  new configuration model  .
joint degree distribution problem. given    corresponding   create  mini-vertices  every vertex.
 degree .  addition,  every edge  endpoints.
 degree     create two mini-endpoints, one.
 class   one  class .  connect   degree.
mini-vertices   class  mini-endpoints.  forms.
 complete bipartite graph   degree,  .
  forms  disconnected component.  will call.
   components  .k-neighborhood. notice    kdk mini-vertices  degree , .
kdk . , .
.
 , corresponding mini-endpoints .
 k-neighborhood.   pictured  figure . .
 appendix.
take  perfect matching   graph.  .
merge  pair  mini-endpoints  correspond .
  edge,  will   pseudograph .
 exactly  desired joint degree matrix. .
observation forms  basis   sampling method.
degree  minivertices.
class  endpoints.
class  endpoints.
degree  minivertices.
figure .  joint degree matrix configuration model.
 shows just two degree neighborhoods   joint.
degree matrix configuration model.  vertex  degree   split   minivertices   represented.
  circles.   form  complete bipartite.
component    connected   class .
endpoints,  squares.  degree neighborhood .
completely disconnected   others.
. constructing graphs   given joint.
degree matrix.
 erdo.s-gallai condition   necessary  sufficient.
condition   degree sequence   realizable  .
simple graph.
theorem . erdo.s-gallai  degree sequence  .
., ., . . . . sorted  non-increasing order  graphical      every  . , .  . . . .
.
. min., .
 necessity   condition comes  noting.
   set  vertices  size ,     .
.
.
.
internal edges,    vertex     subset,      min., . edges entering.
 condition considers  subset  decreasing degree.
vertices  looks   degree requirements  .
nodes.   requirement     available.
edges,  sequence    graphical.  sufficiency  shown via  constructive havel-hakimi algorithm.
 existence   erdo.s-gallai condition inspires.
  ask whether similar necessary  sufficient conditions exist   joint degree matrix   graphical. .
following necessary  sufficient conditions  due .
amanatidis  . .
theorem .    given     associated.
degree distribution.    realized   simple graph.
    .   integer-valued    .
. ., ,   .   , . dkdl. otherwise, .
, .
.
.
.
.
 necessity   conditions  clear.  first.
condition requires     integer number .
nodes   degree value.  next two  .
 number  edges  nodes  degree  .
 .   .      total possible.
number     edges   simple graph defined  .
marginal degree sequences. amanatidis  . show .
sufficiency   constructive algorithm.  will.
now introduce  new algorithm  runs  .mdmax.
time.
 algorithm proceeds  building  nearly regular.
graph   class  edges, ,. assume .
 .   simplicity.     nodes  degree.
 receives bjk,.dkc edges,  , mod  .
  extra edge. similarly,   degree nodes .
bjk,.dlc edges,  , mod   . extra. .
  construct  simple bipartite graph  .
degree sequence.    done  linear time .
 number  edges using queues   discussed .
observation .   . ,   differences  .
 graph   longer bipartite    .,.
endpoints   distributed among  nodes.  find.
 simple nearly regular graph, one  use bayati, kim.
 saberi. . algorithm  .,. time.
 must show     way  combine  .
 nearly-regular graphs together without violating.
 degree constraints.   . ., ., . . . .  .
sorted nonincreasing order degree sequence  .
 . denote  residual degree sequence  .
residual degree   vertex    minus  number .
edges  currently neighbor . also,  . denote .
number  nodes  degree    non-zero residual.
degree, . . .
.
.
. . .
algorithm . .   .  . . . .   .  . . . .
.
.   .  .
.   . , mod    . , mod .
.  . . . . . bjk,ldk ., . . . .xdk . .
,.
 .
 . . . .  . bjk,ldl . ., . . . . ydl . .
,.
 .
. construct  simple bipartite graph  .
degree sequence . . . .xdk , . . . . ydl.
. else.
.   . ., mod .
.  . . . . .  .,kdk  . .  . . . .xdk .
 .,kdk .
. construct  simple graph    degree.
sequence . . . .xdk.
. end .
. place     matching  nodes  degree.
  higher residual degree  . . . . .
  degree   higher residual degree .
. . . . .   vertices     matched.
  way      degree   .
. update  residual degrees      degree.
node.
. end .
 combine  nearly uniform subgraphs,  start.
  largest degree nodes,   corresponding.
largest degree classes. first,  note   every.
iteration,  joint degree sequence  still feasible .
., ,  .  ., . .  . ., .
.
.
.
.
 will prove  algorithm .  always satisfy.
 feasibility conditions. first,  note  fact.
observation .   ,.
.
 ., . ., .
.
.
.
 follows directly   fact   left hand.
side  summing      endpoints needed  .
  right hand side  summing   available.
residual endpoints   degree distribution. next,.
 note    residual degrees  degree  nodes.
 either .  ., .
observation . ,       . , . . .
 . .
.
.
. .
.
.
. . . . .
lemma .  every iteration,  every pair .
vertices ,    degree , . . . . .
amanatidis  . refer  lemma .  .
balanced degree invariant.    easily proven .
considering  vertices  degree    queue.  .
  edges   assigned,   consider  process.
 deciding  many edges  assign  vertex .
 one  popping vertices   top   queue.
 reinserting    end  times.  vertex.
 assigned edges equal   number  times  .
popped.  next time  assign edges  endpoints.
 degree ,  start   queue    position.
   ended previously.   clear   vertex.
  popped twice without   vertices .
popped  least .
lemma .   algorithm  always greedily.
produce  graph  satisfies  , provided  satisfies.
 initial necessary conditions.
proof.   one key observation   algorithm   maximizes .  ensuring   residual degrees   two vertices    degree never.
differ    .  maximizing  number .
available vertices,    get stuck adding  selfloop  multiple edge.  ,  gather  , .
 degree ,  exists  vertex    . . .,.
   vertices  degree ,  residuals must .
either .  .  means .
.
.
. . . . .,.
 every    observation .
  initial conditions,     every.
,  , . dkdl.  . . provided   degree.
 vertices  non-zero residuals. otherwise,  .
unprocessed pair, , . min., . . .  .
,  case,   clear  , . . .
.
.
.
. therefore,.
 residual joint degree matrix  degree sequence.
will always  feasible,   algorithm  always.
continue.
theorem .  necessary conditions   joint.
degree matrix   graphical imply   associated.
degree vector satisfies  erdo.s-gallai condition.
 proof  included   appendix.
. uniformly sampling graphs  monte.
carlo markov chain .mcmc. methods.
 now turn  attention  uniformly sampling.
graphs   given graphical joint degree matrix using mcmc methods.  return   joint degree.
matrix configuration model.   obtain  starting.
configuration   graphical joint degree matrix .
using algorithm .  transitions  use select .
endpoint uniformly  random,  select  .
endpoint   degree neighborhood  swap  two.
edges   neighbor.   complex version .
 chain checks   swap   create  multiple edge  self-loop. formally,  transition function.
  randomized algorithm given  algorithm .
algorithm . .  probability ., stay  configuration . else.
. select  endpoint . uniformly  random. .
neighbors  vertex .  configuration .
. select  . .  . degree neighborhood.
 neighbors .
. .optional.   graph obtained   configuration  edges  . ., ., ., . .
., ., ., . contains  multi-edge  self-loop,.
reject.
.  .  . ., ., ., . . ., ., ., .
  two chains described  algorithm .
 first,  .  step .   state space .
 pseudographs   desired joint degree matrix.
 second,  includes step .   considers.
simple graphs   right joint degree matrix.
 remind  reader   standard result .
 irreducible, aperiodic markov chain  symmetric transitions converges   uniform distribution .
 state space.      aperiodic, due .
 self-loop   state.   description  .
transition function,   see    symmetric.
  less clear   transition function  .  .
possible  two connected configurations    different number  feasible transitions   given degree.
neighborhood.  show      case  .
following lemma.  proof  included   appendix.
lemma .  transition function    symmetric.
 remaining important question   connectivity   state space   chains.   simple .
show   state space    connected.  note.
    standard result   perfect matchings.
  complete bipartite graph  connected via edge.
swaps . moreover,  space  pseudographs  .
seen exactly   set   perfect matchings  .
disconnected complete bipartite degree neighborhoods.
  joint degree matrix configuration model. .
connectivity result  much less obvious  .  adapt.
 result  taylor .   graphs   given degree.
sequence  connected via edge swaps  order  prove.
.  proof  inductive  follows  structure .
taylor. proof.   included   appendix.
theorem . given two simple graphs, .  . .
  size    joint degree matrix, .
exists  series  endpoint rewirings  transform .
 . . vice versa.  every intermediate graph.
 also simple.
. mixing time   markov chain.
 markov chain    similar  one analyzed.
 kannan, tetali  vempala .   exactly.
use  canonical paths  analysis  show .
 mixing time  polynomial.  result follows.
directly  theorem .  .  chain .  .
  joint degree matrix configuration model.
  viewed  . complete, bipartite,  disjoint.
components.  components  remain disjoint,.
  markov chain   viewed   .meta-chain.
 samples  component   runs one step.
  kannan, tetali  vempala chain  .
component. even though  mixing time   chain.
 provably polynomial,  upper bound   large .
 useful  practice.
 analysis  bound  mixing time   chain .
significantly  complicated.  considered using .
canonical path method  bound  congestion  .
chain.  standard trick   define  path  . .
.  fixes  misplaced edges identified  .
  globally ordered way. however,   difficult .
  chain   fixing  specific edge may .
 atomic, .   proof  theorem .  may.
take   . swaps  correctly connect  vertex .
 endpoint    conflicts    degree.
neighborhoods.  swaps take place   degree.
neighborhoods    local moves.  addition,.
step . also prevents   using path coupling  .
proof   mixing time.
given  bounding  mixing time   chain.
seems   difficult,  use  series  experiments .
substitute  autocorrelation time   mixing time.
. autocorrelation time autocorrelation time .
 quantity   related   mixing time .
 popular among physicists.  will give  brief.
introduction   concept,  refer  reader .
sokal. lecture notes   details .
 autocorrelation   signal   crosscorrelation   signal   given  lag . .
formally, given  series  data .    .
 drawn    distribution   mean .
 variance .,  autocorrelation function  . .
.
. .
definition .  exponential autocorrelation time .
.exp, . lim supt.
.
. log . .
definition .  integrated autocorrelation time .
.int, . .
.
. .
.
. .
.
. .
intuitively,  inherent problem   markov.
chain method   successive states generated  .
chain may  highly correlated.    able  draw.
independent samples   stationary distribution,.
  autocorrelation   set  samples .
   .   number  samples increased.
 autocorrelation time  capturing  size  .
gaps  sampled states   chain needed .
 autocorrelation   .thinned. chain   small.
  thinned chain  . autocorrelation,   must.
 exactly sampled   stationary distribution. .
practice,  estimating  autocorrelation  .
finite number  samples,    expect   .
 exactly .,    expect   .die away.  .
number  samples  gap increases.
 difference   exponential autocorrelation time   integrated autocorrelation time .
  exponential autocorrelation time measures .
time  takes   chain  reach equilibrium  .
cold start,  .burn-in. time.  integrated autocorrelation time  related   increase   variance.
  samples   markov chain  opposed .
samples   truly independent. often,  measurements   , although    necessarily.
true.
  substitute  autocorrelation time  .
mixing time   ,  effect, measuring .
 thing   number  iterations   markov.
chain needs  run    difference .
 current distribution   stationary distribution.
 small.  will use  integrated autocorrelation time.
estimate.
. experimental design  used  markov.
chain   two different ways. first,    .
datasets,  ran  chain  .,. iterations . times.
 used   calculate   autocorrelation values.
  edge   lag  .  .,. .
multiples  .  ,  calculated  estimated.
integrated autocorrelation time,  well   iteration.
time   autocorrelation   edge  drop .
 threshold  .   discussed  section .
 also replicated  experimental design .
raftery  lewis . given  estimates   autocorrelation time   size graph  section ., .
ran  chain   long enough  capture .,.
samples   sample   iterations   chain.
 .   chosen  vary  much smaller.
  estimated autocorrelation time,  much larger.
  samples,  calculated  sample mean .
 edge,  compared    actual mean .
 joint degree matrix.  looked   total variational distance   sample means  actual.
means  showed   difference appears   converging  .  chose  mean   evaluation metric.
   able  calculate  true means theoretically.   unaware  another similarly simple.
metric.
 used  formulas  empirical evaluation .
mixing time  page .  sokal. survey . .
particular,  used  following.
.  sample mean  . . .
.
. .
.  sample unnormalized autocorrelation function.
 . . .
.
. . . . . .
.  natural estimator  .  . . .
.  estimator  .int,  .int .
.
.
.
. .  .   .suitable.
cutoff function.
data sets   used several publicly available.
datasets, word adjacencies ., les miserables .,.
american college football .,  karate club .,.
  dolphin social network .   following.
. .   number  nodes, .   number  edges.
 . .   number  non-zero entries   joint.
degree matrix.
. . . . .
adjnoun . . .
dolphins . . .
football . . .
karate . . .
lesmis . . .
 selected  datasets    size. .
 sequence  length , calculating  autocorrelation .
gap  requires . . . dot products.  experiments.
require   calculate  autocorrelation  .
possible edge   graph  many lags. thus running.
 full set  experiments requires . . log . time.
  prohibitive    large.  section . .
discuss results  suggest   feasible method .
estimating autocorrelation time  larger graphs.
. autocorrelation values   dataset .
 run  calculated  unnormalized autocorrelation values   edge    .  .,.
 multiples  .  randomly selected . run  .
dataset  graphed  autocorrelation values  .
  edges.  present  data   karate .
dolphins datasets  figures .  .   graphs.
   datasets  included   appendix due.
  similarity   two presented.
   graphs exhibit   behavior. .
see  exponential drop  initially,   .
autocorrelation values oscillate around .  behavior.
 due   limited number  samples,   bias due.
 using  sample mean   edge.   ignore.
 noisy tail,   estimate   autocorrelation.
. . . .
.
.
.
.
.
.
.
.
.
number  iterations.
.
.
.
rre.
.
tio.
 .
.
.
.
autocorrelation  iterations  karate.
figure .  exponential dropoff  karate appears.
 end  . iterations.
. . . .
.
.
.
.
.
number  iterations.
.
.
.
rre.
.
tio.
 .
.
.
.
autocorrelation  iterations  dolphins.
figure .  exponential dropoff  dolphins appears.
 end  . iterations.
.dies .   point   mean absolute value .
 autocorrelation approximately converges,  .
 locate  .elbow.   graphs  table .
. estimated integrated autocorrelation.
time   dataset  run,  calculated .
estimated integrated autocorrelation time. given .
 calculated  autocorrelation  lags  . .
.  .,.   dataset,  estimate .  .
times  sum   values.  cut-off function .
used  . . .  . .  . ., .  . otherwise.
 value  calculated   edge.
  dataset,  calculated  following. .
mean, median  maximum values   estimated.
integrated autocorrelation time   edge.  .
graphed  figure .  number   edges represents.
   datasets.  particular,  order  left.
 right   karate, dolphins, lesmis, adjnoun.
 football.  error bars represent  maximum.
 minimum values   edges,   line runs.
  median value   edges.
 three metrics give roughly   picture. .
note    much higher variance  estimated  .
 .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .
.
. .
.
. .
.
.
.
rre.
.
tio.
 .
.
.
.
number  edges.
estimated integrated autocorrelation time.
max.
median.
mean.
figure .  max, median  min values  .
edges   est. int. autocorrelation times.   .
karate, dolphins, lesmis, adjnoun  football.
tocorrelation time   larger graphs.   consider.
just  median values,   autocorrelation time.
appears   linear. however,   consider  error.
bars   maximum   may need  superlinear.
time  guarantee convergence   edges.
.  sample mean approaches  real.
mean   edge given  results   previous experiment estimating  integrated autocorrelation time,  next executed  experiment suggested.
 raftery  lewis . first  note   .
edge ,  know  true value   . . .   . .
exactly ,ldkdl .
,.
. .
    edge  degrees .
 .      dkdl potential ., .
edges  show    graph   fixed  , .
 graph  ,  .   consider  graphs.
  labeled,    see   edge .
 equal probability  showing    consider.
permutations   orderings.
thus,  experiment   take samples  varying intervals,  consider   sample mean  .
edge compared   known theoretical mean.  .
graphs,  took .,. samples  varying gaps depending   estimated integrated autocorrelation time.
  smaller graphs,  took . different samples .
.,. edges.  elided  step   larger graphs.
  saw  small variance. additionally, .
saw   total variational distance quickly converged.
  small,  non-zero value.   smaller graphs,.
karate  dolphins,  repeated  experiment .
.,. samples  show   error  due  .
 .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .
.
tal.
 .
ria.
tio.
.
 .
ista.
nce.
.
.
number  iterations  samples.
percent error  total variational distance, karate.
. samples.
. samples.
figure .  total variational distance   percentage.
  sum  .   karate data.   repeated.
 . runs  .,. samples   . run .
.,. samples.  error bars represent  maximum.
 minimum error   . runs.  line  .
median values.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .
.
tal.
 .
ria.
tio.
.
 .
ista.
nce.
.
.
number  iterations  samples.
percent error  total variational distance, dolphins.
. samples.
. samples.
figure .      graph   dolphins.
data.
number  samples    sampler.  present.
 results  figure .  ,   sample mean .
edge   gap ,  .   true mean,  .
graphed value .
.
 ., . .
.
 .
    figures,  line runs  .
median error   . runs   error bars .
 maximum  minimum values.  note  .
maximum  minimum   close   median .
  within .   intervals.  graphs.
imply    sampling uniformly   gap  .
  karate graph.   dolphin graph,  see.
 similar results,  note   error becomes.
constant   sampling gap  . iterations.
  larger graphs,  took just one series .
samples     following gaps. ., ., .,.
., ., .,  . ,  see consistent.
results, although  residual error  higher.  .
  expected     potential edges.
  graphs,   took relatively fewer samples per.
 .
 .
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .
.
.
 .
.
.
tio.
.
 .
.
.
.
.
.
number  iterations  samples.
percent error  total variational distance  .,. samples.
lesmis.
adjnoun.
football.
figure .  total variational distance   percentage.
  sum  .   . run  .,. samples .
adjnoun, football  lesmis.
edge.  adjnoun,  appear   sampling uniformly.
  gap  .  .  football,  error.
converges  .  . . lesmis also.
appears   converge   .  .
gaps.  results  slightly better   median.
estimated integrated autocorrelation time   .
 datasets.
. max  mean conv. thresh.
adjnoun . . . .
dolphins . . . .
football . . . .
karate . . . .
lesmis . . . .
table .  summary  estimates  convergence .
 three experiments.  values   maximum.
estimated integrated autocorrelation time .max .,.
 sample mean convergence iteration number, .
 time  drop   autocorrelation threshold.
 autocorrelation threshold  calculated  .
 average absolute value   autocorrelation .
less  .
. relationship  mean   edge .
autocorrelation   results  section ., .
considered     relationship   time.
 took   autocorrelation   edge   .die .
 .   edge   run,  calculated .
first time  . passed   threshold .
  values,  looked   mean time  pass.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .
.
.
.
tic.
.
 .
.
 .
.
 .
.
.
number  iterations.
synthetic .
mean iteration   edge.
figure .  time   edge. estimated autocorrelation function  pass   threshold  .
versus .   edge.  synthetic dataset  .
larger range  . values   real datasets  .
significant number  edges   value.
  threshold  created figure .  .
included  graphs  football  dolphins  .
appendix     smaller range  ratios.
 illustrate  effect less well.
  graphs,  suspect     relationship  .   time  pass   threshold. unfortunately, none   datasets contained .
significant number  edges  larger . values, .
 .  .  order  test  hypothesis, .
designed  synthetic dataset  contained  many.
edges  values  .  .   . ., . . . .  describe  creation   dataset   appendix.
 final dataset  created  . edges, .
vertices  . distinct  entries.  ran  markov.
chain . times   synthetic graph.  .
run,  calculated  threshold value   edge.
figure . shows  edges. mean   mean time .
 autocorrelation value  pass  .  see.
    roughly symmetric curve  obtains .
maximum  . . .
 result suggests  way  estimate  autocorrelation time  larger graphs without repeating .
entire experiment  every edge   possibly appear. one  calculate .   edge  sample.
edges  . . . . . one   repeat .
experiments  just  selected edges  order  estimate  autocorrelation time.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .
.
.
.
tic.
.
 .
.
 .
.
 .
.
.
number  iterations.
les miserables.
mean iteration   edge.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .  .
.
.
.
tic.
.
 .
.
 .
.
 .
.
.
number  iterations.
word adjacencies.
mean iteration   edge.
 .
 .
 .
 .
 .
 .
 .  .  .  .  .  .  .  .  .  .
.
.
.
tic.
.
 .
.
 .
.
 .
.
.
number  iterations.
zachary. karate club.
mean iteration   edge.
figure .  time   edge. estimated autocorrelation function  pass   threshold  . versus .   edge  lesmis, adjnoun  karate.
 top  bottom order.
. conclusions  future work.
 paper makes two primary contributions.  first.
  investigation  markov chain methods  uniformly sampling graphs   fixed joint degree distribution. previous work shows   mixing time.
   polynomial,   experiments suggest .
 mixing time    also polynomial.  relationship   mean   edge   autocorrelation values   used  efficiently experiment .
larger graphs  sampling edges  mean  .
 .  repeating  analysis  just  edges.
  allow one  efficiently obtain estimates .
 running time  much larger graphs. initial experimental results  larger graphs following  design.
show  similar polynomial running time.
 second contribution    design   experiments  evaluate  mixing time   markov.
chain.  practice,  seems  stopping time  sampling  often chosen without justification. autocorrelation   simple metric  use,    strong evidence.
  chain  close   stationary distribution .
used correctly.
acknowledgments  authors  like  acknowledge helpful contributions  david gleich, satish.
rao, jaideep ray, alistair sinclair, virginia vassilevska.
williams  wes weimer.
</doc>
<doc title='alx11_16_venkatasubramanians.txt'>
 johnson-lindenstrauss transform.  empirical study.
suresh venkatasubramanian. qiushi wang.
abstract.
 johnson-lindenstrauss lemma states   set.
  points may  embedded   space  dimension .log .  preserving  pairwise distances.
within  factor  . . .  high probability.  .
inspired  number  proofs  extend  result, simplify ,  improve  efficiency  computing .
resulting embedding.  lemma   critical tool .
 realm  dimensionality reduction  high dimensional approximate computational geometry.   also.
employed  data mining  domains  analyze intrinsically high dimensional objects   images .
text. however,  algorithms performing  dimensionality reduction  become increasingly sophisticated,   little understanding   behavior .
 embeddings  practice.   paper,  present.
 first comprehensive study   empirical behavior.
 algorithms  dimensionality reduction based  .
 lemma.
 study answers  number  important questions.
  quality   embeddings   performance  algorithms used  compute . among.
 key results.
. determining  likely range   big-oh constant.
 practice   dimension   target space,.
 demonstrating  accuracy   predicted.
bounds.
. finding .best  class. algorithms  wide ranges.
 data size  source dimensionality,  showing.
  depend heavily  parameters  .
data  well  sparsity.
.iii. developing  best implementation  .
method, making use  non-standard optimized.
code  key subroutines.
. identifying critical computational bottlenecks .
 spur  theoretical study  efficient algorithms.
. introduction.
 johnson-lindenstrauss . lemma . governs.
 projection  high dimensional euclidean vectors.
.supported  part  nsf award ccf-.
  lower dimensional euclidean space.  states .
given  set   points  .,  exists  distribution.
 mappings    projection . jl-transform.
chosen randomly   distribution will project .
data approximately isometrically  .logn.  high.
probability.  lemma  tremendously important .
 theory  metric space embeddings .   also .
critical tool  algorithms  data analysis,   powerful method  alleviate  .curse  dimensionality.
 comes  high dimensional data. indeed, .
 growing interest  applying   lemma directly.
 application settings  diverse  natural language.
processing .  image retrieval .
  original proof    lemma uses measure concentration   sphere,  well   brunnminkowski inequality .,  lemma   reproved.
 improved extensively ., ., ., ., ., ., ., ., ., .,.
., . early work showed   projections  .
constructed  simple random matrices,  newer.
results simplifying  distributions  projections .
sampled , improving  running time   mapping,  even derandomizing  construction. however, even   projection algorithms  become increasingly sophisticated,    little effort put.
 studying  empirical behavior  algorithms .
perform  projections.
  three important questions  come .
 researchers consider using random projections .
reduce dimensionality   datasets.
. since  algorithms  perform  projection.
 randomized,  reliable   quality  .
output  practice.
.  significant   hidden constants  .
.log . dimension   target space. small constants   dimension  make  huge difference.
  behavior  downstream algorithms, since.
 analysis tasks take time exponential  .
dimension.
.  algorithms   best  use,   .
 choice affected  patterns   data. .
last point  particularly important,  data profiles.
 vary dramatically  different applications.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
.  work.   paper  undertake  comprehensive empirical study  algorithms  compute.
 jl-transform.  main contributions   summarized  follows.
.  demonstrate    algorithms considered,.
 distance errors  distributed exactly  predicted   lemma.  also show interesting variations  behavior  highly clustered data.
.  show   constant associated  .
target dimension    small  practice.  .
cases, setting  target dimension   . lnn.
suffices  achieve  desired error rates.
.  determine  .best  class. among  algorithms proposed.  answer will depend heavily.
 data sparsity,   illustrate  settings .
lead  different .winners.  efficiency.
.  find  nontrivial  careful implementations  underlying primitives  needed .
achieve  above-mentioned efficiencies. parameter choices, especially   design   projection matrices, also play  critical role  obtaining.
best performance.
. finally,  identify key bottlenecks   computation  propose new theoretical questions .
 efficient answers will   direct impact .
 performance   algorithms.
. paper outline.  paper  organized  follows.  set  basic definitions  notation  section .     noted  different papers  often.
used different formulations  notations,  attempt.
 set   standard formulation common  . .
present  theoretical overview   main classes .
methods  review  section .,    detailed discussion   implementation  section .
 main experimental results follow  section ., .
 conclude   directions   research .
section .
. definitions.
 johnson-lindenstrauss lemma states    set.
   points  ,  . . ., . .,  exists .
map  .  . .logn.    euclidean.
distances  pairs  points    preserved .
within  . . . factor.  say    mapping.
 distance preserving.   cases .    .
constructions  consider.   constructed  picking.
 random matrix . . .   carefully chosen.
distribution  defining . . .   shown  .
yields  desired distance preservation  probability.
. .  motivates  following definition.
definition .  probability distribution .  .
space  . matrices  said    jl-transform  .
matrix . drawn  random  .  distance preserving.
 probability . .
notes.  linearity   mapping implies .
without loss  generality,   assume   point.
  transformed  unit norm. also  linearity,.
 may merely consider   mapping . preserves.
 norm  . finally,  will assume   . .
  . matrix .,  will refer  .  dense  .
 . nonzero entries,  sparse otherwise. table.
. summarizes  variable conventions   paper.
variable description.
 number  points  projected.
 original dimension   data.
. allowed distortion factor   projection.
 target dimension   projection, taken.
  .log .
.  transformation matrix.
table . variables   paper.
. methods.
 start   review   major themes   design.
 jl-transforms. table . summarizes  asymptotic.
guarantees  construction time, space,  application.
time   methods described.
. dense  sparse projections.  first set.
 approaches  designing  jl-transform  involve.
computing  random  .  matrix . directly. frankl.
 maehara . proposed constructing .  .stacking.  orthonormal random vectors . precisely,.
picking  element uniformly   stiefel manifold.
. indyk  motwani . pointed   .
orthogonality constraint   relaxed  setting .
element  .   random sample   normal distribution  ., . . analysis  later simplified.
 dasgupta  gupta .
  approach yields  dense matrix, .
 lead  slower projection routines.  also requires.
sampling   unit normal. achlioptas improved .
  aspects.   approach, .  constructed .
follows.  element  set  .  probability .,.
  set  .  .  equal probability . .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 resulting matrix  still  sparse,  .
nonzero entries,  practice    enough nonzero.
entries  take advantage  sparse matrix multiplication.
routines.
 will use sparse matrices   nature  subsequent sections,  following matousek .,  will .
convenient  use  parameter   quantify sparsity.
 distribution  matrices  sparsity    element   matrix  independently chosen   zero.
 probability . . .  . otherwise. thus,.
larger values   imply greater sparsity.  construction  achlioptas  now  referred    sparsity  . .
. using preconditioners.    limit .
 practical sparsity achievable via  methods.
problems arise   vector   projected.
  sparse   projection may   able.
 preserve  norm   degree needed. thus,.
 idea   precondition  vector   order .
make  less sparse,  preserving  norm. .
allows    sparse projection matrix  .
otherwise  employed. since preconditioning  .
 mapping    ,   crucial  able .
compute  efficiently. otherwise,  overhead .
preconditioning will cancel   benefits  increased.
sparsity   projection matrix.
 sparsity   vector.    measured via .
.-norm . even . . norms.  .-norm  .
unit vector must lie   range .
.
, .   larger.
 .-norm ,   sparse  vector must  .
 extreme case, . . .,   contains exactly one.
non-zero coordinate. typical preconditioning-based.
jl-transforms work  two steps. first, apply  preconditioning random linear transformation   guarantees .   fixed . . ., ., . . .
 ,  random projection   applied  ,.
 whose sparsity   increased, since  vector .
 now sufficiently dense.
 first method proposed along  lines .
 fast johnson-lindenstrauss transform  ailon.
 chazelle .  preconditioner,  used .
walsh-hadamard matrix  combined   random.
diagonal matrix    entry set  . .
equal probability.  showed    vector .
 . . ., hdx  sparsity   .
.
logn.
 .
  combined    .  sparse projection.
matrix  ,  pij  drawn   ., . .
probability .   set  zero  probability.
.    confused   matrix sparsity defined.
. unfortunately,  literature uses   term  .
concepts.
. . .,   . max. log. ., . subsequently,.
matousek showed .   matrix   instead.
 populated  . entries   manner similar .
achlioptas. construction. specifically,  showed .
pij  instead  set  zero  probability .,.
  . otherwise.
  search  even better projection matrices, dasgupta, kumar  sarlos . showed  instead .
choosing  elements   projection matrix totally.
independently, enforcing dependencies   allows  relaxing   sparsity constraints   matrix.
  adaptation   ailon-chazelle method, .
   remain unchanged,   generated  constructing  random function  . . . .  .
setting .,   .  equal probability,  .
 elements set  . note though,    know.
 data   dense,   ignore  preconditioner.
 directly apply   matrix,   will call .
sparse hash matrix.
. combining projections  preconditioners.  turns    preconditioning transforms also satisfy  metric preservation properties.
  johnson-lindenstrauss lemma    applied quickly,    reduce  dimension .
 data. ailon  liberty . proposed  use.
 non-square hadamard-like preconditioners . socalled lean walsh matrices.    preconditioning.
 dimensionality reduction    step.
  .  matrix    seed matrix    fewer.
rows  columns . . .,   entries  magnitude.
.
.
,    rows    orthogonal. given .
valid seed matrix,  lean walsh transform  found .
recursively .growing.  matrix  taking  kronecker.
tensor product   seed   current matrix. .
final projection combines  lean walsh transform  .
random diagonal matrix, defined     .
two additional methods bear mentioning  .
  test   paper. ailon  liberty used.
bch codes .   speed   transform, .
 improvements primarily   .large . range.
since  method requires  . . memory issues.
.including large constants. made  prohibitive  test.
 recently, ailon  liberty presented  almost.
optimal  transform . . terms  running time. .
 context   paper,  technique   seen  .
lean walsh transform .lwt.   maximum seed.
size.  running time  dominated   time needed.
 perform  walsh-hadamard transform  .
will examine   detail.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
technique construction time space requirement application time .per point.
dense ., ., ., . . . .
sparse . . . . . . .
fjlt . . . . . log . .
sparse jlt . . . . log .
lean walsh . . . .
table .  summary   different methods  compare   paper.
. implementations.
  exception   code  computing .
walsh-hadamard transform .see section . ., .
use matlab .   implementation platform. .
    following reasons.
. matlab  heavily optimized matrix manipulation routines   sparse  dense matrices.
. matlab   platform  choice  machine.
learning implementations   areas .
dimensionality reduction  employed,  thus .
will  easy  embed  code  higher-level data.
analysis tasks.
. matlab lends   easy prototyping .
testing.
. random projections. random projectionbased methods  straightforward    simply.
store  transformation matrix  apply  directly .
matrix multiplication.   sparsity parameter  increases,  number  nonzero entries decreases, .
 becomes  effective  use  built-in matlab.
routines  representing  operating  sparse matrices .via  matlab declaration sparse. since.
 storage  use  sparse matrices incurs overhead,.
one must  careful  declaring  matrix  sparse,.
 declaring  dense matrix   sparse  actually.
yield worse performance  performing direct multiplication.   experiments,  . approaches use.
dense representations,   matrix   sparsity.
parameter  . .  declared  sparse.
. using preconditioners.  walshhadamard transform.   fjlt  sparse.
jlt employ three matrices.  random diagonal matrix.
,  hadamard matrix ,   sparse projection.
matrix  .  sparse matrix   stored  used .
 describe  section . applying    vector.
  effectively  coordinate-wise multiplication .
two vectors,   matlab provides  special.
operation . .    effective  applying  .
 block  vectors . see section .  remains  .
application   walsh-hadamard transform .wht.
  two ways  implement  wht .
matlab.  easiest approach   merely treat .
transform   dense matrix  perform direct matrix.
multiplication.  however takes . time  compute hdx  requires . storage. fortunately,  .
variant   fourier transform,   known efficient.
methods  computing  transform  . log . time.
 matlab comes   native implementation .
 fwht. however, tests showed   runtime .
 routine  actually slower  direct multiplication   hadamard matrix.    critical.
problem since  running time   wht becomes.
 main bottleneck   overall computation.
spiral.  overcome  problem,  turned .
spiral . spiral   signal processing package.
 provides  efficient implementation   wht,.
customized  local machine architectures.   written.
    used mex  build  interface  order .
invoke   inside matlab.
two aspects   data transfer  matlab.
 spiral require  care. firstly, spiral.
operates  blocks  memory  size .  matlab.
transfers  row-major representation   input points,.
 spiral  operate   memory block .
. however,   representation  column major.
.   standard representation,  points .
column vectors.,   data    transposed.
prior  applying spiral. secondly, spiral .
operate directly  sparse data,    input vectors.
need   stored  dense form.  mention  .
point   additional work needed  make use .
  complex methods versus  simple .
implementations   wht.
.  lean walsh transform. recall  .
lean walsh transform  constructed  first forming.
  .  seed matrix ,   repeatedly taking.
powers via  kronecker product.  transform.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
   applied recursively, exploiting  structure.
  kronecker .power.  seed matrix  .
constructed  taking   rows   hadamard matrix,.
  necessarily    power  two. note  .
seed matrix   applied    length vector .
either direct multiplication   computing .
wht  just keeping  entries.   recursive.
structure,  seed matrix   applied   .
final step,   typically sufficiently small  .
use direct multiplication rather  going  .
overhead  spiral.  described  .,  overall.
running time  compute  transform   . .
.
.
 crc.
.
,   choosing  smaller seed matrix yields.
better constants   running time.
 structure   lwt  make choosing .
seed matrix quite inconvenient. suppose  wish .
embed .-dimensional points  k-dimensional space,.
  . ., .   seed matrix  shape . . .,.
 need  determine  power     .  .
 . . since . . .  . . . . , taking .
sixth power   seed matrix   sufficient.  now.
 three choices.   take  seventh power .
 seed, yielding  . . matrix  requires.
massive padding  zeros   dimensions.  .
choose  different seed matrix  shape . . . .
 . .   . . .   also choose .
seed matrix  shape  . .   . . . .
 matrices might require less padding,  increase.
 running time   overall transformation .since.
     larger.,  determining  optimal.
parameters   given instance  quite difficult.
. results.
experimental setup.  experiments  run.
  quad core . ghz processor  .  ram,.
 .-bit matlab version . ., .
spiral version .   tests, unless stated.
otherwise,  .  . lnn. .  testing  dense .
sparse direct projection methods,  fix  . .
  roughly  upper bound    still.
comfortably test values    matlab  running.
  memory. finally  took . . .  .
choice  arbitrary,  will see   quality .
nature   results remains consistent  values  .
 performance tests, varying   effectively identical.
 varying ., since   parameter depending  .
 .  .  timing data point   result .
averaging . runs.
.  also select   rows   discrete fourier.
transform matrix  remove  constraint  , although  .
case   end    complex-valued transform  .
potentially undesirable.
data generation.  generated three kinds .
random data   ., . cube. dense data.
 generated  sampling  element uniformly.
 ., . sparse data  generated  choosing.
 . . dimensions  random,   populating.
 dimension randomly  . clustered data.
 generated  fixing  number  clusters ,.
choosing  points  random   cube,  .
generating equal numbers  points . around .
cluster center.  also experimented  almost lowdimensional data, generated  sampling data  .
randomly chosen low dimensional subspace  .
perturbing    full-dimensional gaussian.  results.
  datasets  essentially     .
full dimensional data,      present separate.
results   case.
block evaluations. matlab  optimized .
direct multiplication  blocks,    often faster .
multiply  transformation   matrix  points, rather.
 performing  set  matrix-vector operations. however,  large datasets,    apply  transformation  chunks  data   time. , .
wht implementations .  matlab  spiral.   appear   optimized  block operations. hence   paper  report times based .
point-evaluations.
. . . . .
dense.
. . . . .
sparse hash.
. . . . .
fjlt.
. . . . .
lwt.
figure . comparison  distortion distributions .
dense data.
. quality  projections.  start   evaluation   quality   embedding.   , .
project  given dataset using     algorithms,   compute  distortion incurred .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
 norm   point .recall  norm preservation .
distance preservation  equivalent  linear maps.
  plot  distribution   resulting distortion.
values.
perhaps surprisingly,    methods  examined yield distortion distributions   nearly indistinguishable. figure . shows   set  dense.
points . . . random points  . projected .
different methods,    produce distributions.
  highly gaussian  low variance.  .
examples,  . .     use  lean walsh.
transform   . .   seed matrix  dimension.
. .
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
min mean max.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
figure . min, mean, max,  variance   distortion  embeddings    increased.
 results   stable   varies,  shown.
 figure . additionally,  variance   distortion decreases  , roughly  .,   .
predicted.
projecting clustered data. projecting uniform.
random data produces distortions   strongly.
gaussian  even small values  . given highly.
structured data, however, distortion distributions .
become skewed.  instance,  left panel  figure .
shows distortions  projecting five clusters  data.
  cluster distortions    desired range,.
 cluster incurs  systematic bias   embedding.
. . . . . . .
single run.
. . . . .
. runs.
figure . distortions  projecting highly clustered.
data  five clusters . left. cumulative distortion.
distribution  repeatedly applying random projections    data . right.
   contrast   right panel,  depicts.
 cumulative distortions averaged  multiple random projections,  yields  expected distribution.
 distortions.  distinction  important.  many.
applications   common  apply  single random projection  reduce dimensionality  data.   .
guaranteed   distortions stay   prescribed.
range,    longer assume   looking .
individual clusters  data   errors  distributed.
nicely,   may affect future analysis  probes.
individual clusters.
projecting real data.  examine two datasets.
  uci machine learning repository . .
dexter . test dataset  . instances  .
dimensions.    sparse, bag-of-words representation.
 ,  average, . nonzeros per element.  .
. dataset  dense  . instances  dimension.
. figure . shows  distortion distributions .
 two real world datasets.  . projections.
exhibits  clustering behavior   distributions.
fall well within  guarantees  behaves consistently.
 synthetic data.
. . . . .
dexter.
. . . . .
. mutants.
figure . distortion distribution  projecting real.
datasets.
determining  exact value  .  .
proofs    lemma,  number  dimensions.
 controlled   number  norm measurements.
needed.   histograms shown ,  distortion ranges  fall well within  predicted range .
., ., suggesting   may  able  use fewer.
dimensions  . lnn. figure . compares distortion ranges  norm preservation . measurements.
 distance preservation .
.
.
.
.
measurements.  .
vary . notice   error range  distance preservation  close   predicted value.
 suggests  following estimation procedure.
plot  minimum  maximum distortions obtained.
 projecting   .  lnn. dimensions, .
determine   bounds satisfy  desired theoretical range . . ., . . . figure . illustrates .
results   procedure. notice   measurement.
 norms,  constant    close  .,  .
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. . . . .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
single norms.
. . . . .
.
.
.
.
.
.
.
.
pairwise distances.
. distortion ranges  .
. . . . .
.
.
.
.
.
.
.
.
.
.
single norms.
. . . . .
.
.
.
.
.
.
pairwise distances.
. distortion ranges  .
min mean max.
figure . illustration   embedding distortion.
ranges change  single points  pairwise distances.
  vary   adjusting .  .
measuring pairwise distances,  constant    little less  .  indicates   bound provided.
   lemma   tight,    written .
 . dlnp.,     number  norm measurements   preserved.
. performance  direct projections.  now.
evaluate  performance  methods based  direct.
random projections  dense matrices . . .  well.
 sparse matrices  . . figure . compares  time.
needed  project  single point   data using matrices.
 varying values  .
consider first  left panel  figure .,  .
evaluate  projection methods  dense data. ,.
 dense matrix initially performs better  .
matrix  sparsity  . .,   overhead  .
sparse representation.   matrix  sparse enough.
. . . . .,  advantage  sparsity wins .
notice    increases .  decreases.  benefits.
 using  explicit sparse representation reduce, .
  . . .around  . .,   remains  .
overhead   sparse representation.
 sparse data,  similar picture emerges,  .
 sparse matrices initially outperforming  dense.
 near-dense approaches,  eventually matching.
.   different   case   .
 input data  sparse, matlab  able  optimize.
 multiplication  dense  sparse  efficiently,.
leading   superior relative performance  .
dense matrix . methods  still orders  magnitude.
faster  sparse data   dense data.   .  .
  nonzero entries,  direct matrix multiplication.
takes . time   sparsity advantage   .
matrices becomes much less pronounced.
  figures,  interesting anomaly . noticeable  sparse data. emerges  . .  . . .
 matrix .stored  sparse. becomes fully dense, matlab appears    form  optimization, boosting.
 performance   fully dense sparse matrix past.
    . . sparse matrix.  asymptotic behavior   point  follows    dense.
projection,    additional overhead  .
stored  sparse.
stability  distortions  increasing matrix sparsity.     methods store  entire matrix  memory, requiring . storage. .
points   easily streamed, implementing  similar.
solution   projection  much  cumbersome,.
    zeros   projection matrix .
 crucial   able  actually use  methods.
  increase  sparsity however,  projection becomes increasingly unstable. figure . illustrates  distortion   set   . . dense  sparse points.
 ranges  .   increases .making  projection.
matrix  sparse.,  norms   projected vectors tend  .  optimal  giving distortions still.
within  bounds depends  , ,  .  well .
 data sparsity.  surprisingly,  deterioration.
 quality   rapid  projections  sparse data.
  dense data.  motivates  addition  preconditioners,  gives upper bounds  data sparsity.
 preserving  norm   original vector.
. . . . . .
.
.
.
.
.
.
.
.
.
.
dense data.
. . . . . .
.
.
.
.
sparse data.
min mean max.
figure . variation  distortion range  embeddings.
 sparsity. larger  indicates greater sparsity.
copyright . .  siam .
unauthorized reproduction  prohibited.
.
. .
.
.
.
.
.
.
.
.
.
dense data.
. .
.
.
.
.
sparse data.
dense  . .  . . . .
figure . runtimes  projecting  single data point  direct multiplication  projection matrices .
varying sparsity. increasing  directly increases  target dimension . vertical bar indicates  . .  . .
.  walsh-hadamard transform.   approaches  consider,  walsh-hadamard transform .
 preconditioner  choice. figure . compares  time.
needed   different methods described  section .
 perform  transform   .including direct matrix.
multiplication  sparse data.
. . . . .
.
.
.
.
.
.
.
.
.
.
. matrix multiply.
matlab fwht.
spiral fwht.
matrix multiply .sparse.
figure . runtimes   increases  different walshhadamard transform methods.
 general,  spiral.mex implementation .
much faster   grows   reasonable size. .
 see   sparse data, direct matrix multiplication.
  viable option    data    .
dimensions,     option.
. determining  .best  class. figures .
 . indicate   long   data  known  .
reasonably dense,   avoid  use   preconditioner.   case,   efficient projection matrix.
  sparse hash matrix    used   sparse.
jlt. conversely,   data  known   sparse, .
 </doc>
</xml>
